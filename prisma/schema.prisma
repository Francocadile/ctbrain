// src/app/api/ct/rivales/[id]/plan/route.ts
import { NextResponse } from "next/server";
import { PrismaClient } from "@prisma/client";

export const dynamic = "force-dynamic";
const prisma = new PrismaClient();

// Estructuras de datos esperadas
type RivalReport = {
  system?: string | null;
  strengths?: string[];
  weaknesses?: string[];
  keyPlayers?: string[];
  setPieces?: {
    for?: string[];
    against?: string[];
  };
};

type RivalPlan = {
  charlaUrl: string | null;
  report: RivalReport;
};

export async function GET(
  _req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const id = String(params?.id || "");
    if (!id) return new NextResponse("id requerido", { status: 400 });

    const r = await prisma.rival.findUnique({
      where: { id },
      select: {
        planCharlaUrl: true,
        planReport: true,
      },
    });

    if (!r) return new NextResponse("No encontrado", { status: 404 });

    const data: RivalPlan = {
      charlaUrl: r.planCharlaUrl ?? null,
      report: (r.planReport as RivalReport) || {},
    };

    return NextResponse.json({ data });
  } catch (e: any) {
    return new NextResponse(e?.message || "Error", { status: 500 });
  }
}

export async function PUT(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const id = String(params?.id || "");
    if (!id) return new NextResponse("id requerido", { status: 400 });

    const body = (await req.json()) as RivalPlan | undefined;
    if (!body) return new NextResponse("body requerido", { status: 400 });

    const charlaUrl =
      typeof body.charlaUrl === "string" && body.charlaUrl.trim()
        ? body.charlaUrl.trim()
        : null;

    // Sanitizar mÃ­nimamente el reporte
    const report: RivalReport = {
      system:
        typeof body.report?.system === "string" && body.report.system.trim()
          ? body.report.system.trim()
          : null,
      strengths: Array.isArray(body.report?.strengths)
        ? body.report!.strengths.map((s) => String(s).trim()).filter(Boolean)
        : [],
      weaknesses: Array.isArray(body.report?.weaknesses)
        ? body.report!.weaknesses.map((s) => String(s).trim()).filter(Boolean)
        : [],
      keyPlayers: Array.isArray(body.report?.keyPlayers)
        ? body.report!.keyPlayers.map((s) => String(s).trim()).filter(Boolean)
        : [],
      setPieces: {
        for: Array.isArray(body.report?.setPieces?.for)
          ? body.report!.setPieces!.for!.map((s) => String(s).trim()).filter(Boolean)
          : [],
        against: Array.isArray(body.report?.setPieces?.against)
          ? body.report!.setPieces!.against!.map((s) => String(s).trim()).filter(Boolean)
          : [],
      },
    };

    const row = await prisma.rival.update({
      where: { id },
      data: {
        planCharlaUrl: charlaUrl,
        planReport: report as any, // Prisma Json
      },
      select: {
        planCharlaUrl: true,
        planReport: true,
      },
    });

    const data: RivalPlan = {
      charlaUrl: row.planCharlaUrl ?? null,
      report: (row.planReport as RivalReport) || {},
    };

    return NextResponse.json({ data });
  } catch (e: any) {
    return new NextResponse(e?.message || "Error", { status: 500 });
  }
}
