
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model GlobalConfig
 * 
 */
export type GlobalConfig = $Result.DefaultSelection<Prisma.$GlobalConfigPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserTeam
 * 
 */
export type UserTeam = $Result.DefaultSelection<Prisma.$UserTeamPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Rival
 * 
 */
export type Rival = $Result.DefaultSelection<Prisma.$RivalPayload>
/**
 * Model PlayerFeedback
 * 
 */
export type PlayerFeedback = $Result.DefaultSelection<Prisma.$PlayerFeedbackPayload>
/**
 * Model Place
 * 
 */
export type Place = $Result.DefaultSelection<Prisma.$PlacePayload>
/**
 * Model ExerciseKind
 * 
 */
export type ExerciseKind = $Result.DefaultSelection<Prisma.$ExerciseKindPayload>
/**
 * Model Exercise
 * 
 */
export type Exercise = $Result.DefaultSelection<Prisma.$ExercisePayload>
/**
 * Model RPEEntry
 * 
 */
export type RPEEntry = $Result.DefaultSelection<Prisma.$RPEEntryPayload>
/**
 * Model WellnessEntry
 * 
 */
export type WellnessEntry = $Result.DefaultSelection<Prisma.$WellnessEntryPayload>
/**
 * Model PlannerPrefs
 * 
 */
export type PlannerPrefs = $Result.DefaultSelection<Prisma.$PlannerPrefsPayload>
/**
 * Model ClinicalEntry
 * 
 */
export type ClinicalEntry = $Result.DefaultSelection<Prisma.$ClinicalEntryPayload>
/**
 * Model ScoutingCategory
 * 
 */
export type ScoutingCategory = $Result.DefaultSelection<Prisma.$ScoutingCategoryPayload>
/**
 * Model Player
 * 
 */
export type Player = $Result.DefaultSelection<Prisma.$PlayerPayload>
/**
 * Model ScoutingPlayer
 * 
 */
export type ScoutingPlayer = $Result.DefaultSelection<Prisma.$ScoutingPlayerPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model TeamVideo
 * 
 */
export type TeamVideo = $Result.DefaultSelection<Prisma.$TeamVideoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  SUPERADMIN: 'SUPERADMIN',
  ADMIN: 'ADMIN',
  CT: 'CT',
  MEDICO: 'MEDICO',
  JUGADOR: 'JUGADOR',
  DIRECTIVO: 'DIRECTIVO'
};

export type Role = (typeof Role)[keyof typeof Role]


export const TeamRole: {
  ADMIN: 'ADMIN',
  CT: 'CT',
  MEDICO: 'MEDICO',
  JUGADOR: 'JUGADOR',
  DIRECTIVO: 'DIRECTIVO'
};

export type TeamRole = (typeof TeamRole)[keyof typeof TeamRole]


export const SessionType: {
  GENERAL: 'GENERAL',
  FUERZA: 'FUERZA',
  TACTICA: 'TACTICA',
  AEROBICO: 'AEROBICO',
  RECUPERACION: 'RECUPERACION'
};

export type SessionType = (typeof SessionType)[keyof typeof SessionType]


export const ClinicalStatus: {
  BAJA: 'BAJA',
  REINTEGRO: 'REINTEGRO',
  LIMITADA: 'LIMITADA',
  ALTA: 'ALTA'
};

export type ClinicalStatus = (typeof ClinicalStatus)[keyof typeof ClinicalStatus]


export const LeaveStage: {
  PARTIDO: 'PARTIDO',
  ENTRENAMIENTO: 'ENTRENAMIENTO',
  EXTRADEPORTIVO: 'EXTRADEPORTIVO'
};

export type LeaveStage = (typeof LeaveStage)[keyof typeof LeaveStage]


export const LeaveKind: {
  LESION: 'LESION',
  ENFERMEDAD: 'ENFERMEDAD'
};

export type LeaveKind = (typeof LeaveKind)[keyof typeof LeaveKind]


export const Laterality: {
  IZQ: 'IZQ',
  DER: 'DER',
  BILATERAL: 'BILATERAL',
  NA: 'NA'
};

export type Laterality = (typeof Laterality)[keyof typeof Laterality]


export const Mechanism: {
  SOBRECARGA: 'SOBRECARGA',
  IMPACTO: 'IMPACTO',
  TORSION: 'TORSION',
  ESTIRAMIENTO: 'ESTIRAMIENTO',
  RECIDIVA: 'RECIDIVA',
  OTRO: 'OTRO'
};

export type Mechanism = (typeof Mechanism)[keyof typeof Mechanism]


export const Severity: {
  LEVE: 'LEVE',
  MODERADA: 'MODERADA',
  SEVERA: 'SEVERA'
};

export type Severity = (typeof Severity)[keyof typeof Severity]


export const SystemAffected: {
  RESPIRATORIO: 'RESPIRATORIO',
  GASTROINTESTINAL: 'GASTROINTESTINAL',
  OTORRINO: 'OTORRINO',
  DERMATOLOGICO: 'DERMATOLOGICO',
  GENERAL: 'GENERAL',
  OTRO: 'OTRO'
};

export type SystemAffected = (typeof SystemAffected)[keyof typeof SystemAffected]


export const IllAptitude: {
  SOLO_GIMNASIO: 'SOLO_GIMNASIO',
  AEROBICO_SUAVE: 'AEROBICO_SUAVE',
  CHARLAS_TACTICO: 'CHARLAS_TACTICO',
  NINGUNO: 'NINGUNO'
};

export type IllAptitude = (typeof IllAptitude)[keyof typeof IllAptitude]


export const PlayerStatus: {
  ACTIVO: 'ACTIVO',
  LESIONADO: 'LESIONADO',
  RECUPERACION: 'RECUPERACION',
  ALTA_PARCIAL: 'ALTA_PARCIAL',
  ALTA_TOTAL: 'ALTA_TOTAL'
};

export type PlayerStatus = (typeof PlayerStatus)[keyof typeof PlayerStatus]


export const ScoutingStatus: {
  ACTIVO: 'ACTIVO',
  WATCHLIST: 'WATCHLIST',
  DESCARTADO: 'DESCARTADO'
};

export type ScoutingStatus = (typeof ScoutingStatus)[keyof typeof ScoutingStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type TeamRole = $Enums.TeamRole

export const TeamRole: typeof $Enums.TeamRole

export type SessionType = $Enums.SessionType

export const SessionType: typeof $Enums.SessionType

export type ClinicalStatus = $Enums.ClinicalStatus

export const ClinicalStatus: typeof $Enums.ClinicalStatus

export type LeaveStage = $Enums.LeaveStage

export const LeaveStage: typeof $Enums.LeaveStage

export type LeaveKind = $Enums.LeaveKind

export const LeaveKind: typeof $Enums.LeaveKind

export type Laterality = $Enums.Laterality

export const Laterality: typeof $Enums.Laterality

export type Mechanism = $Enums.Mechanism

export const Mechanism: typeof $Enums.Mechanism

export type Severity = $Enums.Severity

export const Severity: typeof $Enums.Severity

export type SystemAffected = $Enums.SystemAffected

export const SystemAffected: typeof $Enums.SystemAffected

export type IllAptitude = $Enums.IllAptitude

export const IllAptitude: typeof $Enums.IllAptitude

export type PlayerStatus = $Enums.PlayerStatus

export const PlayerStatus: typeof $Enums.PlayerStatus

export type ScoutingStatus = $Enums.ScoutingStatus

export const ScoutingStatus: typeof $Enums.ScoutingStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Teams
 * const teams = await prisma.team.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Teams
   * const teams = await prisma.team.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs>;

  /**
   * `prisma.globalConfig`: Exposes CRUD operations for the **GlobalConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GlobalConfigs
    * const globalConfigs = await prisma.globalConfig.findMany()
    * ```
    */
  get globalConfig(): Prisma.GlobalConfigDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userTeam`: Exposes CRUD operations for the **UserTeam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTeams
    * const userTeams = await prisma.userTeam.findMany()
    * ```
    */
  get userTeam(): Prisma.UserTeamDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.rival`: Exposes CRUD operations for the **Rival** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rivals
    * const rivals = await prisma.rival.findMany()
    * ```
    */
  get rival(): Prisma.RivalDelegate<ExtArgs>;

  /**
   * `prisma.playerFeedback`: Exposes CRUD operations for the **PlayerFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerFeedbacks
    * const playerFeedbacks = await prisma.playerFeedback.findMany()
    * ```
    */
  get playerFeedback(): Prisma.PlayerFeedbackDelegate<ExtArgs>;

  /**
   * `prisma.place`: Exposes CRUD operations for the **Place** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Places
    * const places = await prisma.place.findMany()
    * ```
    */
  get place(): Prisma.PlaceDelegate<ExtArgs>;

  /**
   * `prisma.exerciseKind`: Exposes CRUD operations for the **ExerciseKind** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExerciseKinds
    * const exerciseKinds = await prisma.exerciseKind.findMany()
    * ```
    */
  get exerciseKind(): Prisma.ExerciseKindDelegate<ExtArgs>;

  /**
   * `prisma.exercise`: Exposes CRUD operations for the **Exercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exercises
    * const exercises = await prisma.exercise.findMany()
    * ```
    */
  get exercise(): Prisma.ExerciseDelegate<ExtArgs>;

  /**
   * `prisma.rPEEntry`: Exposes CRUD operations for the **RPEEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RPEEntries
    * const rPEEntries = await prisma.rPEEntry.findMany()
    * ```
    */
  get rPEEntry(): Prisma.RPEEntryDelegate<ExtArgs>;

  /**
   * `prisma.wellnessEntry`: Exposes CRUD operations for the **WellnessEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WellnessEntries
    * const wellnessEntries = await prisma.wellnessEntry.findMany()
    * ```
    */
  get wellnessEntry(): Prisma.WellnessEntryDelegate<ExtArgs>;

  /**
   * `prisma.plannerPrefs`: Exposes CRUD operations for the **PlannerPrefs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlannerPrefs
    * const plannerPrefs = await prisma.plannerPrefs.findMany()
    * ```
    */
  get plannerPrefs(): Prisma.PlannerPrefsDelegate<ExtArgs>;

  /**
   * `prisma.clinicalEntry`: Exposes CRUD operations for the **ClinicalEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClinicalEntries
    * const clinicalEntries = await prisma.clinicalEntry.findMany()
    * ```
    */
  get clinicalEntry(): Prisma.ClinicalEntryDelegate<ExtArgs>;

  /**
   * `prisma.scoutingCategory`: Exposes CRUD operations for the **ScoutingCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScoutingCategories
    * const scoutingCategories = await prisma.scoutingCategory.findMany()
    * ```
    */
  get scoutingCategory(): Prisma.ScoutingCategoryDelegate<ExtArgs>;

  /**
   * `prisma.player`: Exposes CRUD operations for the **Player** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Players
    * const players = await prisma.player.findMany()
    * ```
    */
  get player(): Prisma.PlayerDelegate<ExtArgs>;

  /**
   * `prisma.scoutingPlayer`: Exposes CRUD operations for the **ScoutingPlayer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScoutingPlayers
    * const scoutingPlayers = await prisma.scoutingPlayer.findMany()
    * ```
    */
  get scoutingPlayer(): Prisma.ScoutingPlayerDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.teamVideo`: Exposes CRUD operations for the **TeamVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamVideos
    * const teamVideos = await prisma.teamVideo.findMany()
    * ```
    */
  get teamVideo(): Prisma.TeamVideoDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.19.1
   * Query Engine version: 69d742ee20b815d88e17e54db4a2a7a3b30324e3
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Team: 'Team',
    GlobalConfig: 'GlobalConfig',
    User: 'User',
    UserTeam: 'UserTeam',
    Session: 'Session',
    Rival: 'Rival',
    PlayerFeedback: 'PlayerFeedback',
    Place: 'Place',
    ExerciseKind: 'ExerciseKind',
    Exercise: 'Exercise',
    RPEEntry: 'RPEEntry',
    WellnessEntry: 'WellnessEntry',
    PlannerPrefs: 'PlannerPrefs',
    ClinicalEntry: 'ClinicalEntry',
    ScoutingCategory: 'ScoutingCategory',
    Player: 'Player',
    ScoutingPlayer: 'ScoutingPlayer',
    Report: 'Report',
    TeamVideo: 'TeamVideo'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "team" | "globalConfig" | "user" | "userTeam" | "session" | "rival" | "playerFeedback" | "place" | "exerciseKind" | "exercise" | "rPEEntry" | "wellnessEntry" | "plannerPrefs" | "clinicalEntry" | "scoutingCategory" | "player" | "scoutingPlayer" | "report" | "teamVideo"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      GlobalConfig: {
        payload: Prisma.$GlobalConfigPayload<ExtArgs>
        fields: Prisma.GlobalConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GlobalConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GlobalConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload>
          }
          findFirst: {
            args: Prisma.GlobalConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GlobalConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload>
          }
          findMany: {
            args: Prisma.GlobalConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload>[]
          }
          create: {
            args: Prisma.GlobalConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload>
          }
          createMany: {
            args: Prisma.GlobalConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GlobalConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload>[]
          }
          delete: {
            args: Prisma.GlobalConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload>
          }
          update: {
            args: Prisma.GlobalConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload>
          }
          deleteMany: {
            args: Prisma.GlobalConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GlobalConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GlobalConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload>
          }
          aggregate: {
            args: Prisma.GlobalConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGlobalConfig>
          }
          groupBy: {
            args: Prisma.GlobalConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<GlobalConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.GlobalConfigCountArgs<ExtArgs>
            result: $Utils.Optional<GlobalConfigCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserTeam: {
        payload: Prisma.$UserTeamPayload<ExtArgs>
        fields: Prisma.UserTeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTeamPayload>
          }
          findFirst: {
            args: Prisma.UserTeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTeamPayload>
          }
          findMany: {
            args: Prisma.UserTeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTeamPayload>[]
          }
          create: {
            args: Prisma.UserTeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTeamPayload>
          }
          createMany: {
            args: Prisma.UserTeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTeamPayload>[]
          }
          delete: {
            args: Prisma.UserTeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTeamPayload>
          }
          update: {
            args: Prisma.UserTeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTeamPayload>
          }
          deleteMany: {
            args: Prisma.UserTeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserTeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTeamPayload>
          }
          aggregate: {
            args: Prisma.UserTeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTeam>
          }
          groupBy: {
            args: Prisma.UserTeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTeamCountArgs<ExtArgs>
            result: $Utils.Optional<UserTeamCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Rival: {
        payload: Prisma.$RivalPayload<ExtArgs>
        fields: Prisma.RivalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RivalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RivalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RivalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RivalPayload>
          }
          findFirst: {
            args: Prisma.RivalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RivalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RivalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RivalPayload>
          }
          findMany: {
            args: Prisma.RivalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RivalPayload>[]
          }
          create: {
            args: Prisma.RivalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RivalPayload>
          }
          createMany: {
            args: Prisma.RivalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RivalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RivalPayload>[]
          }
          delete: {
            args: Prisma.RivalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RivalPayload>
          }
          update: {
            args: Prisma.RivalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RivalPayload>
          }
          deleteMany: {
            args: Prisma.RivalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RivalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RivalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RivalPayload>
          }
          aggregate: {
            args: Prisma.RivalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRival>
          }
          groupBy: {
            args: Prisma.RivalGroupByArgs<ExtArgs>
            result: $Utils.Optional<RivalGroupByOutputType>[]
          }
          count: {
            args: Prisma.RivalCountArgs<ExtArgs>
            result: $Utils.Optional<RivalCountAggregateOutputType> | number
          }
        }
      }
      PlayerFeedback: {
        payload: Prisma.$PlayerFeedbackPayload<ExtArgs>
        fields: Prisma.PlayerFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFeedbackPayload>
          }
          findFirst: {
            args: Prisma.PlayerFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFeedbackPayload>
          }
          findMany: {
            args: Prisma.PlayerFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFeedbackPayload>[]
          }
          create: {
            args: Prisma.PlayerFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFeedbackPayload>
          }
          createMany: {
            args: Prisma.PlayerFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFeedbackPayload>[]
          }
          delete: {
            args: Prisma.PlayerFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFeedbackPayload>
          }
          update: {
            args: Prisma.PlayerFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.PlayerFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerFeedbackPayload>
          }
          aggregate: {
            args: Prisma.PlayerFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerFeedback>
          }
          groupBy: {
            args: Prisma.PlayerFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerFeedbackCountAggregateOutputType> | number
          }
        }
      }
      Place: {
        payload: Prisma.$PlacePayload<ExtArgs>
        fields: Prisma.PlaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          findFirst: {
            args: Prisma.PlaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          findMany: {
            args: Prisma.PlaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>[]
          }
          create: {
            args: Prisma.PlaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          createMany: {
            args: Prisma.PlaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>[]
          }
          delete: {
            args: Prisma.PlaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          update: {
            args: Prisma.PlaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          deleteMany: {
            args: Prisma.PlaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          aggregate: {
            args: Prisma.PlaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlace>
          }
          groupBy: {
            args: Prisma.PlaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaceCountArgs<ExtArgs>
            result: $Utils.Optional<PlaceCountAggregateOutputType> | number
          }
        }
      }
      ExerciseKind: {
        payload: Prisma.$ExerciseKindPayload<ExtArgs>
        fields: Prisma.ExerciseKindFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseKindFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseKindPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseKindFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseKindPayload>
          }
          findFirst: {
            args: Prisma.ExerciseKindFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseKindPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseKindFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseKindPayload>
          }
          findMany: {
            args: Prisma.ExerciseKindFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseKindPayload>[]
          }
          create: {
            args: Prisma.ExerciseKindCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseKindPayload>
          }
          createMany: {
            args: Prisma.ExerciseKindCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseKindCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseKindPayload>[]
          }
          delete: {
            args: Prisma.ExerciseKindDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseKindPayload>
          }
          update: {
            args: Prisma.ExerciseKindUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseKindPayload>
          }
          deleteMany: {
            args: Prisma.ExerciseKindDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseKindUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExerciseKindUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseKindPayload>
          }
          aggregate: {
            args: Prisma.ExerciseKindAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExerciseKind>
          }
          groupBy: {
            args: Prisma.ExerciseKindGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseKindGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseKindCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseKindCountAggregateOutputType> | number
          }
        }
      }
      Exercise: {
        payload: Prisma.$ExercisePayload<ExtArgs>
        fields: Prisma.ExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findFirst: {
            args: Prisma.ExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findMany: {
            args: Prisma.ExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          create: {
            args: Prisma.ExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          createMany: {
            args: Prisma.ExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          delete: {
            args: Prisma.ExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          update: {
            args: Prisma.ExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          deleteMany: {
            args: Prisma.ExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          aggregate: {
            args: Prisma.ExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExercise>
          }
          groupBy: {
            args: Prisma.ExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseCountAggregateOutputType> | number
          }
        }
      }
      RPEEntry: {
        payload: Prisma.$RPEEntryPayload<ExtArgs>
        fields: Prisma.RPEEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RPEEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPEEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RPEEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPEEntryPayload>
          }
          findFirst: {
            args: Prisma.RPEEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPEEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RPEEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPEEntryPayload>
          }
          findMany: {
            args: Prisma.RPEEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPEEntryPayload>[]
          }
          create: {
            args: Prisma.RPEEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPEEntryPayload>
          }
          createMany: {
            args: Prisma.RPEEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RPEEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPEEntryPayload>[]
          }
          delete: {
            args: Prisma.RPEEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPEEntryPayload>
          }
          update: {
            args: Prisma.RPEEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPEEntryPayload>
          }
          deleteMany: {
            args: Prisma.RPEEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RPEEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RPEEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPEEntryPayload>
          }
          aggregate: {
            args: Prisma.RPEEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRPEEntry>
          }
          groupBy: {
            args: Prisma.RPEEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<RPEEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.RPEEntryCountArgs<ExtArgs>
            result: $Utils.Optional<RPEEntryCountAggregateOutputType> | number
          }
        }
      }
      WellnessEntry: {
        payload: Prisma.$WellnessEntryPayload<ExtArgs>
        fields: Prisma.WellnessEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WellnessEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WellnessEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessEntryPayload>
          }
          findFirst: {
            args: Prisma.WellnessEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WellnessEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessEntryPayload>
          }
          findMany: {
            args: Prisma.WellnessEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessEntryPayload>[]
          }
          create: {
            args: Prisma.WellnessEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessEntryPayload>
          }
          createMany: {
            args: Prisma.WellnessEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WellnessEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessEntryPayload>[]
          }
          delete: {
            args: Prisma.WellnessEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessEntryPayload>
          }
          update: {
            args: Prisma.WellnessEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessEntryPayload>
          }
          deleteMany: {
            args: Prisma.WellnessEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WellnessEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WellnessEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WellnessEntryPayload>
          }
          aggregate: {
            args: Prisma.WellnessEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWellnessEntry>
          }
          groupBy: {
            args: Prisma.WellnessEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<WellnessEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.WellnessEntryCountArgs<ExtArgs>
            result: $Utils.Optional<WellnessEntryCountAggregateOutputType> | number
          }
        }
      }
      PlannerPrefs: {
        payload: Prisma.$PlannerPrefsPayload<ExtArgs>
        fields: Prisma.PlannerPrefsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlannerPrefsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerPrefsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlannerPrefsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerPrefsPayload>
          }
          findFirst: {
            args: Prisma.PlannerPrefsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerPrefsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlannerPrefsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerPrefsPayload>
          }
          findMany: {
            args: Prisma.PlannerPrefsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerPrefsPayload>[]
          }
          create: {
            args: Prisma.PlannerPrefsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerPrefsPayload>
          }
          createMany: {
            args: Prisma.PlannerPrefsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlannerPrefsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerPrefsPayload>[]
          }
          delete: {
            args: Prisma.PlannerPrefsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerPrefsPayload>
          }
          update: {
            args: Prisma.PlannerPrefsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerPrefsPayload>
          }
          deleteMany: {
            args: Prisma.PlannerPrefsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlannerPrefsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlannerPrefsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerPrefsPayload>
          }
          aggregate: {
            args: Prisma.PlannerPrefsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlannerPrefs>
          }
          groupBy: {
            args: Prisma.PlannerPrefsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlannerPrefsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlannerPrefsCountArgs<ExtArgs>
            result: $Utils.Optional<PlannerPrefsCountAggregateOutputType> | number
          }
        }
      }
      ClinicalEntry: {
        payload: Prisma.$ClinicalEntryPayload<ExtArgs>
        fields: Prisma.ClinicalEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicalEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicalEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalEntryPayload>
          }
          findFirst: {
            args: Prisma.ClinicalEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicalEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalEntryPayload>
          }
          findMany: {
            args: Prisma.ClinicalEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalEntryPayload>[]
          }
          create: {
            args: Prisma.ClinicalEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalEntryPayload>
          }
          createMany: {
            args: Prisma.ClinicalEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicalEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalEntryPayload>[]
          }
          delete: {
            args: Prisma.ClinicalEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalEntryPayload>
          }
          update: {
            args: Prisma.ClinicalEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalEntryPayload>
          }
          deleteMany: {
            args: Prisma.ClinicalEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicalEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClinicalEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalEntryPayload>
          }
          aggregate: {
            args: Prisma.ClinicalEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinicalEntry>
          }
          groupBy: {
            args: Prisma.ClinicalEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicalEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicalEntryCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicalEntryCountAggregateOutputType> | number
          }
        }
      }
      ScoutingCategory: {
        payload: Prisma.$ScoutingCategoryPayload<ExtArgs>
        fields: Prisma.ScoutingCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScoutingCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScoutingCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingCategoryPayload>
          }
          findFirst: {
            args: Prisma.ScoutingCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScoutingCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingCategoryPayload>
          }
          findMany: {
            args: Prisma.ScoutingCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingCategoryPayload>[]
          }
          create: {
            args: Prisma.ScoutingCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingCategoryPayload>
          }
          createMany: {
            args: Prisma.ScoutingCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScoutingCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingCategoryPayload>[]
          }
          delete: {
            args: Prisma.ScoutingCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingCategoryPayload>
          }
          update: {
            args: Prisma.ScoutingCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ScoutingCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScoutingCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScoutingCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingCategoryPayload>
          }
          aggregate: {
            args: Prisma.ScoutingCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScoutingCategory>
          }
          groupBy: {
            args: Prisma.ScoutingCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScoutingCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScoutingCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ScoutingCategoryCountAggregateOutputType> | number
          }
        }
      }
      Player: {
        payload: Prisma.$PlayerPayload<ExtArgs>
        fields: Prisma.PlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findFirst: {
            args: Prisma.PlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findMany: {
            args: Prisma.PlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          create: {
            args: Prisma.PlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          createMany: {
            args: Prisma.PlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          delete: {
            args: Prisma.PlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          update: {
            args: Prisma.PlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          deleteMany: {
            args: Prisma.PlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          aggregate: {
            args: Prisma.PlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayer>
          }
          groupBy: {
            args: Prisma.PlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerCountAggregateOutputType> | number
          }
        }
      }
      ScoutingPlayer: {
        payload: Prisma.$ScoutingPlayerPayload<ExtArgs>
        fields: Prisma.ScoutingPlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScoutingPlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingPlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScoutingPlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingPlayerPayload>
          }
          findFirst: {
            args: Prisma.ScoutingPlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingPlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScoutingPlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingPlayerPayload>
          }
          findMany: {
            args: Prisma.ScoutingPlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingPlayerPayload>[]
          }
          create: {
            args: Prisma.ScoutingPlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingPlayerPayload>
          }
          createMany: {
            args: Prisma.ScoutingPlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScoutingPlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingPlayerPayload>[]
          }
          delete: {
            args: Prisma.ScoutingPlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingPlayerPayload>
          }
          update: {
            args: Prisma.ScoutingPlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingPlayerPayload>
          }
          deleteMany: {
            args: Prisma.ScoutingPlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScoutingPlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScoutingPlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScoutingPlayerPayload>
          }
          aggregate: {
            args: Prisma.ScoutingPlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScoutingPlayer>
          }
          groupBy: {
            args: Prisma.ScoutingPlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScoutingPlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScoutingPlayerCountArgs<ExtArgs>
            result: $Utils.Optional<ScoutingPlayerCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      TeamVideo: {
        payload: Prisma.$TeamVideoPayload<ExtArgs>
        fields: Prisma.TeamVideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamVideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamVideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamVideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamVideoPayload>
          }
          findFirst: {
            args: Prisma.TeamVideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamVideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamVideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamVideoPayload>
          }
          findMany: {
            args: Prisma.TeamVideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamVideoPayload>[]
          }
          create: {
            args: Prisma.TeamVideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamVideoPayload>
          }
          createMany: {
            args: Prisma.TeamVideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamVideoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamVideoPayload>[]
          }
          delete: {
            args: Prisma.TeamVideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamVideoPayload>
          }
          update: {
            args: Prisma.TeamVideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamVideoPayload>
          }
          deleteMany: {
            args: Prisma.TeamVideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamVideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamVideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamVideoPayload>
          }
          aggregate: {
            args: Prisma.TeamVideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamVideo>
          }
          groupBy: {
            args: Prisma.TeamVideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamVideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamVideoCountArgs<ExtArgs>
            result: $Utils.Optional<TeamVideoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    members: number
    rivals: number
    feedback: number
    sessions: number
    places: number
    plannerPrefs: number
    scoutingCategories: number
    scoutingPlayers: number
    videos: number
    reports: number
    players: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | TeamCountOutputTypeCountMembersArgs
    rivals?: boolean | TeamCountOutputTypeCountRivalsArgs
    feedback?: boolean | TeamCountOutputTypeCountFeedbackArgs
    sessions?: boolean | TeamCountOutputTypeCountSessionsArgs
    places?: boolean | TeamCountOutputTypeCountPlacesArgs
    plannerPrefs?: boolean | TeamCountOutputTypeCountPlannerPrefsArgs
    scoutingCategories?: boolean | TeamCountOutputTypeCountScoutingCategoriesArgs
    scoutingPlayers?: boolean | TeamCountOutputTypeCountScoutingPlayersArgs
    videos?: boolean | TeamCountOutputTypeCountVideosArgs
    reports?: boolean | TeamCountOutputTypeCountReportsArgs
    players?: boolean | TeamCountOutputTypeCountPlayersArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTeamWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountRivalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RivalWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerFeedbackWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountPlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountPlannerPrefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlannerPrefsWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountScoutingCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScoutingCategoryWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountScoutingPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScoutingPlayerWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamVideoWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    rpeEntries: number
    wellnessEntries: number
    plannerPrefs: number
    exercises: number
    clinicalEntries: number
    teams: number
    reports: number
    players: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    rpeEntries?: boolean | UserCountOutputTypeCountRpeEntriesArgs
    wellnessEntries?: boolean | UserCountOutputTypeCountWellnessEntriesArgs
    plannerPrefs?: boolean | UserCountOutputTypeCountPlannerPrefsArgs
    exercises?: boolean | UserCountOutputTypeCountExercisesArgs
    clinicalEntries?: boolean | UserCountOutputTypeCountClinicalEntriesArgs
    teams?: boolean | UserCountOutputTypeCountTeamsArgs
    reports?: boolean | UserCountOutputTypeCountReportsArgs
    players?: boolean | UserCountOutputTypeCountPlayersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRpeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RPEEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWellnessEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellnessEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlannerPrefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlannerPrefsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClinicalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTeamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
  }


  /**
   * Count Type ExerciseKindCountOutputType
   */

  export type ExerciseKindCountOutputType = {
    exercises: number
  }

  export type ExerciseKindCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercises?: boolean | ExerciseKindCountOutputTypeCountExercisesArgs
  }

  // Custom InputTypes
  /**
   * ExerciseKindCountOutputType without action
   */
  export type ExerciseKindCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseKindCountOutputType
     */
    select?: ExerciseKindCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExerciseKindCountOutputType without action
   */
  export type ExerciseKindCountOutputTypeCountExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
  }


  /**
   * Count Type ScoutingCategoryCountOutputType
   */

  export type ScoutingCategoryCountOutputType = {
    players: number
  }

  export type ScoutingCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | ScoutingCategoryCountOutputTypeCountPlayersArgs
  }

  // Custom InputTypes
  /**
   * ScoutingCategoryCountOutputType without action
   */
  export type ScoutingCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingCategoryCountOutputType
     */
    select?: ScoutingCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScoutingCategoryCountOutputType without action
   */
  export type ScoutingCategoryCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScoutingPlayerWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    isActive: boolean | null
    logoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    isActive: boolean | null
    logoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    isActive: number
    logoUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    isActive?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    isActive?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    isActive?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    slug: string
    isActive: boolean
    logoUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    isActive?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Team$membersArgs<ExtArgs>
    rivals?: boolean | Team$rivalsArgs<ExtArgs>
    feedback?: boolean | Team$feedbackArgs<ExtArgs>
    sessions?: boolean | Team$sessionsArgs<ExtArgs>
    places?: boolean | Team$placesArgs<ExtArgs>
    plannerPrefs?: boolean | Team$plannerPrefsArgs<ExtArgs>
    scoutingCategories?: boolean | Team$scoutingCategoriesArgs<ExtArgs>
    scoutingPlayers?: boolean | Team$scoutingPlayersArgs<ExtArgs>
    videos?: boolean | Team$videosArgs<ExtArgs>
    reports?: boolean | Team$reportsArgs<ExtArgs>
    players?: boolean | Team$playersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    isActive?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    isActive?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Team$membersArgs<ExtArgs>
    rivals?: boolean | Team$rivalsArgs<ExtArgs>
    feedback?: boolean | Team$feedbackArgs<ExtArgs>
    sessions?: boolean | Team$sessionsArgs<ExtArgs>
    places?: boolean | Team$placesArgs<ExtArgs>
    plannerPrefs?: boolean | Team$plannerPrefsArgs<ExtArgs>
    scoutingCategories?: boolean | Team$scoutingCategoriesArgs<ExtArgs>
    scoutingPlayers?: boolean | Team$scoutingPlayersArgs<ExtArgs>
    videos?: boolean | Team$videosArgs<ExtArgs>
    reports?: boolean | Team$reportsArgs<ExtArgs>
    players?: boolean | Team$playersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      members: Prisma.$UserTeamPayload<ExtArgs>[]
      rivals: Prisma.$RivalPayload<ExtArgs>[]
      feedback: Prisma.$PlayerFeedbackPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      places: Prisma.$PlacePayload<ExtArgs>[]
      plannerPrefs: Prisma.$PlannerPrefsPayload<ExtArgs>[]
      scoutingCategories: Prisma.$ScoutingCategoryPayload<ExtArgs>[]
      scoutingPlayers: Prisma.$ScoutingPlayerPayload<ExtArgs>[]
      videos: Prisma.$TeamVideoPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      players: Prisma.$PlayerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      isActive: boolean
      logoUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTeamPayload<ExtArgs>, T, "findMany"> | Null>
    rivals<T extends Team$rivalsArgs<ExtArgs> = {}>(args?: Subset<T, Team$rivalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RivalPayload<ExtArgs>, T, "findMany"> | Null>
    feedback<T extends Team$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, Team$feedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerFeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends Team$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Team$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    places<T extends Team$placesArgs<ExtArgs> = {}>(args?: Subset<T, Team$placesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findMany"> | Null>
    plannerPrefs<T extends Team$plannerPrefsArgs<ExtArgs> = {}>(args?: Subset<T, Team$plannerPrefsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlannerPrefsPayload<ExtArgs>, T, "findMany"> | Null>
    scoutingCategories<T extends Team$scoutingCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Team$scoutingCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScoutingCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    scoutingPlayers<T extends Team$scoutingPlayersArgs<ExtArgs> = {}>(args?: Subset<T, Team$scoutingPlayersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScoutingPlayerPayload<ExtArgs>, T, "findMany"> | Null>
    videos<T extends Team$videosArgs<ExtArgs> = {}>(args?: Subset<T, Team$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamVideoPayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends Team$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Team$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    players<T extends Team$playersArgs<ExtArgs> = {}>(args?: Subset<T, Team$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */ 
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly slug: FieldRef<"Team", 'String'>
    readonly isActive: FieldRef<"Team", 'Boolean'>
    readonly logoUrl: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTeam
     */
    select?: UserTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTeamInclude<ExtArgs> | null
    where?: UserTeamWhereInput
    orderBy?: UserTeamOrderByWithRelationInput | UserTeamOrderByWithRelationInput[]
    cursor?: UserTeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTeamScalarFieldEnum | UserTeamScalarFieldEnum[]
  }

  /**
   * Team.rivals
   */
  export type Team$rivalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rival
     */
    select?: RivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RivalInclude<ExtArgs> | null
    where?: RivalWhereInput
    orderBy?: RivalOrderByWithRelationInput | RivalOrderByWithRelationInput[]
    cursor?: RivalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RivalScalarFieldEnum | RivalScalarFieldEnum[]
  }

  /**
   * Team.feedback
   */
  export type Team$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFeedback
     */
    select?: PlayerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFeedbackInclude<ExtArgs> | null
    where?: PlayerFeedbackWhereInput
    orderBy?: PlayerFeedbackOrderByWithRelationInput | PlayerFeedbackOrderByWithRelationInput[]
    cursor?: PlayerFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerFeedbackScalarFieldEnum | PlayerFeedbackScalarFieldEnum[]
  }

  /**
   * Team.sessions
   */
  export type Team$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Team.places
   */
  export type Team$placesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    where?: PlaceWhereInput
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    cursor?: PlaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Team.plannerPrefs
   */
  export type Team$plannerPrefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerPrefs
     */
    select?: PlannerPrefsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerPrefsInclude<ExtArgs> | null
    where?: PlannerPrefsWhereInput
    orderBy?: PlannerPrefsOrderByWithRelationInput | PlannerPrefsOrderByWithRelationInput[]
    cursor?: PlannerPrefsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlannerPrefsScalarFieldEnum | PlannerPrefsScalarFieldEnum[]
  }

  /**
   * Team.scoutingCategories
   */
  export type Team$scoutingCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingCategory
     */
    select?: ScoutingCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingCategoryInclude<ExtArgs> | null
    where?: ScoutingCategoryWhereInput
    orderBy?: ScoutingCategoryOrderByWithRelationInput | ScoutingCategoryOrderByWithRelationInput[]
    cursor?: ScoutingCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScoutingCategoryScalarFieldEnum | ScoutingCategoryScalarFieldEnum[]
  }

  /**
   * Team.scoutingPlayers
   */
  export type Team$scoutingPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingPlayer
     */
    select?: ScoutingPlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingPlayerInclude<ExtArgs> | null
    where?: ScoutingPlayerWhereInput
    orderBy?: ScoutingPlayerOrderByWithRelationInput | ScoutingPlayerOrderByWithRelationInput[]
    cursor?: ScoutingPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScoutingPlayerScalarFieldEnum | ScoutingPlayerScalarFieldEnum[]
  }

  /**
   * Team.videos
   */
  export type Team$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamVideo
     */
    select?: TeamVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamVideoInclude<ExtArgs> | null
    where?: TeamVideoWhereInput
    orderBy?: TeamVideoOrderByWithRelationInput | TeamVideoOrderByWithRelationInput[]
    cursor?: TeamVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamVideoScalarFieldEnum | TeamVideoScalarFieldEnum[]
  }

  /**
   * Team.reports
   */
  export type Team$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Team.players
   */
  export type Team$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    cursor?: PlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model GlobalConfig
   */

  export type AggregateGlobalConfig = {
    _count: GlobalConfigCountAggregateOutputType | null
    _min: GlobalConfigMinAggregateOutputType | null
    _max: GlobalConfigMaxAggregateOutputType | null
  }

  export type GlobalConfigMinAggregateOutputType = {
    id: string | null
    systemName: string | null
    logoUrl: string | null
    mainColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GlobalConfigMaxAggregateOutputType = {
    id: string | null
    systemName: string | null
    logoUrl: string | null
    mainColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GlobalConfigCountAggregateOutputType = {
    id: number
    systemName: number
    logoUrl: number
    mainColor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GlobalConfigMinAggregateInputType = {
    id?: true
    systemName?: true
    logoUrl?: true
    mainColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GlobalConfigMaxAggregateInputType = {
    id?: true
    systemName?: true
    logoUrl?: true
    mainColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GlobalConfigCountAggregateInputType = {
    id?: true
    systemName?: true
    logoUrl?: true
    mainColor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GlobalConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalConfig to aggregate.
     */
    where?: GlobalConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalConfigs to fetch.
     */
    orderBy?: GlobalConfigOrderByWithRelationInput | GlobalConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GlobalConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GlobalConfigs
    **/
    _count?: true | GlobalConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GlobalConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GlobalConfigMaxAggregateInputType
  }

  export type GetGlobalConfigAggregateType<T extends GlobalConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateGlobalConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGlobalConfig[P]>
      : GetScalarType<T[P], AggregateGlobalConfig[P]>
  }




  export type GlobalConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GlobalConfigWhereInput
    orderBy?: GlobalConfigOrderByWithAggregationInput | GlobalConfigOrderByWithAggregationInput[]
    by: GlobalConfigScalarFieldEnum[] | GlobalConfigScalarFieldEnum
    having?: GlobalConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GlobalConfigCountAggregateInputType | true
    _min?: GlobalConfigMinAggregateInputType
    _max?: GlobalConfigMaxAggregateInputType
  }

  export type GlobalConfigGroupByOutputType = {
    id: string
    systemName: string
    logoUrl: string | null
    mainColor: string | null
    createdAt: Date
    updatedAt: Date
    _count: GlobalConfigCountAggregateOutputType | null
    _min: GlobalConfigMinAggregateOutputType | null
    _max: GlobalConfigMaxAggregateOutputType | null
  }

  type GetGlobalConfigGroupByPayload<T extends GlobalConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GlobalConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GlobalConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GlobalConfigGroupByOutputType[P]>
            : GetScalarType<T[P], GlobalConfigGroupByOutputType[P]>
        }
      >
    >


  export type GlobalConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    systemName?: boolean
    logoUrl?: boolean
    mainColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["globalConfig"]>

  export type GlobalConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    systemName?: boolean
    logoUrl?: boolean
    mainColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["globalConfig"]>

  export type GlobalConfigSelectScalar = {
    id?: boolean
    systemName?: boolean
    logoUrl?: boolean
    mainColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $GlobalConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GlobalConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      systemName: string
      logoUrl: string | null
      mainColor: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["globalConfig"]>
    composites: {}
  }

  type GlobalConfigGetPayload<S extends boolean | null | undefined | GlobalConfigDefaultArgs> = $Result.GetResult<Prisma.$GlobalConfigPayload, S>

  type GlobalConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GlobalConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GlobalConfigCountAggregateInputType | true
    }

  export interface GlobalConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GlobalConfig'], meta: { name: 'GlobalConfig' } }
    /**
     * Find zero or one GlobalConfig that matches the filter.
     * @param {GlobalConfigFindUniqueArgs} args - Arguments to find a GlobalConfig
     * @example
     * // Get one GlobalConfig
     * const globalConfig = await prisma.globalConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GlobalConfigFindUniqueArgs>(args: SelectSubset<T, GlobalConfigFindUniqueArgs<ExtArgs>>): Prisma__GlobalConfigClient<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GlobalConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GlobalConfigFindUniqueOrThrowArgs} args - Arguments to find a GlobalConfig
     * @example
     * // Get one GlobalConfig
     * const globalConfig = await prisma.globalConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GlobalConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, GlobalConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GlobalConfigClient<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GlobalConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalConfigFindFirstArgs} args - Arguments to find a GlobalConfig
     * @example
     * // Get one GlobalConfig
     * const globalConfig = await prisma.globalConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GlobalConfigFindFirstArgs>(args?: SelectSubset<T, GlobalConfigFindFirstArgs<ExtArgs>>): Prisma__GlobalConfigClient<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GlobalConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalConfigFindFirstOrThrowArgs} args - Arguments to find a GlobalConfig
     * @example
     * // Get one GlobalConfig
     * const globalConfig = await prisma.globalConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GlobalConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, GlobalConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__GlobalConfigClient<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GlobalConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GlobalConfigs
     * const globalConfigs = await prisma.globalConfig.findMany()
     * 
     * // Get first 10 GlobalConfigs
     * const globalConfigs = await prisma.globalConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const globalConfigWithIdOnly = await prisma.globalConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GlobalConfigFindManyArgs>(args?: SelectSubset<T, GlobalConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GlobalConfig.
     * @param {GlobalConfigCreateArgs} args - Arguments to create a GlobalConfig.
     * @example
     * // Create one GlobalConfig
     * const GlobalConfig = await prisma.globalConfig.create({
     *   data: {
     *     // ... data to create a GlobalConfig
     *   }
     * })
     * 
     */
    create<T extends GlobalConfigCreateArgs>(args: SelectSubset<T, GlobalConfigCreateArgs<ExtArgs>>): Prisma__GlobalConfigClient<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GlobalConfigs.
     * @param {GlobalConfigCreateManyArgs} args - Arguments to create many GlobalConfigs.
     * @example
     * // Create many GlobalConfigs
     * const globalConfig = await prisma.globalConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GlobalConfigCreateManyArgs>(args?: SelectSubset<T, GlobalConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GlobalConfigs and returns the data saved in the database.
     * @param {GlobalConfigCreateManyAndReturnArgs} args - Arguments to create many GlobalConfigs.
     * @example
     * // Create many GlobalConfigs
     * const globalConfig = await prisma.globalConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GlobalConfigs and only return the `id`
     * const globalConfigWithIdOnly = await prisma.globalConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GlobalConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, GlobalConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GlobalConfig.
     * @param {GlobalConfigDeleteArgs} args - Arguments to delete one GlobalConfig.
     * @example
     * // Delete one GlobalConfig
     * const GlobalConfig = await prisma.globalConfig.delete({
     *   where: {
     *     // ... filter to delete one GlobalConfig
     *   }
     * })
     * 
     */
    delete<T extends GlobalConfigDeleteArgs>(args: SelectSubset<T, GlobalConfigDeleteArgs<ExtArgs>>): Prisma__GlobalConfigClient<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GlobalConfig.
     * @param {GlobalConfigUpdateArgs} args - Arguments to update one GlobalConfig.
     * @example
     * // Update one GlobalConfig
     * const globalConfig = await prisma.globalConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GlobalConfigUpdateArgs>(args: SelectSubset<T, GlobalConfigUpdateArgs<ExtArgs>>): Prisma__GlobalConfigClient<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GlobalConfigs.
     * @param {GlobalConfigDeleteManyArgs} args - Arguments to filter GlobalConfigs to delete.
     * @example
     * // Delete a few GlobalConfigs
     * const { count } = await prisma.globalConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GlobalConfigDeleteManyArgs>(args?: SelectSubset<T, GlobalConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlobalConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GlobalConfigs
     * const globalConfig = await prisma.globalConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GlobalConfigUpdateManyArgs>(args: SelectSubset<T, GlobalConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GlobalConfig.
     * @param {GlobalConfigUpsertArgs} args - Arguments to update or create a GlobalConfig.
     * @example
     * // Update or create a GlobalConfig
     * const globalConfig = await prisma.globalConfig.upsert({
     *   create: {
     *     // ... data to create a GlobalConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GlobalConfig we want to update
     *   }
     * })
     */
    upsert<T extends GlobalConfigUpsertArgs>(args: SelectSubset<T, GlobalConfigUpsertArgs<ExtArgs>>): Prisma__GlobalConfigClient<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GlobalConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalConfigCountArgs} args - Arguments to filter GlobalConfigs to count.
     * @example
     * // Count the number of GlobalConfigs
     * const count = await prisma.globalConfig.count({
     *   where: {
     *     // ... the filter for the GlobalConfigs we want to count
     *   }
     * })
    **/
    count<T extends GlobalConfigCountArgs>(
      args?: Subset<T, GlobalConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GlobalConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GlobalConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GlobalConfigAggregateArgs>(args: Subset<T, GlobalConfigAggregateArgs>): Prisma.PrismaPromise<GetGlobalConfigAggregateType<T>>

    /**
     * Group by GlobalConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GlobalConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GlobalConfigGroupByArgs['orderBy'] }
        : { orderBy?: GlobalConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GlobalConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGlobalConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GlobalConfig model
   */
  readonly fields: GlobalConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GlobalConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GlobalConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GlobalConfig model
   */ 
  interface GlobalConfigFieldRefs {
    readonly id: FieldRef<"GlobalConfig", 'String'>
    readonly systemName: FieldRef<"GlobalConfig", 'String'>
    readonly logoUrl: FieldRef<"GlobalConfig", 'String'>
    readonly mainColor: FieldRef<"GlobalConfig", 'String'>
    readonly createdAt: FieldRef<"GlobalConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"GlobalConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GlobalConfig findUnique
   */
  export type GlobalConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * Filter, which GlobalConfig to fetch.
     */
    where: GlobalConfigWhereUniqueInput
  }

  /**
   * GlobalConfig findUniqueOrThrow
   */
  export type GlobalConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * Filter, which GlobalConfig to fetch.
     */
    where: GlobalConfigWhereUniqueInput
  }

  /**
   * GlobalConfig findFirst
   */
  export type GlobalConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * Filter, which GlobalConfig to fetch.
     */
    where?: GlobalConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalConfigs to fetch.
     */
    orderBy?: GlobalConfigOrderByWithRelationInput | GlobalConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalConfigs.
     */
    cursor?: GlobalConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalConfigs.
     */
    distinct?: GlobalConfigScalarFieldEnum | GlobalConfigScalarFieldEnum[]
  }

  /**
   * GlobalConfig findFirstOrThrow
   */
  export type GlobalConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * Filter, which GlobalConfig to fetch.
     */
    where?: GlobalConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalConfigs to fetch.
     */
    orderBy?: GlobalConfigOrderByWithRelationInput | GlobalConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalConfigs.
     */
    cursor?: GlobalConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalConfigs.
     */
    distinct?: GlobalConfigScalarFieldEnum | GlobalConfigScalarFieldEnum[]
  }

  /**
   * GlobalConfig findMany
   */
  export type GlobalConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * Filter, which GlobalConfigs to fetch.
     */
    where?: GlobalConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalConfigs to fetch.
     */
    orderBy?: GlobalConfigOrderByWithRelationInput | GlobalConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GlobalConfigs.
     */
    cursor?: GlobalConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalConfigs.
     */
    skip?: number
    distinct?: GlobalConfigScalarFieldEnum | GlobalConfigScalarFieldEnum[]
  }

  /**
   * GlobalConfig create
   */
  export type GlobalConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a GlobalConfig.
     */
    data: XOR<GlobalConfigCreateInput, GlobalConfigUncheckedCreateInput>
  }

  /**
   * GlobalConfig createMany
   */
  export type GlobalConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GlobalConfigs.
     */
    data: GlobalConfigCreateManyInput | GlobalConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlobalConfig createManyAndReturn
   */
  export type GlobalConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GlobalConfigs.
     */
    data: GlobalConfigCreateManyInput | GlobalConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlobalConfig update
   */
  export type GlobalConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a GlobalConfig.
     */
    data: XOR<GlobalConfigUpdateInput, GlobalConfigUncheckedUpdateInput>
    /**
     * Choose, which GlobalConfig to update.
     */
    where: GlobalConfigWhereUniqueInput
  }

  /**
   * GlobalConfig updateMany
   */
  export type GlobalConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GlobalConfigs.
     */
    data: XOR<GlobalConfigUpdateManyMutationInput, GlobalConfigUncheckedUpdateManyInput>
    /**
     * Filter which GlobalConfigs to update
     */
    where?: GlobalConfigWhereInput
  }

  /**
   * GlobalConfig upsert
   */
  export type GlobalConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the GlobalConfig to update in case it exists.
     */
    where: GlobalConfigWhereUniqueInput
    /**
     * In case the GlobalConfig found by the `where` argument doesn't exist, create a new GlobalConfig with this data.
     */
    create: XOR<GlobalConfigCreateInput, GlobalConfigUncheckedCreateInput>
    /**
     * In case the GlobalConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GlobalConfigUpdateInput, GlobalConfigUncheckedUpdateInput>
  }

  /**
   * GlobalConfig delete
   */
  export type GlobalConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * Filter which GlobalConfig to delete.
     */
    where: GlobalConfigWhereUniqueInput
  }

  /**
   * GlobalConfig deleteMany
   */
  export type GlobalConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalConfigs to delete
     */
    where?: GlobalConfigWhereInput
  }

  /**
   * GlobalConfig without action
   */
  export type GlobalConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    role: $Enums.Role | null
    isApproved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    role: $Enums.Role | null
    isApproved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    passwordHash: number
    role: number
    isApproved: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    role?: true
    isApproved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    role?: true
    isApproved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    role?: true
    isApproved?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    passwordHash: string | null
    role: $Enums.Role
    isApproved: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    role?: boolean
    isApproved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    rpeEntries?: boolean | User$rpeEntriesArgs<ExtArgs>
    wellnessEntries?: boolean | User$wellnessEntriesArgs<ExtArgs>
    plannerPrefs?: boolean | User$plannerPrefsArgs<ExtArgs>
    exercises?: boolean | User$exercisesArgs<ExtArgs>
    clinicalEntries?: boolean | User$clinicalEntriesArgs<ExtArgs>
    teams?: boolean | User$teamsArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    players?: boolean | User$playersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    role?: boolean
    isApproved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    role?: boolean
    isApproved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    rpeEntries?: boolean | User$rpeEntriesArgs<ExtArgs>
    wellnessEntries?: boolean | User$wellnessEntriesArgs<ExtArgs>
    plannerPrefs?: boolean | User$plannerPrefsArgs<ExtArgs>
    exercises?: boolean | User$exercisesArgs<ExtArgs>
    clinicalEntries?: boolean | User$clinicalEntriesArgs<ExtArgs>
    teams?: boolean | User$teamsArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    players?: boolean | User$playersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      rpeEntries: Prisma.$RPEEntryPayload<ExtArgs>[]
      wellnessEntries: Prisma.$WellnessEntryPayload<ExtArgs>[]
      plannerPrefs: Prisma.$PlannerPrefsPayload<ExtArgs>[]
      exercises: Prisma.$ExercisePayload<ExtArgs>[]
      clinicalEntries: Prisma.$ClinicalEntryPayload<ExtArgs>[]
      teams: Prisma.$UserTeamPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      players: Prisma.$PlayerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      passwordHash: string | null
      role: $Enums.Role
      isApproved: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    rpeEntries<T extends User$rpeEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$rpeEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RPEEntryPayload<ExtArgs>, T, "findMany"> | Null>
    wellnessEntries<T extends User$wellnessEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$wellnessEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellnessEntryPayload<ExtArgs>, T, "findMany"> | Null>
    plannerPrefs<T extends User$plannerPrefsArgs<ExtArgs> = {}>(args?: Subset<T, User$plannerPrefsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlannerPrefsPayload<ExtArgs>, T, "findMany"> | Null>
    exercises<T extends User$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, User$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany"> | Null>
    clinicalEntries<T extends User$clinicalEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$clinicalEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalEntryPayload<ExtArgs>, T, "findMany"> | Null>
    teams<T extends User$teamsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTeamPayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends User$reportsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    players<T extends User$playersArgs<ExtArgs> = {}>(args?: Subset<T, User$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly isApproved: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.rpeEntries
   */
  export type User$rpeEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPEEntry
     */
    select?: RPEEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPEEntryInclude<ExtArgs> | null
    where?: RPEEntryWhereInput
    orderBy?: RPEEntryOrderByWithRelationInput | RPEEntryOrderByWithRelationInput[]
    cursor?: RPEEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RPEEntryScalarFieldEnum | RPEEntryScalarFieldEnum[]
  }

  /**
   * User.wellnessEntries
   */
  export type User$wellnessEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessEntry
     */
    select?: WellnessEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessEntryInclude<ExtArgs> | null
    where?: WellnessEntryWhereInput
    orderBy?: WellnessEntryOrderByWithRelationInput | WellnessEntryOrderByWithRelationInput[]
    cursor?: WellnessEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WellnessEntryScalarFieldEnum | WellnessEntryScalarFieldEnum[]
  }

  /**
   * User.plannerPrefs
   */
  export type User$plannerPrefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerPrefs
     */
    select?: PlannerPrefsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerPrefsInclude<ExtArgs> | null
    where?: PlannerPrefsWhereInput
    orderBy?: PlannerPrefsOrderByWithRelationInput | PlannerPrefsOrderByWithRelationInput[]
    cursor?: PlannerPrefsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlannerPrefsScalarFieldEnum | PlannerPrefsScalarFieldEnum[]
  }

  /**
   * User.exercises
   */
  export type User$exercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * User.clinicalEntries
   */
  export type User$clinicalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalEntry
     */
    select?: ClinicalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalEntryInclude<ExtArgs> | null
    where?: ClinicalEntryWhereInput
    orderBy?: ClinicalEntryOrderByWithRelationInput | ClinicalEntryOrderByWithRelationInput[]
    cursor?: ClinicalEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicalEntryScalarFieldEnum | ClinicalEntryScalarFieldEnum[]
  }

  /**
   * User.teams
   */
  export type User$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTeam
     */
    select?: UserTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTeamInclude<ExtArgs> | null
    where?: UserTeamWhereInput
    orderBy?: UserTeamOrderByWithRelationInput | UserTeamOrderByWithRelationInput[]
    cursor?: UserTeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTeamScalarFieldEnum | UserTeamScalarFieldEnum[]
  }

  /**
   * User.reports
   */
  export type User$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.players
   */
  export type User$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    cursor?: PlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserTeam
   */

  export type AggregateUserTeam = {
    _count: UserTeamCountAggregateOutputType | null
    _min: UserTeamMinAggregateOutputType | null
    _max: UserTeamMaxAggregateOutputType | null
  }

  export type UserTeamMinAggregateOutputType = {
    id: string | null
    userId: string | null
    teamId: string | null
    role: $Enums.TeamRole | null
    createdAt: Date | null
  }

  export type UserTeamMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    teamId: string | null
    role: $Enums.TeamRole | null
    createdAt: Date | null
  }

  export type UserTeamCountAggregateOutputType = {
    id: number
    userId: number
    teamId: number
    role: number
    createdAt: number
    _all: number
  }


  export type UserTeamMinAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    role?: true
    createdAt?: true
  }

  export type UserTeamMaxAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    role?: true
    createdAt?: true
  }

  export type UserTeamCountAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type UserTeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTeam to aggregate.
     */
    where?: UserTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTeams to fetch.
     */
    orderBy?: UserTeamOrderByWithRelationInput | UserTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTeams
    **/
    _count?: true | UserTeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTeamMaxAggregateInputType
  }

  export type GetUserTeamAggregateType<T extends UserTeamAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTeam[P]>
      : GetScalarType<T[P], AggregateUserTeam[P]>
  }




  export type UserTeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTeamWhereInput
    orderBy?: UserTeamOrderByWithAggregationInput | UserTeamOrderByWithAggregationInput[]
    by: UserTeamScalarFieldEnum[] | UserTeamScalarFieldEnum
    having?: UserTeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTeamCountAggregateInputType | true
    _min?: UserTeamMinAggregateInputType
    _max?: UserTeamMaxAggregateInputType
  }

  export type UserTeamGroupByOutputType = {
    id: string
    userId: string
    teamId: string
    role: $Enums.TeamRole
    createdAt: Date
    _count: UserTeamCountAggregateOutputType | null
    _min: UserTeamMinAggregateOutputType | null
    _max: UserTeamMaxAggregateOutputType | null
  }

  type GetUserTeamGroupByPayload<T extends UserTeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTeamGroupByOutputType[P]>
            : GetScalarType<T[P], UserTeamGroupByOutputType[P]>
        }
      >
    >


  export type UserTeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    teamId?: boolean
    role?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTeam"]>

  export type UserTeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    teamId?: boolean
    role?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTeam"]>

  export type UserTeamSelectScalar = {
    id?: boolean
    userId?: boolean
    teamId?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type UserTeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type UserTeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $UserTeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTeam"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      teamId: string
      role: $Enums.TeamRole
      createdAt: Date
    }, ExtArgs["result"]["userTeam"]>
    composites: {}
  }

  type UserTeamGetPayload<S extends boolean | null | undefined | UserTeamDefaultArgs> = $Result.GetResult<Prisma.$UserTeamPayload, S>

  type UserTeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserTeamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserTeamCountAggregateInputType | true
    }

  export interface UserTeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTeam'], meta: { name: 'UserTeam' } }
    /**
     * Find zero or one UserTeam that matches the filter.
     * @param {UserTeamFindUniqueArgs} args - Arguments to find a UserTeam
     * @example
     * // Get one UserTeam
     * const userTeam = await prisma.userTeam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTeamFindUniqueArgs>(args: SelectSubset<T, UserTeamFindUniqueArgs<ExtArgs>>): Prisma__UserTeamClient<$Result.GetResult<Prisma.$UserTeamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserTeam that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserTeamFindUniqueOrThrowArgs} args - Arguments to find a UserTeam
     * @example
     * // Get one UserTeam
     * const userTeam = await prisma.userTeam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTeamFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTeamClient<$Result.GetResult<Prisma.$UserTeamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserTeam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTeamFindFirstArgs} args - Arguments to find a UserTeam
     * @example
     * // Get one UserTeam
     * const userTeam = await prisma.userTeam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTeamFindFirstArgs>(args?: SelectSubset<T, UserTeamFindFirstArgs<ExtArgs>>): Prisma__UserTeamClient<$Result.GetResult<Prisma.$UserTeamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserTeam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTeamFindFirstOrThrowArgs} args - Arguments to find a UserTeam
     * @example
     * // Get one UserTeam
     * const userTeam = await prisma.userTeam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTeamFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTeamClient<$Result.GetResult<Prisma.$UserTeamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserTeams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTeams
     * const userTeams = await prisma.userTeam.findMany()
     * 
     * // Get first 10 UserTeams
     * const userTeams = await prisma.userTeam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTeamWithIdOnly = await prisma.userTeam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTeamFindManyArgs>(args?: SelectSubset<T, UserTeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTeamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserTeam.
     * @param {UserTeamCreateArgs} args - Arguments to create a UserTeam.
     * @example
     * // Create one UserTeam
     * const UserTeam = await prisma.userTeam.create({
     *   data: {
     *     // ... data to create a UserTeam
     *   }
     * })
     * 
     */
    create<T extends UserTeamCreateArgs>(args: SelectSubset<T, UserTeamCreateArgs<ExtArgs>>): Prisma__UserTeamClient<$Result.GetResult<Prisma.$UserTeamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserTeams.
     * @param {UserTeamCreateManyArgs} args - Arguments to create many UserTeams.
     * @example
     * // Create many UserTeams
     * const userTeam = await prisma.userTeam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTeamCreateManyArgs>(args?: SelectSubset<T, UserTeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTeams and returns the data saved in the database.
     * @param {UserTeamCreateManyAndReturnArgs} args - Arguments to create many UserTeams.
     * @example
     * // Create many UserTeams
     * const userTeam = await prisma.userTeam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTeams and only return the `id`
     * const userTeamWithIdOnly = await prisma.userTeam.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTeamCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTeamPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserTeam.
     * @param {UserTeamDeleteArgs} args - Arguments to delete one UserTeam.
     * @example
     * // Delete one UserTeam
     * const UserTeam = await prisma.userTeam.delete({
     *   where: {
     *     // ... filter to delete one UserTeam
     *   }
     * })
     * 
     */
    delete<T extends UserTeamDeleteArgs>(args: SelectSubset<T, UserTeamDeleteArgs<ExtArgs>>): Prisma__UserTeamClient<$Result.GetResult<Prisma.$UserTeamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserTeam.
     * @param {UserTeamUpdateArgs} args - Arguments to update one UserTeam.
     * @example
     * // Update one UserTeam
     * const userTeam = await prisma.userTeam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTeamUpdateArgs>(args: SelectSubset<T, UserTeamUpdateArgs<ExtArgs>>): Prisma__UserTeamClient<$Result.GetResult<Prisma.$UserTeamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserTeams.
     * @param {UserTeamDeleteManyArgs} args - Arguments to filter UserTeams to delete.
     * @example
     * // Delete a few UserTeams
     * const { count } = await prisma.userTeam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTeamDeleteManyArgs>(args?: SelectSubset<T, UserTeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTeams
     * const userTeam = await prisma.userTeam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTeamUpdateManyArgs>(args: SelectSubset<T, UserTeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTeam.
     * @param {UserTeamUpsertArgs} args - Arguments to update or create a UserTeam.
     * @example
     * // Update or create a UserTeam
     * const userTeam = await prisma.userTeam.upsert({
     *   create: {
     *     // ... data to create a UserTeam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTeam we want to update
     *   }
     * })
     */
    upsert<T extends UserTeamUpsertArgs>(args: SelectSubset<T, UserTeamUpsertArgs<ExtArgs>>): Prisma__UserTeamClient<$Result.GetResult<Prisma.$UserTeamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTeamCountArgs} args - Arguments to filter UserTeams to count.
     * @example
     * // Count the number of UserTeams
     * const count = await prisma.userTeam.count({
     *   where: {
     *     // ... the filter for the UserTeams we want to count
     *   }
     * })
    **/
    count<T extends UserTeamCountArgs>(
      args?: Subset<T, UserTeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTeamAggregateArgs>(args: Subset<T, UserTeamAggregateArgs>): Prisma.PrismaPromise<GetUserTeamAggregateType<T>>

    /**
     * Group by UserTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTeamGroupByArgs['orderBy'] }
        : { orderBy?: UserTeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTeam model
   */
  readonly fields: UserTeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTeam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTeam model
   */ 
  interface UserTeamFieldRefs {
    readonly id: FieldRef<"UserTeam", 'String'>
    readonly userId: FieldRef<"UserTeam", 'String'>
    readonly teamId: FieldRef<"UserTeam", 'String'>
    readonly role: FieldRef<"UserTeam", 'TeamRole'>
    readonly createdAt: FieldRef<"UserTeam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserTeam findUnique
   */
  export type UserTeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTeam
     */
    select?: UserTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTeamInclude<ExtArgs> | null
    /**
     * Filter, which UserTeam to fetch.
     */
    where: UserTeamWhereUniqueInput
  }

  /**
   * UserTeam findUniqueOrThrow
   */
  export type UserTeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTeam
     */
    select?: UserTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTeamInclude<ExtArgs> | null
    /**
     * Filter, which UserTeam to fetch.
     */
    where: UserTeamWhereUniqueInput
  }

  /**
   * UserTeam findFirst
   */
  export type UserTeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTeam
     */
    select?: UserTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTeamInclude<ExtArgs> | null
    /**
     * Filter, which UserTeam to fetch.
     */
    where?: UserTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTeams to fetch.
     */
    orderBy?: UserTeamOrderByWithRelationInput | UserTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTeams.
     */
    cursor?: UserTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTeams.
     */
    distinct?: UserTeamScalarFieldEnum | UserTeamScalarFieldEnum[]
  }

  /**
   * UserTeam findFirstOrThrow
   */
  export type UserTeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTeam
     */
    select?: UserTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTeamInclude<ExtArgs> | null
    /**
     * Filter, which UserTeam to fetch.
     */
    where?: UserTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTeams to fetch.
     */
    orderBy?: UserTeamOrderByWithRelationInput | UserTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTeams.
     */
    cursor?: UserTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTeams.
     */
    distinct?: UserTeamScalarFieldEnum | UserTeamScalarFieldEnum[]
  }

  /**
   * UserTeam findMany
   */
  export type UserTeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTeam
     */
    select?: UserTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTeamInclude<ExtArgs> | null
    /**
     * Filter, which UserTeams to fetch.
     */
    where?: UserTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTeams to fetch.
     */
    orderBy?: UserTeamOrderByWithRelationInput | UserTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTeams.
     */
    cursor?: UserTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTeams.
     */
    skip?: number
    distinct?: UserTeamScalarFieldEnum | UserTeamScalarFieldEnum[]
  }

  /**
   * UserTeam create
   */
  export type UserTeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTeam
     */
    select?: UserTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTeamInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTeam.
     */
    data: XOR<UserTeamCreateInput, UserTeamUncheckedCreateInput>
  }

  /**
   * UserTeam createMany
   */
  export type UserTeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTeams.
     */
    data: UserTeamCreateManyInput | UserTeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTeam createManyAndReturn
   */
  export type UserTeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTeam
     */
    select?: UserTeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserTeams.
     */
    data: UserTeamCreateManyInput | UserTeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTeam update
   */
  export type UserTeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTeam
     */
    select?: UserTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTeamInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTeam.
     */
    data: XOR<UserTeamUpdateInput, UserTeamUncheckedUpdateInput>
    /**
     * Choose, which UserTeam to update.
     */
    where: UserTeamWhereUniqueInput
  }

  /**
   * UserTeam updateMany
   */
  export type UserTeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTeams.
     */
    data: XOR<UserTeamUpdateManyMutationInput, UserTeamUncheckedUpdateManyInput>
    /**
     * Filter which UserTeams to update
     */
    where?: UserTeamWhereInput
  }

  /**
   * UserTeam upsert
   */
  export type UserTeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTeam
     */
    select?: UserTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTeamInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTeam to update in case it exists.
     */
    where: UserTeamWhereUniqueInput
    /**
     * In case the UserTeam found by the `where` argument doesn't exist, create a new UserTeam with this data.
     */
    create: XOR<UserTeamCreateInput, UserTeamUncheckedCreateInput>
    /**
     * In case the UserTeam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTeamUpdateInput, UserTeamUncheckedUpdateInput>
  }

  /**
   * UserTeam delete
   */
  export type UserTeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTeam
     */
    select?: UserTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTeamInclude<ExtArgs> | null
    /**
     * Filter which UserTeam to delete.
     */
    where: UserTeamWhereUniqueInput
  }

  /**
   * UserTeam deleteMany
   */
  export type UserTeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTeams to delete
     */
    where?: UserTeamWhereInput
  }

  /**
   * UserTeam without action
   */
  export type UserTeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTeam
     */
    select?: UserTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTeamInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    date: Date | null
    type: $Enums.SessionType | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    teamId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    date: Date | null
    type: $Enums.SessionType | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    teamId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    title: number
    description: number
    date: number
    type: number
    createdAt: number
    updatedAt: number
    createdBy: number
    teamId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    teamId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    teamId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    teamId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    title: string
    description: string | null
    date: Date
    type: $Enums.SessionType
    createdAt: Date
    updatedAt: Date
    createdBy: string
    teamId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    teamId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    teamId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    teamId?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      date: Date
      type: $Enums.SessionType
      createdAt: Date
      updatedAt: Date
      createdBy: string
      teamId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly title: FieldRef<"Session", 'String'>
    readonly description: FieldRef<"Session", 'String'>
    readonly date: FieldRef<"Session", 'DateTime'>
    readonly type: FieldRef<"Session", 'SessionType'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly createdBy: FieldRef<"Session", 'String'>
    readonly teamId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Rival
   */

  export type AggregateRival = {
    _count: RivalCountAggregateOutputType | null
    _min: RivalMinAggregateOutputType | null
    _max: RivalMaxAggregateOutputType | null
  }

  export type RivalMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    name: string | null
    logoUrl: string | null
    coach: string | null
    baseSystem: string | null
    nextMatchDate: Date | null
    nextMatchCompetition: string | null
    planCharlaUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RivalMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    name: string | null
    logoUrl: string | null
    coach: string | null
    baseSystem: string | null
    nextMatchDate: Date | null
    nextMatchCompetition: string | null
    planCharlaUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RivalCountAggregateOutputType = {
    id: number
    teamId: number
    name: number
    logoUrl: number
    coach: number
    baseSystem: number
    nextMatchDate: number
    nextMatchCompetition: number
    planCharlaUrl: number
    planReport: number
    planVideos: number
    planStats: number
    planNotes: number
    planVisibility: number
    planSquad: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RivalMinAggregateInputType = {
    id?: true
    teamId?: true
    name?: true
    logoUrl?: true
    coach?: true
    baseSystem?: true
    nextMatchDate?: true
    nextMatchCompetition?: true
    planCharlaUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RivalMaxAggregateInputType = {
    id?: true
    teamId?: true
    name?: true
    logoUrl?: true
    coach?: true
    baseSystem?: true
    nextMatchDate?: true
    nextMatchCompetition?: true
    planCharlaUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RivalCountAggregateInputType = {
    id?: true
    teamId?: true
    name?: true
    logoUrl?: true
    coach?: true
    baseSystem?: true
    nextMatchDate?: true
    nextMatchCompetition?: true
    planCharlaUrl?: true
    planReport?: true
    planVideos?: true
    planStats?: true
    planNotes?: true
    planVisibility?: true
    planSquad?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RivalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rival to aggregate.
     */
    where?: RivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rivals to fetch.
     */
    orderBy?: RivalOrderByWithRelationInput | RivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rivals
    **/
    _count?: true | RivalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RivalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RivalMaxAggregateInputType
  }

  export type GetRivalAggregateType<T extends RivalAggregateArgs> = {
        [P in keyof T & keyof AggregateRival]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRival[P]>
      : GetScalarType<T[P], AggregateRival[P]>
  }




  export type RivalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RivalWhereInput
    orderBy?: RivalOrderByWithAggregationInput | RivalOrderByWithAggregationInput[]
    by: RivalScalarFieldEnum[] | RivalScalarFieldEnum
    having?: RivalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RivalCountAggregateInputType | true
    _min?: RivalMinAggregateInputType
    _max?: RivalMaxAggregateInputType
  }

  export type RivalGroupByOutputType = {
    id: string
    teamId: string
    name: string
    logoUrl: string | null
    coach: string | null
    baseSystem: string | null
    nextMatchDate: Date | null
    nextMatchCompetition: string | null
    planCharlaUrl: string | null
    planReport: JsonValue | null
    planVideos: JsonValue | null
    planStats: JsonValue | null
    planNotes: JsonValue | null
    planVisibility: JsonValue | null
    planSquad: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: RivalCountAggregateOutputType | null
    _min: RivalMinAggregateOutputType | null
    _max: RivalMaxAggregateOutputType | null
  }

  type GetRivalGroupByPayload<T extends RivalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RivalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RivalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RivalGroupByOutputType[P]>
            : GetScalarType<T[P], RivalGroupByOutputType[P]>
        }
      >
    >


  export type RivalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    name?: boolean
    logoUrl?: boolean
    coach?: boolean
    baseSystem?: boolean
    nextMatchDate?: boolean
    nextMatchCompetition?: boolean
    planCharlaUrl?: boolean
    planReport?: boolean
    planVideos?: boolean
    planStats?: boolean
    planNotes?: boolean
    planVisibility?: boolean
    planSquad?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rival"]>

  export type RivalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    name?: boolean
    logoUrl?: boolean
    coach?: boolean
    baseSystem?: boolean
    nextMatchDate?: boolean
    nextMatchCompetition?: boolean
    planCharlaUrl?: boolean
    planReport?: boolean
    planVideos?: boolean
    planStats?: boolean
    planNotes?: boolean
    planVisibility?: boolean
    planSquad?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rival"]>

  export type RivalSelectScalar = {
    id?: boolean
    teamId?: boolean
    name?: boolean
    logoUrl?: boolean
    coach?: boolean
    baseSystem?: boolean
    nextMatchDate?: boolean
    nextMatchCompetition?: boolean
    planCharlaUrl?: boolean
    planReport?: boolean
    planVideos?: boolean
    planStats?: boolean
    planNotes?: boolean
    planVisibility?: boolean
    planSquad?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RivalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type RivalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $RivalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rival"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      name: string
      logoUrl: string | null
      coach: string | null
      baseSystem: string | null
      nextMatchDate: Date | null
      nextMatchCompetition: string | null
      planCharlaUrl: string | null
      planReport: Prisma.JsonValue | null
      planVideos: Prisma.JsonValue | null
      planStats: Prisma.JsonValue | null
      planNotes: Prisma.JsonValue | null
      planVisibility: Prisma.JsonValue | null
      planSquad: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rival"]>
    composites: {}
  }

  type RivalGetPayload<S extends boolean | null | undefined | RivalDefaultArgs> = $Result.GetResult<Prisma.$RivalPayload, S>

  type RivalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RivalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RivalCountAggregateInputType | true
    }

  export interface RivalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rival'], meta: { name: 'Rival' } }
    /**
     * Find zero or one Rival that matches the filter.
     * @param {RivalFindUniqueArgs} args - Arguments to find a Rival
     * @example
     * // Get one Rival
     * const rival = await prisma.rival.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RivalFindUniqueArgs>(args: SelectSubset<T, RivalFindUniqueArgs<ExtArgs>>): Prisma__RivalClient<$Result.GetResult<Prisma.$RivalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Rival that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RivalFindUniqueOrThrowArgs} args - Arguments to find a Rival
     * @example
     * // Get one Rival
     * const rival = await prisma.rival.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RivalFindUniqueOrThrowArgs>(args: SelectSubset<T, RivalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RivalClient<$Result.GetResult<Prisma.$RivalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Rival that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RivalFindFirstArgs} args - Arguments to find a Rival
     * @example
     * // Get one Rival
     * const rival = await prisma.rival.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RivalFindFirstArgs>(args?: SelectSubset<T, RivalFindFirstArgs<ExtArgs>>): Prisma__RivalClient<$Result.GetResult<Prisma.$RivalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Rival that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RivalFindFirstOrThrowArgs} args - Arguments to find a Rival
     * @example
     * // Get one Rival
     * const rival = await prisma.rival.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RivalFindFirstOrThrowArgs>(args?: SelectSubset<T, RivalFindFirstOrThrowArgs<ExtArgs>>): Prisma__RivalClient<$Result.GetResult<Prisma.$RivalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rivals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RivalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rivals
     * const rivals = await prisma.rival.findMany()
     * 
     * // Get first 10 Rivals
     * const rivals = await prisma.rival.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rivalWithIdOnly = await prisma.rival.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RivalFindManyArgs>(args?: SelectSubset<T, RivalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RivalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Rival.
     * @param {RivalCreateArgs} args - Arguments to create a Rival.
     * @example
     * // Create one Rival
     * const Rival = await prisma.rival.create({
     *   data: {
     *     // ... data to create a Rival
     *   }
     * })
     * 
     */
    create<T extends RivalCreateArgs>(args: SelectSubset<T, RivalCreateArgs<ExtArgs>>): Prisma__RivalClient<$Result.GetResult<Prisma.$RivalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rivals.
     * @param {RivalCreateManyArgs} args - Arguments to create many Rivals.
     * @example
     * // Create many Rivals
     * const rival = await prisma.rival.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RivalCreateManyArgs>(args?: SelectSubset<T, RivalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rivals and returns the data saved in the database.
     * @param {RivalCreateManyAndReturnArgs} args - Arguments to create many Rivals.
     * @example
     * // Create many Rivals
     * const rival = await prisma.rival.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rivals and only return the `id`
     * const rivalWithIdOnly = await prisma.rival.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RivalCreateManyAndReturnArgs>(args?: SelectSubset<T, RivalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RivalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Rival.
     * @param {RivalDeleteArgs} args - Arguments to delete one Rival.
     * @example
     * // Delete one Rival
     * const Rival = await prisma.rival.delete({
     *   where: {
     *     // ... filter to delete one Rival
     *   }
     * })
     * 
     */
    delete<T extends RivalDeleteArgs>(args: SelectSubset<T, RivalDeleteArgs<ExtArgs>>): Prisma__RivalClient<$Result.GetResult<Prisma.$RivalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Rival.
     * @param {RivalUpdateArgs} args - Arguments to update one Rival.
     * @example
     * // Update one Rival
     * const rival = await prisma.rival.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RivalUpdateArgs>(args: SelectSubset<T, RivalUpdateArgs<ExtArgs>>): Prisma__RivalClient<$Result.GetResult<Prisma.$RivalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rivals.
     * @param {RivalDeleteManyArgs} args - Arguments to filter Rivals to delete.
     * @example
     * // Delete a few Rivals
     * const { count } = await prisma.rival.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RivalDeleteManyArgs>(args?: SelectSubset<T, RivalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RivalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rivals
     * const rival = await prisma.rival.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RivalUpdateManyArgs>(args: SelectSubset<T, RivalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rival.
     * @param {RivalUpsertArgs} args - Arguments to update or create a Rival.
     * @example
     * // Update or create a Rival
     * const rival = await prisma.rival.upsert({
     *   create: {
     *     // ... data to create a Rival
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rival we want to update
     *   }
     * })
     */
    upsert<T extends RivalUpsertArgs>(args: SelectSubset<T, RivalUpsertArgs<ExtArgs>>): Prisma__RivalClient<$Result.GetResult<Prisma.$RivalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RivalCountArgs} args - Arguments to filter Rivals to count.
     * @example
     * // Count the number of Rivals
     * const count = await prisma.rival.count({
     *   where: {
     *     // ... the filter for the Rivals we want to count
     *   }
     * })
    **/
    count<T extends RivalCountArgs>(
      args?: Subset<T, RivalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RivalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rival.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RivalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RivalAggregateArgs>(args: Subset<T, RivalAggregateArgs>): Prisma.PrismaPromise<GetRivalAggregateType<T>>

    /**
     * Group by Rival.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RivalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RivalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RivalGroupByArgs['orderBy'] }
        : { orderBy?: RivalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RivalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRivalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rival model
   */
  readonly fields: RivalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rival.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RivalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rival model
   */ 
  interface RivalFieldRefs {
    readonly id: FieldRef<"Rival", 'String'>
    readonly teamId: FieldRef<"Rival", 'String'>
    readonly name: FieldRef<"Rival", 'String'>
    readonly logoUrl: FieldRef<"Rival", 'String'>
    readonly coach: FieldRef<"Rival", 'String'>
    readonly baseSystem: FieldRef<"Rival", 'String'>
    readonly nextMatchDate: FieldRef<"Rival", 'DateTime'>
    readonly nextMatchCompetition: FieldRef<"Rival", 'String'>
    readonly planCharlaUrl: FieldRef<"Rival", 'String'>
    readonly planReport: FieldRef<"Rival", 'Json'>
    readonly planVideos: FieldRef<"Rival", 'Json'>
    readonly planStats: FieldRef<"Rival", 'Json'>
    readonly planNotes: FieldRef<"Rival", 'Json'>
    readonly planVisibility: FieldRef<"Rival", 'Json'>
    readonly planSquad: FieldRef<"Rival", 'Json'>
    readonly createdAt: FieldRef<"Rival", 'DateTime'>
    readonly updatedAt: FieldRef<"Rival", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Rival findUnique
   */
  export type RivalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rival
     */
    select?: RivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RivalInclude<ExtArgs> | null
    /**
     * Filter, which Rival to fetch.
     */
    where: RivalWhereUniqueInput
  }

  /**
   * Rival findUniqueOrThrow
   */
  export type RivalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rival
     */
    select?: RivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RivalInclude<ExtArgs> | null
    /**
     * Filter, which Rival to fetch.
     */
    where: RivalWhereUniqueInput
  }

  /**
   * Rival findFirst
   */
  export type RivalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rival
     */
    select?: RivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RivalInclude<ExtArgs> | null
    /**
     * Filter, which Rival to fetch.
     */
    where?: RivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rivals to fetch.
     */
    orderBy?: RivalOrderByWithRelationInput | RivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rivals.
     */
    cursor?: RivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rivals.
     */
    distinct?: RivalScalarFieldEnum | RivalScalarFieldEnum[]
  }

  /**
   * Rival findFirstOrThrow
   */
  export type RivalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rival
     */
    select?: RivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RivalInclude<ExtArgs> | null
    /**
     * Filter, which Rival to fetch.
     */
    where?: RivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rivals to fetch.
     */
    orderBy?: RivalOrderByWithRelationInput | RivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rivals.
     */
    cursor?: RivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rivals.
     */
    distinct?: RivalScalarFieldEnum | RivalScalarFieldEnum[]
  }

  /**
   * Rival findMany
   */
  export type RivalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rival
     */
    select?: RivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RivalInclude<ExtArgs> | null
    /**
     * Filter, which Rivals to fetch.
     */
    where?: RivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rivals to fetch.
     */
    orderBy?: RivalOrderByWithRelationInput | RivalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rivals.
     */
    cursor?: RivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rivals.
     */
    skip?: number
    distinct?: RivalScalarFieldEnum | RivalScalarFieldEnum[]
  }

  /**
   * Rival create
   */
  export type RivalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rival
     */
    select?: RivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RivalInclude<ExtArgs> | null
    /**
     * The data needed to create a Rival.
     */
    data: XOR<RivalCreateInput, RivalUncheckedCreateInput>
  }

  /**
   * Rival createMany
   */
  export type RivalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rivals.
     */
    data: RivalCreateManyInput | RivalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rival createManyAndReturn
   */
  export type RivalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rival
     */
    select?: RivalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Rivals.
     */
    data: RivalCreateManyInput | RivalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RivalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rival update
   */
  export type RivalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rival
     */
    select?: RivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RivalInclude<ExtArgs> | null
    /**
     * The data needed to update a Rival.
     */
    data: XOR<RivalUpdateInput, RivalUncheckedUpdateInput>
    /**
     * Choose, which Rival to update.
     */
    where: RivalWhereUniqueInput
  }

  /**
   * Rival updateMany
   */
  export type RivalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rivals.
     */
    data: XOR<RivalUpdateManyMutationInput, RivalUncheckedUpdateManyInput>
    /**
     * Filter which Rivals to update
     */
    where?: RivalWhereInput
  }

  /**
   * Rival upsert
   */
  export type RivalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rival
     */
    select?: RivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RivalInclude<ExtArgs> | null
    /**
     * The filter to search for the Rival to update in case it exists.
     */
    where: RivalWhereUniqueInput
    /**
     * In case the Rival found by the `where` argument doesn't exist, create a new Rival with this data.
     */
    create: XOR<RivalCreateInput, RivalUncheckedCreateInput>
    /**
     * In case the Rival was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RivalUpdateInput, RivalUncheckedUpdateInput>
  }

  /**
   * Rival delete
   */
  export type RivalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rival
     */
    select?: RivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RivalInclude<ExtArgs> | null
    /**
     * Filter which Rival to delete.
     */
    where: RivalWhereUniqueInput
  }

  /**
   * Rival deleteMany
   */
  export type RivalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rivals to delete
     */
    where?: RivalWhereInput
  }

  /**
   * Rival without action
   */
  export type RivalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rival
     */
    select?: RivalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RivalInclude<ExtArgs> | null
  }


  /**
   * Model PlayerFeedback
   */

  export type AggregatePlayerFeedback = {
    _count: PlayerFeedbackCountAggregateOutputType | null
    _avg: PlayerFeedbackAvgAggregateOutputType | null
    _sum: PlayerFeedbackSumAggregateOutputType | null
    _min: PlayerFeedbackMinAggregateOutputType | null
    _max: PlayerFeedbackMaxAggregateOutputType | null
  }

  export type PlayerFeedbackAvgAggregateOutputType = {
    rating: number | null
  }

  export type PlayerFeedbackSumAggregateOutputType = {
    rating: number | null
  }

  export type PlayerFeedbackMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    playerId: string | null
    subject: string | null
    text: string | null
    rating: number | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type PlayerFeedbackMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    playerId: string | null
    subject: string | null
    text: string | null
    rating: number | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type PlayerFeedbackCountAggregateOutputType = {
    id: number
    teamId: number
    playerId: number
    subject: number
    text: number
    rating: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type PlayerFeedbackAvgAggregateInputType = {
    rating?: true
  }

  export type PlayerFeedbackSumAggregateInputType = {
    rating?: true
  }

  export type PlayerFeedbackMinAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    subject?: true
    text?: true
    rating?: true
    createdBy?: true
    createdAt?: true
  }

  export type PlayerFeedbackMaxAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    subject?: true
    text?: true
    rating?: true
    createdBy?: true
    createdAt?: true
  }

  export type PlayerFeedbackCountAggregateInputType = {
    id?: true
    teamId?: true
    playerId?: true
    subject?: true
    text?: true
    rating?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type PlayerFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerFeedback to aggregate.
     */
    where?: PlayerFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerFeedbacks to fetch.
     */
    orderBy?: PlayerFeedbackOrderByWithRelationInput | PlayerFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerFeedbacks
    **/
    _count?: true | PlayerFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerFeedbackMaxAggregateInputType
  }

  export type GetPlayerFeedbackAggregateType<T extends PlayerFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerFeedback[P]>
      : GetScalarType<T[P], AggregatePlayerFeedback[P]>
  }




  export type PlayerFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerFeedbackWhereInput
    orderBy?: PlayerFeedbackOrderByWithAggregationInput | PlayerFeedbackOrderByWithAggregationInput[]
    by: PlayerFeedbackScalarFieldEnum[] | PlayerFeedbackScalarFieldEnum
    having?: PlayerFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerFeedbackCountAggregateInputType | true
    _avg?: PlayerFeedbackAvgAggregateInputType
    _sum?: PlayerFeedbackSumAggregateInputType
    _min?: PlayerFeedbackMinAggregateInputType
    _max?: PlayerFeedbackMaxAggregateInputType
  }

  export type PlayerFeedbackGroupByOutputType = {
    id: string
    teamId: string
    playerId: string
    subject: string | null
    text: string
    rating: number | null
    createdBy: string
    createdAt: Date
    _count: PlayerFeedbackCountAggregateOutputType | null
    _avg: PlayerFeedbackAvgAggregateOutputType | null
    _sum: PlayerFeedbackSumAggregateOutputType | null
    _min: PlayerFeedbackMinAggregateOutputType | null
    _max: PlayerFeedbackMaxAggregateOutputType | null
  }

  type GetPlayerFeedbackGroupByPayload<T extends PlayerFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type PlayerFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    subject?: boolean
    text?: boolean
    rating?: boolean
    createdBy?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerFeedback"]>

  export type PlayerFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    subject?: boolean
    text?: boolean
    rating?: boolean
    createdBy?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerFeedback"]>

  export type PlayerFeedbackSelectScalar = {
    id?: boolean
    teamId?: boolean
    playerId?: boolean
    subject?: boolean
    text?: boolean
    rating?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type PlayerFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type PlayerFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $PlayerFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerFeedback"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      playerId: string
      subject: string | null
      text: string
      rating: number | null
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["playerFeedback"]>
    composites: {}
  }

  type PlayerFeedbackGetPayload<S extends boolean | null | undefined | PlayerFeedbackDefaultArgs> = $Result.GetResult<Prisma.$PlayerFeedbackPayload, S>

  type PlayerFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerFeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerFeedbackCountAggregateInputType | true
    }

  export interface PlayerFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerFeedback'], meta: { name: 'PlayerFeedback' } }
    /**
     * Find zero or one PlayerFeedback that matches the filter.
     * @param {PlayerFeedbackFindUniqueArgs} args - Arguments to find a PlayerFeedback
     * @example
     * // Get one PlayerFeedback
     * const playerFeedback = await prisma.playerFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerFeedbackFindUniqueArgs>(args: SelectSubset<T, PlayerFeedbackFindUniqueArgs<ExtArgs>>): Prisma__PlayerFeedbackClient<$Result.GetResult<Prisma.$PlayerFeedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerFeedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerFeedbackFindUniqueOrThrowArgs} args - Arguments to find a PlayerFeedback
     * @example
     * // Get one PlayerFeedback
     * const playerFeedback = await prisma.playerFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerFeedbackClient<$Result.GetResult<Prisma.$PlayerFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFeedbackFindFirstArgs} args - Arguments to find a PlayerFeedback
     * @example
     * // Get one PlayerFeedback
     * const playerFeedback = await prisma.playerFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerFeedbackFindFirstArgs>(args?: SelectSubset<T, PlayerFeedbackFindFirstArgs<ExtArgs>>): Prisma__PlayerFeedbackClient<$Result.GetResult<Prisma.$PlayerFeedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFeedbackFindFirstOrThrowArgs} args - Arguments to find a PlayerFeedback
     * @example
     * // Get one PlayerFeedback
     * const playerFeedback = await prisma.playerFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerFeedbackClient<$Result.GetResult<Prisma.$PlayerFeedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerFeedbacks
     * const playerFeedbacks = await prisma.playerFeedback.findMany()
     * 
     * // Get first 10 PlayerFeedbacks
     * const playerFeedbacks = await prisma.playerFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerFeedbackWithIdOnly = await prisma.playerFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerFeedbackFindManyArgs>(args?: SelectSubset<T, PlayerFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerFeedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerFeedback.
     * @param {PlayerFeedbackCreateArgs} args - Arguments to create a PlayerFeedback.
     * @example
     * // Create one PlayerFeedback
     * const PlayerFeedback = await prisma.playerFeedback.create({
     *   data: {
     *     // ... data to create a PlayerFeedback
     *   }
     * })
     * 
     */
    create<T extends PlayerFeedbackCreateArgs>(args: SelectSubset<T, PlayerFeedbackCreateArgs<ExtArgs>>): Prisma__PlayerFeedbackClient<$Result.GetResult<Prisma.$PlayerFeedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerFeedbacks.
     * @param {PlayerFeedbackCreateManyArgs} args - Arguments to create many PlayerFeedbacks.
     * @example
     * // Create many PlayerFeedbacks
     * const playerFeedback = await prisma.playerFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerFeedbackCreateManyArgs>(args?: SelectSubset<T, PlayerFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerFeedbacks and returns the data saved in the database.
     * @param {PlayerFeedbackCreateManyAndReturnArgs} args - Arguments to create many PlayerFeedbacks.
     * @example
     * // Create many PlayerFeedbacks
     * const playerFeedback = await prisma.playerFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerFeedbacks and only return the `id`
     * const playerFeedbackWithIdOnly = await prisma.playerFeedback.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerFeedbackPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerFeedback.
     * @param {PlayerFeedbackDeleteArgs} args - Arguments to delete one PlayerFeedback.
     * @example
     * // Delete one PlayerFeedback
     * const PlayerFeedback = await prisma.playerFeedback.delete({
     *   where: {
     *     // ... filter to delete one PlayerFeedback
     *   }
     * })
     * 
     */
    delete<T extends PlayerFeedbackDeleteArgs>(args: SelectSubset<T, PlayerFeedbackDeleteArgs<ExtArgs>>): Prisma__PlayerFeedbackClient<$Result.GetResult<Prisma.$PlayerFeedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerFeedback.
     * @param {PlayerFeedbackUpdateArgs} args - Arguments to update one PlayerFeedback.
     * @example
     * // Update one PlayerFeedback
     * const playerFeedback = await prisma.playerFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerFeedbackUpdateArgs>(args: SelectSubset<T, PlayerFeedbackUpdateArgs<ExtArgs>>): Prisma__PlayerFeedbackClient<$Result.GetResult<Prisma.$PlayerFeedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerFeedbacks.
     * @param {PlayerFeedbackDeleteManyArgs} args - Arguments to filter PlayerFeedbacks to delete.
     * @example
     * // Delete a few PlayerFeedbacks
     * const { count } = await prisma.playerFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerFeedbackDeleteManyArgs>(args?: SelectSubset<T, PlayerFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerFeedbacks
     * const playerFeedback = await prisma.playerFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerFeedbackUpdateManyArgs>(args: SelectSubset<T, PlayerFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerFeedback.
     * @param {PlayerFeedbackUpsertArgs} args - Arguments to update or create a PlayerFeedback.
     * @example
     * // Update or create a PlayerFeedback
     * const playerFeedback = await prisma.playerFeedback.upsert({
     *   create: {
     *     // ... data to create a PlayerFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerFeedback we want to update
     *   }
     * })
     */
    upsert<T extends PlayerFeedbackUpsertArgs>(args: SelectSubset<T, PlayerFeedbackUpsertArgs<ExtArgs>>): Prisma__PlayerFeedbackClient<$Result.GetResult<Prisma.$PlayerFeedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFeedbackCountArgs} args - Arguments to filter PlayerFeedbacks to count.
     * @example
     * // Count the number of PlayerFeedbacks
     * const count = await prisma.playerFeedback.count({
     *   where: {
     *     // ... the filter for the PlayerFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends PlayerFeedbackCountArgs>(
      args?: Subset<T, PlayerFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerFeedbackAggregateArgs>(args: Subset<T, PlayerFeedbackAggregateArgs>): Prisma.PrismaPromise<GetPlayerFeedbackAggregateType<T>>

    /**
     * Group by PlayerFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: PlayerFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerFeedback model
   */
  readonly fields: PlayerFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerFeedback model
   */ 
  interface PlayerFeedbackFieldRefs {
    readonly id: FieldRef<"PlayerFeedback", 'String'>
    readonly teamId: FieldRef<"PlayerFeedback", 'String'>
    readonly playerId: FieldRef<"PlayerFeedback", 'String'>
    readonly subject: FieldRef<"PlayerFeedback", 'String'>
    readonly text: FieldRef<"PlayerFeedback", 'String'>
    readonly rating: FieldRef<"PlayerFeedback", 'Int'>
    readonly createdBy: FieldRef<"PlayerFeedback", 'String'>
    readonly createdAt: FieldRef<"PlayerFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerFeedback findUnique
   */
  export type PlayerFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFeedback
     */
    select?: PlayerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PlayerFeedback to fetch.
     */
    where: PlayerFeedbackWhereUniqueInput
  }

  /**
   * PlayerFeedback findUniqueOrThrow
   */
  export type PlayerFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFeedback
     */
    select?: PlayerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PlayerFeedback to fetch.
     */
    where: PlayerFeedbackWhereUniqueInput
  }

  /**
   * PlayerFeedback findFirst
   */
  export type PlayerFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFeedback
     */
    select?: PlayerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PlayerFeedback to fetch.
     */
    where?: PlayerFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerFeedbacks to fetch.
     */
    orderBy?: PlayerFeedbackOrderByWithRelationInput | PlayerFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerFeedbacks.
     */
    cursor?: PlayerFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerFeedbacks.
     */
    distinct?: PlayerFeedbackScalarFieldEnum | PlayerFeedbackScalarFieldEnum[]
  }

  /**
   * PlayerFeedback findFirstOrThrow
   */
  export type PlayerFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFeedback
     */
    select?: PlayerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PlayerFeedback to fetch.
     */
    where?: PlayerFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerFeedbacks to fetch.
     */
    orderBy?: PlayerFeedbackOrderByWithRelationInput | PlayerFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerFeedbacks.
     */
    cursor?: PlayerFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerFeedbacks.
     */
    distinct?: PlayerFeedbackScalarFieldEnum | PlayerFeedbackScalarFieldEnum[]
  }

  /**
   * PlayerFeedback findMany
   */
  export type PlayerFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFeedback
     */
    select?: PlayerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PlayerFeedbacks to fetch.
     */
    where?: PlayerFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerFeedbacks to fetch.
     */
    orderBy?: PlayerFeedbackOrderByWithRelationInput | PlayerFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerFeedbacks.
     */
    cursor?: PlayerFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerFeedbacks.
     */
    skip?: number
    distinct?: PlayerFeedbackScalarFieldEnum | PlayerFeedbackScalarFieldEnum[]
  }

  /**
   * PlayerFeedback create
   */
  export type PlayerFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFeedback
     */
    select?: PlayerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerFeedback.
     */
    data: XOR<PlayerFeedbackCreateInput, PlayerFeedbackUncheckedCreateInput>
  }

  /**
   * PlayerFeedback createMany
   */
  export type PlayerFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerFeedbacks.
     */
    data: PlayerFeedbackCreateManyInput | PlayerFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerFeedback createManyAndReturn
   */
  export type PlayerFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFeedback
     */
    select?: PlayerFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerFeedbacks.
     */
    data: PlayerFeedbackCreateManyInput | PlayerFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerFeedback update
   */
  export type PlayerFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFeedback
     */
    select?: PlayerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerFeedback.
     */
    data: XOR<PlayerFeedbackUpdateInput, PlayerFeedbackUncheckedUpdateInput>
    /**
     * Choose, which PlayerFeedback to update.
     */
    where: PlayerFeedbackWhereUniqueInput
  }

  /**
   * PlayerFeedback updateMany
   */
  export type PlayerFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerFeedbacks.
     */
    data: XOR<PlayerFeedbackUpdateManyMutationInput, PlayerFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which PlayerFeedbacks to update
     */
    where?: PlayerFeedbackWhereInput
  }

  /**
   * PlayerFeedback upsert
   */
  export type PlayerFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFeedback
     */
    select?: PlayerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerFeedback to update in case it exists.
     */
    where: PlayerFeedbackWhereUniqueInput
    /**
     * In case the PlayerFeedback found by the `where` argument doesn't exist, create a new PlayerFeedback with this data.
     */
    create: XOR<PlayerFeedbackCreateInput, PlayerFeedbackUncheckedCreateInput>
    /**
     * In case the PlayerFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerFeedbackUpdateInput, PlayerFeedbackUncheckedUpdateInput>
  }

  /**
   * PlayerFeedback delete
   */
  export type PlayerFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFeedback
     */
    select?: PlayerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFeedbackInclude<ExtArgs> | null
    /**
     * Filter which PlayerFeedback to delete.
     */
    where: PlayerFeedbackWhereUniqueInput
  }

  /**
   * PlayerFeedback deleteMany
   */
  export type PlayerFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerFeedbacks to delete
     */
    where?: PlayerFeedbackWhereInput
  }

  /**
   * PlayerFeedback without action
   */
  export type PlayerFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerFeedback
     */
    select?: PlayerFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model Place
   */

  export type AggregatePlace = {
    _count: PlaceCountAggregateOutputType | null
    _min: PlaceMinAggregateOutputType | null
    _max: PlaceMaxAggregateOutputType | null
  }

  export type PlaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    teamId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    teamId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlaceCountAggregateOutputType = {
    id: number
    name: number
    teamId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlaceMinAggregateInputType = {
    id?: true
    name?: true
    teamId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlaceMaxAggregateInputType = {
    id?: true
    name?: true
    teamId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlaceCountAggregateInputType = {
    id?: true
    name?: true
    teamId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Place to aggregate.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Places
    **/
    _count?: true | PlaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaceMaxAggregateInputType
  }

  export type GetPlaceAggregateType<T extends PlaceAggregateArgs> = {
        [P in keyof T & keyof AggregatePlace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlace[P]>
      : GetScalarType<T[P], AggregatePlace[P]>
  }




  export type PlaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceWhereInput
    orderBy?: PlaceOrderByWithAggregationInput | PlaceOrderByWithAggregationInput[]
    by: PlaceScalarFieldEnum[] | PlaceScalarFieldEnum
    having?: PlaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaceCountAggregateInputType | true
    _min?: PlaceMinAggregateInputType
    _max?: PlaceMaxAggregateInputType
  }

  export type PlaceGroupByOutputType = {
    id: string
    name: string
    teamId: string
    createdAt: Date
    updatedAt: Date
    _count: PlaceCountAggregateOutputType | null
    _min: PlaceMinAggregateOutputType | null
    _max: PlaceMaxAggregateOutputType | null
  }

  type GetPlaceGroupByPayload<T extends PlaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaceGroupByOutputType[P]>
            : GetScalarType<T[P], PlaceGroupByOutputType[P]>
        }
      >
    >


  export type PlaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    teamId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["place"]>

  export type PlaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    teamId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["place"]>

  export type PlaceSelectScalar = {
    id?: boolean
    name?: boolean
    teamId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type PlaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $PlacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Place"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      teamId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["place"]>
    composites: {}
  }

  type PlaceGetPayload<S extends boolean | null | undefined | PlaceDefaultArgs> = $Result.GetResult<Prisma.$PlacePayload, S>

  type PlaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlaceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlaceCountAggregateInputType | true
    }

  export interface PlaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Place'], meta: { name: 'Place' } }
    /**
     * Find zero or one Place that matches the filter.
     * @param {PlaceFindUniqueArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaceFindUniqueArgs>(args: SelectSubset<T, PlaceFindUniqueArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Place that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlaceFindUniqueOrThrowArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaceFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Place that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFindFirstArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaceFindFirstArgs>(args?: SelectSubset<T, PlaceFindFirstArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Place that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFindFirstOrThrowArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaceFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Places that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Places
     * const places = await prisma.place.findMany()
     * 
     * // Get first 10 Places
     * const places = await prisma.place.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const placeWithIdOnly = await prisma.place.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaceFindManyArgs>(args?: SelectSubset<T, PlaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Place.
     * @param {PlaceCreateArgs} args - Arguments to create a Place.
     * @example
     * // Create one Place
     * const Place = await prisma.place.create({
     *   data: {
     *     // ... data to create a Place
     *   }
     * })
     * 
     */
    create<T extends PlaceCreateArgs>(args: SelectSubset<T, PlaceCreateArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Places.
     * @param {PlaceCreateManyArgs} args - Arguments to create many Places.
     * @example
     * // Create many Places
     * const place = await prisma.place.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaceCreateManyArgs>(args?: SelectSubset<T, PlaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Places and returns the data saved in the database.
     * @param {PlaceCreateManyAndReturnArgs} args - Arguments to create many Places.
     * @example
     * // Create many Places
     * const place = await prisma.place.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Places and only return the `id`
     * const placeWithIdOnly = await prisma.place.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaceCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Place.
     * @param {PlaceDeleteArgs} args - Arguments to delete one Place.
     * @example
     * // Delete one Place
     * const Place = await prisma.place.delete({
     *   where: {
     *     // ... filter to delete one Place
     *   }
     * })
     * 
     */
    delete<T extends PlaceDeleteArgs>(args: SelectSubset<T, PlaceDeleteArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Place.
     * @param {PlaceUpdateArgs} args - Arguments to update one Place.
     * @example
     * // Update one Place
     * const place = await prisma.place.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaceUpdateArgs>(args: SelectSubset<T, PlaceUpdateArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Places.
     * @param {PlaceDeleteManyArgs} args - Arguments to filter Places to delete.
     * @example
     * // Delete a few Places
     * const { count } = await prisma.place.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaceDeleteManyArgs>(args?: SelectSubset<T, PlaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Places.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Places
     * const place = await prisma.place.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaceUpdateManyArgs>(args: SelectSubset<T, PlaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Place.
     * @param {PlaceUpsertArgs} args - Arguments to update or create a Place.
     * @example
     * // Update or create a Place
     * const place = await prisma.place.upsert({
     *   create: {
     *     // ... data to create a Place
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Place we want to update
     *   }
     * })
     */
    upsert<T extends PlaceUpsertArgs>(args: SelectSubset<T, PlaceUpsertArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Places.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceCountArgs} args - Arguments to filter Places to count.
     * @example
     * // Count the number of Places
     * const count = await prisma.place.count({
     *   where: {
     *     // ... the filter for the Places we want to count
     *   }
     * })
    **/
    count<T extends PlaceCountArgs>(
      args?: Subset<T, PlaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Place.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaceAggregateArgs>(args: Subset<T, PlaceAggregateArgs>): Prisma.PrismaPromise<GetPlaceAggregateType<T>>

    /**
     * Group by Place.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaceGroupByArgs['orderBy'] }
        : { orderBy?: PlaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Place model
   */
  readonly fields: PlaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Place.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Place model
   */ 
  interface PlaceFieldRefs {
    readonly id: FieldRef<"Place", 'String'>
    readonly name: FieldRef<"Place", 'String'>
    readonly teamId: FieldRef<"Place", 'String'>
    readonly createdAt: FieldRef<"Place", 'DateTime'>
    readonly updatedAt: FieldRef<"Place", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Place findUnique
   */
  export type PlaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place findUniqueOrThrow
   */
  export type PlaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place findFirst
   */
  export type PlaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Places.
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Places.
     */
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Place findFirstOrThrow
   */
  export type PlaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Places.
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Places.
     */
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Place findMany
   */
  export type PlaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Places to fetch.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Places.
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Place create
   */
  export type PlaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Place.
     */
    data: XOR<PlaceCreateInput, PlaceUncheckedCreateInput>
  }

  /**
   * Place createMany
   */
  export type PlaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Places.
     */
    data: PlaceCreateManyInput | PlaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Place createManyAndReturn
   */
  export type PlaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Places.
     */
    data: PlaceCreateManyInput | PlaceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Place update
   */
  export type PlaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Place.
     */
    data: XOR<PlaceUpdateInput, PlaceUncheckedUpdateInput>
    /**
     * Choose, which Place to update.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place updateMany
   */
  export type PlaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Places.
     */
    data: XOR<PlaceUpdateManyMutationInput, PlaceUncheckedUpdateManyInput>
    /**
     * Filter which Places to update
     */
    where?: PlaceWhereInput
  }

  /**
   * Place upsert
   */
  export type PlaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Place to update in case it exists.
     */
    where: PlaceWhereUniqueInput
    /**
     * In case the Place found by the `where` argument doesn't exist, create a new Place with this data.
     */
    create: XOR<PlaceCreateInput, PlaceUncheckedCreateInput>
    /**
     * In case the Place was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaceUpdateInput, PlaceUncheckedUpdateInput>
  }

  /**
   * Place delete
   */
  export type PlaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter which Place to delete.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place deleteMany
   */
  export type PlaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Places to delete
     */
    where?: PlaceWhereInput
  }

  /**
   * Place without action
   */
  export type PlaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
  }


  /**
   * Model ExerciseKind
   */

  export type AggregateExerciseKind = {
    _count: ExerciseKindCountAggregateOutputType | null
    _min: ExerciseKindMinAggregateOutputType | null
    _max: ExerciseKindMaxAggregateOutputType | null
  }

  export type ExerciseKindMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseKindMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseKindCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExerciseKindMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseKindMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseKindCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExerciseKindAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseKind to aggregate.
     */
    where?: ExerciseKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseKinds to fetch.
     */
    orderBy?: ExerciseKindOrderByWithRelationInput | ExerciseKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExerciseKinds
    **/
    _count?: true | ExerciseKindCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseKindMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseKindMaxAggregateInputType
  }

  export type GetExerciseKindAggregateType<T extends ExerciseKindAggregateArgs> = {
        [P in keyof T & keyof AggregateExerciseKind]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExerciseKind[P]>
      : GetScalarType<T[P], AggregateExerciseKind[P]>
  }




  export type ExerciseKindGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseKindWhereInput
    orderBy?: ExerciseKindOrderByWithAggregationInput | ExerciseKindOrderByWithAggregationInput[]
    by: ExerciseKindScalarFieldEnum[] | ExerciseKindScalarFieldEnum
    having?: ExerciseKindScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseKindCountAggregateInputType | true
    _min?: ExerciseKindMinAggregateInputType
    _max?: ExerciseKindMaxAggregateInputType
  }

  export type ExerciseKindGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ExerciseKindCountAggregateOutputType | null
    _min: ExerciseKindMinAggregateOutputType | null
    _max: ExerciseKindMaxAggregateOutputType | null
  }

  type GetExerciseKindGroupByPayload<T extends ExerciseKindGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseKindGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseKindGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseKindGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseKindGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseKindSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exercises?: boolean | ExerciseKind$exercisesArgs<ExtArgs>
    _count?: boolean | ExerciseKindCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseKind"]>

  export type ExerciseKindSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["exerciseKind"]>

  export type ExerciseKindSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExerciseKindInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercises?: boolean | ExerciseKind$exercisesArgs<ExtArgs>
    _count?: boolean | ExerciseKindCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExerciseKindIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ExerciseKindPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExerciseKind"
    objects: {
      exercises: Prisma.$ExercisePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exerciseKind"]>
    composites: {}
  }

  type ExerciseKindGetPayload<S extends boolean | null | undefined | ExerciseKindDefaultArgs> = $Result.GetResult<Prisma.$ExerciseKindPayload, S>

  type ExerciseKindCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExerciseKindFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExerciseKindCountAggregateInputType | true
    }

  export interface ExerciseKindDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExerciseKind'], meta: { name: 'ExerciseKind' } }
    /**
     * Find zero or one ExerciseKind that matches the filter.
     * @param {ExerciseKindFindUniqueArgs} args - Arguments to find a ExerciseKind
     * @example
     * // Get one ExerciseKind
     * const exerciseKind = await prisma.exerciseKind.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseKindFindUniqueArgs>(args: SelectSubset<T, ExerciseKindFindUniqueArgs<ExtArgs>>): Prisma__ExerciseKindClient<$Result.GetResult<Prisma.$ExerciseKindPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExerciseKind that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExerciseKindFindUniqueOrThrowArgs} args - Arguments to find a ExerciseKind
     * @example
     * // Get one ExerciseKind
     * const exerciseKind = await prisma.exerciseKind.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseKindFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseKindFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseKindClient<$Result.GetResult<Prisma.$ExerciseKindPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExerciseKind that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseKindFindFirstArgs} args - Arguments to find a ExerciseKind
     * @example
     * // Get one ExerciseKind
     * const exerciseKind = await prisma.exerciseKind.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseKindFindFirstArgs>(args?: SelectSubset<T, ExerciseKindFindFirstArgs<ExtArgs>>): Prisma__ExerciseKindClient<$Result.GetResult<Prisma.$ExerciseKindPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExerciseKind that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseKindFindFirstOrThrowArgs} args - Arguments to find a ExerciseKind
     * @example
     * // Get one ExerciseKind
     * const exerciseKind = await prisma.exerciseKind.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseKindFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseKindFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseKindClient<$Result.GetResult<Prisma.$ExerciseKindPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExerciseKinds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseKindFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExerciseKinds
     * const exerciseKinds = await prisma.exerciseKind.findMany()
     * 
     * // Get first 10 ExerciseKinds
     * const exerciseKinds = await prisma.exerciseKind.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseKindWithIdOnly = await prisma.exerciseKind.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseKindFindManyArgs>(args?: SelectSubset<T, ExerciseKindFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseKindPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExerciseKind.
     * @param {ExerciseKindCreateArgs} args - Arguments to create a ExerciseKind.
     * @example
     * // Create one ExerciseKind
     * const ExerciseKind = await prisma.exerciseKind.create({
     *   data: {
     *     // ... data to create a ExerciseKind
     *   }
     * })
     * 
     */
    create<T extends ExerciseKindCreateArgs>(args: SelectSubset<T, ExerciseKindCreateArgs<ExtArgs>>): Prisma__ExerciseKindClient<$Result.GetResult<Prisma.$ExerciseKindPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExerciseKinds.
     * @param {ExerciseKindCreateManyArgs} args - Arguments to create many ExerciseKinds.
     * @example
     * // Create many ExerciseKinds
     * const exerciseKind = await prisma.exerciseKind.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseKindCreateManyArgs>(args?: SelectSubset<T, ExerciseKindCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExerciseKinds and returns the data saved in the database.
     * @param {ExerciseKindCreateManyAndReturnArgs} args - Arguments to create many ExerciseKinds.
     * @example
     * // Create many ExerciseKinds
     * const exerciseKind = await prisma.exerciseKind.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExerciseKinds and only return the `id`
     * const exerciseKindWithIdOnly = await prisma.exerciseKind.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseKindCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseKindCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseKindPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExerciseKind.
     * @param {ExerciseKindDeleteArgs} args - Arguments to delete one ExerciseKind.
     * @example
     * // Delete one ExerciseKind
     * const ExerciseKind = await prisma.exerciseKind.delete({
     *   where: {
     *     // ... filter to delete one ExerciseKind
     *   }
     * })
     * 
     */
    delete<T extends ExerciseKindDeleteArgs>(args: SelectSubset<T, ExerciseKindDeleteArgs<ExtArgs>>): Prisma__ExerciseKindClient<$Result.GetResult<Prisma.$ExerciseKindPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExerciseKind.
     * @param {ExerciseKindUpdateArgs} args - Arguments to update one ExerciseKind.
     * @example
     * // Update one ExerciseKind
     * const exerciseKind = await prisma.exerciseKind.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseKindUpdateArgs>(args: SelectSubset<T, ExerciseKindUpdateArgs<ExtArgs>>): Prisma__ExerciseKindClient<$Result.GetResult<Prisma.$ExerciseKindPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExerciseKinds.
     * @param {ExerciseKindDeleteManyArgs} args - Arguments to filter ExerciseKinds to delete.
     * @example
     * // Delete a few ExerciseKinds
     * const { count } = await prisma.exerciseKind.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseKindDeleteManyArgs>(args?: SelectSubset<T, ExerciseKindDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseKinds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseKindUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExerciseKinds
     * const exerciseKind = await prisma.exerciseKind.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseKindUpdateManyArgs>(args: SelectSubset<T, ExerciseKindUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExerciseKind.
     * @param {ExerciseKindUpsertArgs} args - Arguments to update or create a ExerciseKind.
     * @example
     * // Update or create a ExerciseKind
     * const exerciseKind = await prisma.exerciseKind.upsert({
     *   create: {
     *     // ... data to create a ExerciseKind
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExerciseKind we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseKindUpsertArgs>(args: SelectSubset<T, ExerciseKindUpsertArgs<ExtArgs>>): Prisma__ExerciseKindClient<$Result.GetResult<Prisma.$ExerciseKindPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExerciseKinds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseKindCountArgs} args - Arguments to filter ExerciseKinds to count.
     * @example
     * // Count the number of ExerciseKinds
     * const count = await prisma.exerciseKind.count({
     *   where: {
     *     // ... the filter for the ExerciseKinds we want to count
     *   }
     * })
    **/
    count<T extends ExerciseKindCountArgs>(
      args?: Subset<T, ExerciseKindCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseKindCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExerciseKind.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseKindAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseKindAggregateArgs>(args: Subset<T, ExerciseKindAggregateArgs>): Prisma.PrismaPromise<GetExerciseKindAggregateType<T>>

    /**
     * Group by ExerciseKind.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseKindGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseKindGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseKindGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseKindGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseKindGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseKindGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExerciseKind model
   */
  readonly fields: ExerciseKindFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExerciseKind.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseKindClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exercises<T extends ExerciseKind$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseKind$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExerciseKind model
   */ 
  interface ExerciseKindFieldRefs {
    readonly id: FieldRef<"ExerciseKind", 'String'>
    readonly name: FieldRef<"ExerciseKind", 'String'>
    readonly createdAt: FieldRef<"ExerciseKind", 'DateTime'>
    readonly updatedAt: FieldRef<"ExerciseKind", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExerciseKind findUnique
   */
  export type ExerciseKindFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseKind
     */
    select?: ExerciseKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseKindInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseKind to fetch.
     */
    where: ExerciseKindWhereUniqueInput
  }

  /**
   * ExerciseKind findUniqueOrThrow
   */
  export type ExerciseKindFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseKind
     */
    select?: ExerciseKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseKindInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseKind to fetch.
     */
    where: ExerciseKindWhereUniqueInput
  }

  /**
   * ExerciseKind findFirst
   */
  export type ExerciseKindFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseKind
     */
    select?: ExerciseKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseKindInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseKind to fetch.
     */
    where?: ExerciseKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseKinds to fetch.
     */
    orderBy?: ExerciseKindOrderByWithRelationInput | ExerciseKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseKinds.
     */
    cursor?: ExerciseKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseKinds.
     */
    distinct?: ExerciseKindScalarFieldEnum | ExerciseKindScalarFieldEnum[]
  }

  /**
   * ExerciseKind findFirstOrThrow
   */
  export type ExerciseKindFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseKind
     */
    select?: ExerciseKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseKindInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseKind to fetch.
     */
    where?: ExerciseKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseKinds to fetch.
     */
    orderBy?: ExerciseKindOrderByWithRelationInput | ExerciseKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseKinds.
     */
    cursor?: ExerciseKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseKinds.
     */
    distinct?: ExerciseKindScalarFieldEnum | ExerciseKindScalarFieldEnum[]
  }

  /**
   * ExerciseKind findMany
   */
  export type ExerciseKindFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseKind
     */
    select?: ExerciseKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseKindInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseKinds to fetch.
     */
    where?: ExerciseKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseKinds to fetch.
     */
    orderBy?: ExerciseKindOrderByWithRelationInput | ExerciseKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExerciseKinds.
     */
    cursor?: ExerciseKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseKinds.
     */
    skip?: number
    distinct?: ExerciseKindScalarFieldEnum | ExerciseKindScalarFieldEnum[]
  }

  /**
   * ExerciseKind create
   */
  export type ExerciseKindCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseKind
     */
    select?: ExerciseKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseKindInclude<ExtArgs> | null
    /**
     * The data needed to create a ExerciseKind.
     */
    data: XOR<ExerciseKindCreateInput, ExerciseKindUncheckedCreateInput>
  }

  /**
   * ExerciseKind createMany
   */
  export type ExerciseKindCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExerciseKinds.
     */
    data: ExerciseKindCreateManyInput | ExerciseKindCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExerciseKind createManyAndReturn
   */
  export type ExerciseKindCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseKind
     */
    select?: ExerciseKindSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExerciseKinds.
     */
    data: ExerciseKindCreateManyInput | ExerciseKindCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExerciseKind update
   */
  export type ExerciseKindUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseKind
     */
    select?: ExerciseKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseKindInclude<ExtArgs> | null
    /**
     * The data needed to update a ExerciseKind.
     */
    data: XOR<ExerciseKindUpdateInput, ExerciseKindUncheckedUpdateInput>
    /**
     * Choose, which ExerciseKind to update.
     */
    where: ExerciseKindWhereUniqueInput
  }

  /**
   * ExerciseKind updateMany
   */
  export type ExerciseKindUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExerciseKinds.
     */
    data: XOR<ExerciseKindUpdateManyMutationInput, ExerciseKindUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseKinds to update
     */
    where?: ExerciseKindWhereInput
  }

  /**
   * ExerciseKind upsert
   */
  export type ExerciseKindUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseKind
     */
    select?: ExerciseKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseKindInclude<ExtArgs> | null
    /**
     * The filter to search for the ExerciseKind to update in case it exists.
     */
    where: ExerciseKindWhereUniqueInput
    /**
     * In case the ExerciseKind found by the `where` argument doesn't exist, create a new ExerciseKind with this data.
     */
    create: XOR<ExerciseKindCreateInput, ExerciseKindUncheckedCreateInput>
    /**
     * In case the ExerciseKind was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseKindUpdateInput, ExerciseKindUncheckedUpdateInput>
  }

  /**
   * ExerciseKind delete
   */
  export type ExerciseKindDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseKind
     */
    select?: ExerciseKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseKindInclude<ExtArgs> | null
    /**
     * Filter which ExerciseKind to delete.
     */
    where: ExerciseKindWhereUniqueInput
  }

  /**
   * ExerciseKind deleteMany
   */
  export type ExerciseKindDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseKinds to delete
     */
    where?: ExerciseKindWhereInput
  }

  /**
   * ExerciseKind.exercises
   */
  export type ExerciseKind$exercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * ExerciseKind without action
   */
  export type ExerciseKindDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseKind
     */
    select?: ExerciseKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseKindInclude<ExtArgs> | null
  }


  /**
   * Model Exercise
   */

  export type AggregateExercise = {
    _count: ExerciseCountAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  export type ExerciseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    kindId: string | null
    space: string | null
    players: string | null
    duration: string | null
    description: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    kindId: string | null
    space: string | null
    players: string | null
    duration: string | null
    description: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    kindId: number
    space: number
    players: number
    duration: number
    description: number
    imageUrl: number
    tags: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExerciseMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    kindId?: true
    space?: true
    players?: true
    duration?: true
    description?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    kindId?: true
    space?: true
    players?: true
    duration?: true
    description?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    kindId?: true
    space?: true
    players?: true
    duration?: true
    description?: true
    imageUrl?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercise to aggregate.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exercises
    **/
    _count?: true | ExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseMaxAggregateInputType
  }

  export type GetExerciseAggregateType<T extends ExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExercise[P]>
      : GetScalarType<T[P], AggregateExercise[P]>
  }




  export type ExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithAggregationInput | ExerciseOrderByWithAggregationInput[]
    by: ExerciseScalarFieldEnum[] | ExerciseScalarFieldEnum
    having?: ExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseCountAggregateInputType | true
    _min?: ExerciseMinAggregateInputType
    _max?: ExerciseMaxAggregateInputType
  }

  export type ExerciseGroupByOutputType = {
    id: string
    userId: string
    title: string
    kindId: string | null
    space: string | null
    players: string | null
    duration: string | null
    description: string | null
    imageUrl: string | null
    tags: string[]
    createdAt: Date
    updatedAt: Date
    _count: ExerciseCountAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  type GetExerciseGroupByPayload<T extends ExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    kindId?: boolean
    space?: boolean
    players?: boolean
    duration?: boolean
    description?: boolean
    imageUrl?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    kind?: boolean | Exercise$kindArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    kindId?: boolean
    space?: boolean
    players?: boolean
    duration?: boolean
    description?: boolean
    imageUrl?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    kind?: boolean | Exercise$kindArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    kindId?: boolean
    space?: boolean
    players?: boolean
    duration?: boolean
    description?: boolean
    imageUrl?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    kind?: boolean | Exercise$kindArgs<ExtArgs>
  }
  export type ExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    kind?: boolean | Exercise$kindArgs<ExtArgs>
  }

  export type $ExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exercise"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      kind: Prisma.$ExerciseKindPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      kindId: string | null
      space: string | null
      players: string | null
      duration: string | null
      description: string | null
      imageUrl: string | null
      tags: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exercise"]>
    composites: {}
  }

  type ExerciseGetPayload<S extends boolean | null | undefined | ExerciseDefaultArgs> = $Result.GetResult<Prisma.$ExercisePayload, S>

  type ExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExerciseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExerciseCountAggregateInputType | true
    }

  export interface ExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exercise'], meta: { name: 'Exercise' } }
    /**
     * Find zero or one Exercise that matches the filter.
     * @param {ExerciseFindUniqueArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseFindUniqueArgs>(args: SelectSubset<T, ExerciseFindUniqueArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Exercise that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExerciseFindUniqueOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Exercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseFindFirstArgs>(args?: SelectSubset<T, ExerciseFindFirstArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Exercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Exercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exercises
     * const exercises = await prisma.exercise.findMany()
     * 
     * // Get first 10 Exercises
     * const exercises = await prisma.exercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseWithIdOnly = await prisma.exercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseFindManyArgs>(args?: SelectSubset<T, ExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Exercise.
     * @param {ExerciseCreateArgs} args - Arguments to create a Exercise.
     * @example
     * // Create one Exercise
     * const Exercise = await prisma.exercise.create({
     *   data: {
     *     // ... data to create a Exercise
     *   }
     * })
     * 
     */
    create<T extends ExerciseCreateArgs>(args: SelectSubset<T, ExerciseCreateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Exercises.
     * @param {ExerciseCreateManyArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseCreateManyArgs>(args?: SelectSubset<T, ExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exercises and returns the data saved in the database.
     * @param {ExerciseCreateManyAndReturnArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exercises and only return the `id`
     * const exerciseWithIdOnly = await prisma.exercise.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Exercise.
     * @param {ExerciseDeleteArgs} args - Arguments to delete one Exercise.
     * @example
     * // Delete one Exercise
     * const Exercise = await prisma.exercise.delete({
     *   where: {
     *     // ... filter to delete one Exercise
     *   }
     * })
     * 
     */
    delete<T extends ExerciseDeleteArgs>(args: SelectSubset<T, ExerciseDeleteArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Exercise.
     * @param {ExerciseUpdateArgs} args - Arguments to update one Exercise.
     * @example
     * // Update one Exercise
     * const exercise = await prisma.exercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseUpdateArgs>(args: SelectSubset<T, ExerciseUpdateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Exercises.
     * @param {ExerciseDeleteManyArgs} args - Arguments to filter Exercises to delete.
     * @example
     * // Delete a few Exercises
     * const { count } = await prisma.exercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseDeleteManyArgs>(args?: SelectSubset<T, ExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseUpdateManyArgs>(args: SelectSubset<T, ExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exercise.
     * @param {ExerciseUpsertArgs} args - Arguments to update or create a Exercise.
     * @example
     * // Update or create a Exercise
     * const exercise = await prisma.exercise.upsert({
     *   create: {
     *     // ... data to create a Exercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exercise we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseUpsertArgs>(args: SelectSubset<T, ExerciseUpsertArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseCountArgs} args - Arguments to filter Exercises to count.
     * @example
     * // Count the number of Exercises
     * const count = await prisma.exercise.count({
     *   where: {
     *     // ... the filter for the Exercises we want to count
     *   }
     * })
    **/
    count<T extends ExerciseCountArgs>(
      args?: Subset<T, ExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseAggregateArgs>(args: Subset<T, ExerciseAggregateArgs>): Prisma.PrismaPromise<GetExerciseAggregateType<T>>

    /**
     * Group by Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exercise model
   */
  readonly fields: ExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    kind<T extends Exercise$kindArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$kindArgs<ExtArgs>>): Prisma__ExerciseKindClient<$Result.GetResult<Prisma.$ExerciseKindPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exercise model
   */ 
  interface ExerciseFieldRefs {
    readonly id: FieldRef<"Exercise", 'String'>
    readonly userId: FieldRef<"Exercise", 'String'>
    readonly title: FieldRef<"Exercise", 'String'>
    readonly kindId: FieldRef<"Exercise", 'String'>
    readonly space: FieldRef<"Exercise", 'String'>
    readonly players: FieldRef<"Exercise", 'String'>
    readonly duration: FieldRef<"Exercise", 'String'>
    readonly description: FieldRef<"Exercise", 'String'>
    readonly imageUrl: FieldRef<"Exercise", 'String'>
    readonly tags: FieldRef<"Exercise", 'String[]'>
    readonly createdAt: FieldRef<"Exercise", 'DateTime'>
    readonly updatedAt: FieldRef<"Exercise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exercise findUnique
   */
  export type ExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findUniqueOrThrow
   */
  export type ExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findFirst
   */
  export type ExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findFirstOrThrow
   */
  export type ExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findMany
   */
  export type ExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercises to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise create
   */
  export type ExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a Exercise.
     */
    data: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
  }

  /**
   * Exercise createMany
   */
  export type ExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exercise createManyAndReturn
   */
  export type ExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exercise update
   */
  export type ExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a Exercise.
     */
    data: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
    /**
     * Choose, which Exercise to update.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise updateMany
   */
  export type ExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
  }

  /**
   * Exercise upsert
   */
  export type ExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the Exercise to update in case it exists.
     */
    where: ExerciseWhereUniqueInput
    /**
     * In case the Exercise found by the `where` argument doesn't exist, create a new Exercise with this data.
     */
    create: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
    /**
     * In case the Exercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
  }

  /**
   * Exercise delete
   */
  export type ExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter which Exercise to delete.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise deleteMany
   */
  export type ExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercises to delete
     */
    where?: ExerciseWhereInput
  }

  /**
   * Exercise.kind
   */
  export type Exercise$kindArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseKind
     */
    select?: ExerciseKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseKindInclude<ExtArgs> | null
    where?: ExerciseKindWhereInput
  }

  /**
   * Exercise without action
   */
  export type ExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
  }


  /**
   * Model RPEEntry
   */

  export type AggregateRPEEntry = {
    _count: RPEEntryCountAggregateOutputType | null
    _avg: RPEEntryAvgAggregateOutputType | null
    _sum: RPEEntrySumAggregateOutputType | null
    _min: RPEEntryMinAggregateOutputType | null
    _max: RPEEntryMaxAggregateOutputType | null
  }

  export type RPEEntryAvgAggregateOutputType = {
    session: number | null
    rpe: number | null
    duration: number | null
    load: number | null
  }

  export type RPEEntrySumAggregateOutputType = {
    session: number | null
    rpe: number | null
    duration: number | null
    load: number | null
  }

  export type RPEEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    session: number | null
    sessionLabel: string | null
    sessionUid: string | null
    rpe: number | null
    duration: number | null
    load: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RPEEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    session: number | null
    sessionLabel: string | null
    sessionUid: string | null
    rpe: number | null
    duration: number | null
    load: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RPEEntryCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    session: number
    sessionLabel: number
    sessionUid: number
    rpe: number
    duration: number
    load: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RPEEntryAvgAggregateInputType = {
    session?: true
    rpe?: true
    duration?: true
    load?: true
  }

  export type RPEEntrySumAggregateInputType = {
    session?: true
    rpe?: true
    duration?: true
    load?: true
  }

  export type RPEEntryMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    session?: true
    sessionLabel?: true
    sessionUid?: true
    rpe?: true
    duration?: true
    load?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RPEEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    session?: true
    sessionLabel?: true
    sessionUid?: true
    rpe?: true
    duration?: true
    load?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RPEEntryCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    session?: true
    sessionLabel?: true
    sessionUid?: true
    rpe?: true
    duration?: true
    load?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RPEEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RPEEntry to aggregate.
     */
    where?: RPEEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RPEEntries to fetch.
     */
    orderBy?: RPEEntryOrderByWithRelationInput | RPEEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RPEEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RPEEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RPEEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RPEEntries
    **/
    _count?: true | RPEEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RPEEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RPEEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RPEEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RPEEntryMaxAggregateInputType
  }

  export type GetRPEEntryAggregateType<T extends RPEEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateRPEEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRPEEntry[P]>
      : GetScalarType<T[P], AggregateRPEEntry[P]>
  }




  export type RPEEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RPEEntryWhereInput
    orderBy?: RPEEntryOrderByWithAggregationInput | RPEEntryOrderByWithAggregationInput[]
    by: RPEEntryScalarFieldEnum[] | RPEEntryScalarFieldEnum
    having?: RPEEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RPEEntryCountAggregateInputType | true
    _avg?: RPEEntryAvgAggregateInputType
    _sum?: RPEEntrySumAggregateInputType
    _min?: RPEEntryMinAggregateInputType
    _max?: RPEEntryMaxAggregateInputType
  }

  export type RPEEntryGroupByOutputType = {
    id: string
    userId: string
    date: Date
    session: number
    sessionLabel: string | null
    sessionUid: string | null
    rpe: number
    duration: number | null
    load: number | null
    createdAt: Date
    updatedAt: Date
    _count: RPEEntryCountAggregateOutputType | null
    _avg: RPEEntryAvgAggregateOutputType | null
    _sum: RPEEntrySumAggregateOutputType | null
    _min: RPEEntryMinAggregateOutputType | null
    _max: RPEEntryMaxAggregateOutputType | null
  }

  type GetRPEEntryGroupByPayload<T extends RPEEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RPEEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RPEEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RPEEntryGroupByOutputType[P]>
            : GetScalarType<T[P], RPEEntryGroupByOutputType[P]>
        }
      >
    >


  export type RPEEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    session?: boolean
    sessionLabel?: boolean
    sessionUid?: boolean
    rpe?: boolean
    duration?: boolean
    load?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rPEEntry"]>

  export type RPEEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    session?: boolean
    sessionLabel?: boolean
    sessionUid?: boolean
    rpe?: boolean
    duration?: boolean
    load?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rPEEntry"]>

  export type RPEEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    session?: boolean
    sessionLabel?: boolean
    sessionUid?: boolean
    rpe?: boolean
    duration?: boolean
    load?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RPEEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RPEEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RPEEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RPEEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      session: number
      sessionLabel: string | null
      sessionUid: string | null
      rpe: number
      duration: number | null
      load: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rPEEntry"]>
    composites: {}
  }

  type RPEEntryGetPayload<S extends boolean | null | undefined | RPEEntryDefaultArgs> = $Result.GetResult<Prisma.$RPEEntryPayload, S>

  type RPEEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RPEEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RPEEntryCountAggregateInputType | true
    }

  export interface RPEEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RPEEntry'], meta: { name: 'RPEEntry' } }
    /**
     * Find zero or one RPEEntry that matches the filter.
     * @param {RPEEntryFindUniqueArgs} args - Arguments to find a RPEEntry
     * @example
     * // Get one RPEEntry
     * const rPEEntry = await prisma.rPEEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RPEEntryFindUniqueArgs>(args: SelectSubset<T, RPEEntryFindUniqueArgs<ExtArgs>>): Prisma__RPEEntryClient<$Result.GetResult<Prisma.$RPEEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RPEEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RPEEntryFindUniqueOrThrowArgs} args - Arguments to find a RPEEntry
     * @example
     * // Get one RPEEntry
     * const rPEEntry = await prisma.rPEEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RPEEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, RPEEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RPEEntryClient<$Result.GetResult<Prisma.$RPEEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RPEEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RPEEntryFindFirstArgs} args - Arguments to find a RPEEntry
     * @example
     * // Get one RPEEntry
     * const rPEEntry = await prisma.rPEEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RPEEntryFindFirstArgs>(args?: SelectSubset<T, RPEEntryFindFirstArgs<ExtArgs>>): Prisma__RPEEntryClient<$Result.GetResult<Prisma.$RPEEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RPEEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RPEEntryFindFirstOrThrowArgs} args - Arguments to find a RPEEntry
     * @example
     * // Get one RPEEntry
     * const rPEEntry = await prisma.rPEEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RPEEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, RPEEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__RPEEntryClient<$Result.GetResult<Prisma.$RPEEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RPEEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RPEEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RPEEntries
     * const rPEEntries = await prisma.rPEEntry.findMany()
     * 
     * // Get first 10 RPEEntries
     * const rPEEntries = await prisma.rPEEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rPEEntryWithIdOnly = await prisma.rPEEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RPEEntryFindManyArgs>(args?: SelectSubset<T, RPEEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RPEEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RPEEntry.
     * @param {RPEEntryCreateArgs} args - Arguments to create a RPEEntry.
     * @example
     * // Create one RPEEntry
     * const RPEEntry = await prisma.rPEEntry.create({
     *   data: {
     *     // ... data to create a RPEEntry
     *   }
     * })
     * 
     */
    create<T extends RPEEntryCreateArgs>(args: SelectSubset<T, RPEEntryCreateArgs<ExtArgs>>): Prisma__RPEEntryClient<$Result.GetResult<Prisma.$RPEEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RPEEntries.
     * @param {RPEEntryCreateManyArgs} args - Arguments to create many RPEEntries.
     * @example
     * // Create many RPEEntries
     * const rPEEntry = await prisma.rPEEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RPEEntryCreateManyArgs>(args?: SelectSubset<T, RPEEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RPEEntries and returns the data saved in the database.
     * @param {RPEEntryCreateManyAndReturnArgs} args - Arguments to create many RPEEntries.
     * @example
     * // Create many RPEEntries
     * const rPEEntry = await prisma.rPEEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RPEEntries and only return the `id`
     * const rPEEntryWithIdOnly = await prisma.rPEEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RPEEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, RPEEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RPEEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RPEEntry.
     * @param {RPEEntryDeleteArgs} args - Arguments to delete one RPEEntry.
     * @example
     * // Delete one RPEEntry
     * const RPEEntry = await prisma.rPEEntry.delete({
     *   where: {
     *     // ... filter to delete one RPEEntry
     *   }
     * })
     * 
     */
    delete<T extends RPEEntryDeleteArgs>(args: SelectSubset<T, RPEEntryDeleteArgs<ExtArgs>>): Prisma__RPEEntryClient<$Result.GetResult<Prisma.$RPEEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RPEEntry.
     * @param {RPEEntryUpdateArgs} args - Arguments to update one RPEEntry.
     * @example
     * // Update one RPEEntry
     * const rPEEntry = await prisma.rPEEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RPEEntryUpdateArgs>(args: SelectSubset<T, RPEEntryUpdateArgs<ExtArgs>>): Prisma__RPEEntryClient<$Result.GetResult<Prisma.$RPEEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RPEEntries.
     * @param {RPEEntryDeleteManyArgs} args - Arguments to filter RPEEntries to delete.
     * @example
     * // Delete a few RPEEntries
     * const { count } = await prisma.rPEEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RPEEntryDeleteManyArgs>(args?: SelectSubset<T, RPEEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RPEEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RPEEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RPEEntries
     * const rPEEntry = await prisma.rPEEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RPEEntryUpdateManyArgs>(args: SelectSubset<T, RPEEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RPEEntry.
     * @param {RPEEntryUpsertArgs} args - Arguments to update or create a RPEEntry.
     * @example
     * // Update or create a RPEEntry
     * const rPEEntry = await prisma.rPEEntry.upsert({
     *   create: {
     *     // ... data to create a RPEEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RPEEntry we want to update
     *   }
     * })
     */
    upsert<T extends RPEEntryUpsertArgs>(args: SelectSubset<T, RPEEntryUpsertArgs<ExtArgs>>): Prisma__RPEEntryClient<$Result.GetResult<Prisma.$RPEEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RPEEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RPEEntryCountArgs} args - Arguments to filter RPEEntries to count.
     * @example
     * // Count the number of RPEEntries
     * const count = await prisma.rPEEntry.count({
     *   where: {
     *     // ... the filter for the RPEEntries we want to count
     *   }
     * })
    **/
    count<T extends RPEEntryCountArgs>(
      args?: Subset<T, RPEEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RPEEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RPEEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RPEEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RPEEntryAggregateArgs>(args: Subset<T, RPEEntryAggregateArgs>): Prisma.PrismaPromise<GetRPEEntryAggregateType<T>>

    /**
     * Group by RPEEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RPEEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RPEEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RPEEntryGroupByArgs['orderBy'] }
        : { orderBy?: RPEEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RPEEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRPEEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RPEEntry model
   */
  readonly fields: RPEEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RPEEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RPEEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RPEEntry model
   */ 
  interface RPEEntryFieldRefs {
    readonly id: FieldRef<"RPEEntry", 'String'>
    readonly userId: FieldRef<"RPEEntry", 'String'>
    readonly date: FieldRef<"RPEEntry", 'DateTime'>
    readonly session: FieldRef<"RPEEntry", 'Int'>
    readonly sessionLabel: FieldRef<"RPEEntry", 'String'>
    readonly sessionUid: FieldRef<"RPEEntry", 'String'>
    readonly rpe: FieldRef<"RPEEntry", 'Int'>
    readonly duration: FieldRef<"RPEEntry", 'Int'>
    readonly load: FieldRef<"RPEEntry", 'Int'>
    readonly createdAt: FieldRef<"RPEEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"RPEEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RPEEntry findUnique
   */
  export type RPEEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPEEntry
     */
    select?: RPEEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPEEntryInclude<ExtArgs> | null
    /**
     * Filter, which RPEEntry to fetch.
     */
    where: RPEEntryWhereUniqueInput
  }

  /**
   * RPEEntry findUniqueOrThrow
   */
  export type RPEEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPEEntry
     */
    select?: RPEEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPEEntryInclude<ExtArgs> | null
    /**
     * Filter, which RPEEntry to fetch.
     */
    where: RPEEntryWhereUniqueInput
  }

  /**
   * RPEEntry findFirst
   */
  export type RPEEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPEEntry
     */
    select?: RPEEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPEEntryInclude<ExtArgs> | null
    /**
     * Filter, which RPEEntry to fetch.
     */
    where?: RPEEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RPEEntries to fetch.
     */
    orderBy?: RPEEntryOrderByWithRelationInput | RPEEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RPEEntries.
     */
    cursor?: RPEEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RPEEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RPEEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RPEEntries.
     */
    distinct?: RPEEntryScalarFieldEnum | RPEEntryScalarFieldEnum[]
  }

  /**
   * RPEEntry findFirstOrThrow
   */
  export type RPEEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPEEntry
     */
    select?: RPEEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPEEntryInclude<ExtArgs> | null
    /**
     * Filter, which RPEEntry to fetch.
     */
    where?: RPEEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RPEEntries to fetch.
     */
    orderBy?: RPEEntryOrderByWithRelationInput | RPEEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RPEEntries.
     */
    cursor?: RPEEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RPEEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RPEEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RPEEntries.
     */
    distinct?: RPEEntryScalarFieldEnum | RPEEntryScalarFieldEnum[]
  }

  /**
   * RPEEntry findMany
   */
  export type RPEEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPEEntry
     */
    select?: RPEEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPEEntryInclude<ExtArgs> | null
    /**
     * Filter, which RPEEntries to fetch.
     */
    where?: RPEEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RPEEntries to fetch.
     */
    orderBy?: RPEEntryOrderByWithRelationInput | RPEEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RPEEntries.
     */
    cursor?: RPEEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RPEEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RPEEntries.
     */
    skip?: number
    distinct?: RPEEntryScalarFieldEnum | RPEEntryScalarFieldEnum[]
  }

  /**
   * RPEEntry create
   */
  export type RPEEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPEEntry
     */
    select?: RPEEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPEEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a RPEEntry.
     */
    data: XOR<RPEEntryCreateInput, RPEEntryUncheckedCreateInput>
  }

  /**
   * RPEEntry createMany
   */
  export type RPEEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RPEEntries.
     */
    data: RPEEntryCreateManyInput | RPEEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RPEEntry createManyAndReturn
   */
  export type RPEEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPEEntry
     */
    select?: RPEEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RPEEntries.
     */
    data: RPEEntryCreateManyInput | RPEEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPEEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RPEEntry update
   */
  export type RPEEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPEEntry
     */
    select?: RPEEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPEEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a RPEEntry.
     */
    data: XOR<RPEEntryUpdateInput, RPEEntryUncheckedUpdateInput>
    /**
     * Choose, which RPEEntry to update.
     */
    where: RPEEntryWhereUniqueInput
  }

  /**
   * RPEEntry updateMany
   */
  export type RPEEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RPEEntries.
     */
    data: XOR<RPEEntryUpdateManyMutationInput, RPEEntryUncheckedUpdateManyInput>
    /**
     * Filter which RPEEntries to update
     */
    where?: RPEEntryWhereInput
  }

  /**
   * RPEEntry upsert
   */
  export type RPEEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPEEntry
     */
    select?: RPEEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPEEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the RPEEntry to update in case it exists.
     */
    where: RPEEntryWhereUniqueInput
    /**
     * In case the RPEEntry found by the `where` argument doesn't exist, create a new RPEEntry with this data.
     */
    create: XOR<RPEEntryCreateInput, RPEEntryUncheckedCreateInput>
    /**
     * In case the RPEEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RPEEntryUpdateInput, RPEEntryUncheckedUpdateInput>
  }

  /**
   * RPEEntry delete
   */
  export type RPEEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPEEntry
     */
    select?: RPEEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPEEntryInclude<ExtArgs> | null
    /**
     * Filter which RPEEntry to delete.
     */
    where: RPEEntryWhereUniqueInput
  }

  /**
   * RPEEntry deleteMany
   */
  export type RPEEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RPEEntries to delete
     */
    where?: RPEEntryWhereInput
  }

  /**
   * RPEEntry without action
   */
  export type RPEEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPEEntry
     */
    select?: RPEEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPEEntryInclude<ExtArgs> | null
  }


  /**
   * Model WellnessEntry
   */

  export type AggregateWellnessEntry = {
    _count: WellnessEntryCountAggregateOutputType | null
    _avg: WellnessEntryAvgAggregateOutputType | null
    _sum: WellnessEntrySumAggregateOutputType | null
    _min: WellnessEntryMinAggregateOutputType | null
    _max: WellnessEntryMaxAggregateOutputType | null
  }

  export type WellnessEntryAvgAggregateOutputType = {
    sleepQuality: number | null
    sleepHours: number | null
    fatigue: number | null
    muscleSoreness: number | null
    stress: number | null
    mood: number | null
    total: number | null
  }

  export type WellnessEntrySumAggregateOutputType = {
    sleepQuality: number | null
    sleepHours: number | null
    fatigue: number | null
    muscleSoreness: number | null
    stress: number | null
    mood: number | null
    total: number | null
  }

  export type WellnessEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    sleepQuality: number | null
    sleepHours: number | null
    fatigue: number | null
    muscleSoreness: number | null
    stress: number | null
    mood: number | null
    comment: string | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WellnessEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    sleepQuality: number | null
    sleepHours: number | null
    fatigue: number | null
    muscleSoreness: number | null
    stress: number | null
    mood: number | null
    comment: string | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WellnessEntryCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    sleepQuality: number
    sleepHours: number
    fatigue: number
    muscleSoreness: number
    stress: number
    mood: number
    comment: number
    total: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WellnessEntryAvgAggregateInputType = {
    sleepQuality?: true
    sleepHours?: true
    fatigue?: true
    muscleSoreness?: true
    stress?: true
    mood?: true
    total?: true
  }

  export type WellnessEntrySumAggregateInputType = {
    sleepQuality?: true
    sleepHours?: true
    fatigue?: true
    muscleSoreness?: true
    stress?: true
    mood?: true
    total?: true
  }

  export type WellnessEntryMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    sleepQuality?: true
    sleepHours?: true
    fatigue?: true
    muscleSoreness?: true
    stress?: true
    mood?: true
    comment?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WellnessEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    sleepQuality?: true
    sleepHours?: true
    fatigue?: true
    muscleSoreness?: true
    stress?: true
    mood?: true
    comment?: true
    total?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WellnessEntryCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    sleepQuality?: true
    sleepHours?: true
    fatigue?: true
    muscleSoreness?: true
    stress?: true
    mood?: true
    comment?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WellnessEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WellnessEntry to aggregate.
     */
    where?: WellnessEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellnessEntries to fetch.
     */
    orderBy?: WellnessEntryOrderByWithRelationInput | WellnessEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WellnessEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellnessEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellnessEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WellnessEntries
    **/
    _count?: true | WellnessEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WellnessEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WellnessEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WellnessEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WellnessEntryMaxAggregateInputType
  }

  export type GetWellnessEntryAggregateType<T extends WellnessEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateWellnessEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWellnessEntry[P]>
      : GetScalarType<T[P], AggregateWellnessEntry[P]>
  }




  export type WellnessEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WellnessEntryWhereInput
    orderBy?: WellnessEntryOrderByWithAggregationInput | WellnessEntryOrderByWithAggregationInput[]
    by: WellnessEntryScalarFieldEnum[] | WellnessEntryScalarFieldEnum
    having?: WellnessEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WellnessEntryCountAggregateInputType | true
    _avg?: WellnessEntryAvgAggregateInputType
    _sum?: WellnessEntrySumAggregateInputType
    _min?: WellnessEntryMinAggregateInputType
    _max?: WellnessEntryMaxAggregateInputType
  }

  export type WellnessEntryGroupByOutputType = {
    id: string
    userId: string
    date: Date
    sleepQuality: number
    sleepHours: number | null
    fatigue: number
    muscleSoreness: number
    stress: number
    mood: number
    comment: string | null
    total: number | null
    createdAt: Date
    updatedAt: Date
    _count: WellnessEntryCountAggregateOutputType | null
    _avg: WellnessEntryAvgAggregateOutputType | null
    _sum: WellnessEntrySumAggregateOutputType | null
    _min: WellnessEntryMinAggregateOutputType | null
    _max: WellnessEntryMaxAggregateOutputType | null
  }

  type GetWellnessEntryGroupByPayload<T extends WellnessEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WellnessEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WellnessEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WellnessEntryGroupByOutputType[P]>
            : GetScalarType<T[P], WellnessEntryGroupByOutputType[P]>
        }
      >
    >


  export type WellnessEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    sleepQuality?: boolean
    sleepHours?: boolean
    fatigue?: boolean
    muscleSoreness?: boolean
    stress?: boolean
    mood?: boolean
    comment?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wellnessEntry"]>

  export type WellnessEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    sleepQuality?: boolean
    sleepHours?: boolean
    fatigue?: boolean
    muscleSoreness?: boolean
    stress?: boolean
    mood?: boolean
    comment?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wellnessEntry"]>

  export type WellnessEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    sleepQuality?: boolean
    sleepHours?: boolean
    fatigue?: boolean
    muscleSoreness?: boolean
    stress?: boolean
    mood?: boolean
    comment?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WellnessEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WellnessEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WellnessEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WellnessEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      sleepQuality: number
      sleepHours: number | null
      fatigue: number
      muscleSoreness: number
      stress: number
      mood: number
      comment: string | null
      total: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wellnessEntry"]>
    composites: {}
  }

  type WellnessEntryGetPayload<S extends boolean | null | undefined | WellnessEntryDefaultArgs> = $Result.GetResult<Prisma.$WellnessEntryPayload, S>

  type WellnessEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WellnessEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WellnessEntryCountAggregateInputType | true
    }

  export interface WellnessEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WellnessEntry'], meta: { name: 'WellnessEntry' } }
    /**
     * Find zero or one WellnessEntry that matches the filter.
     * @param {WellnessEntryFindUniqueArgs} args - Arguments to find a WellnessEntry
     * @example
     * // Get one WellnessEntry
     * const wellnessEntry = await prisma.wellnessEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WellnessEntryFindUniqueArgs>(args: SelectSubset<T, WellnessEntryFindUniqueArgs<ExtArgs>>): Prisma__WellnessEntryClient<$Result.GetResult<Prisma.$WellnessEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WellnessEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WellnessEntryFindUniqueOrThrowArgs} args - Arguments to find a WellnessEntry
     * @example
     * // Get one WellnessEntry
     * const wellnessEntry = await prisma.wellnessEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WellnessEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, WellnessEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WellnessEntryClient<$Result.GetResult<Prisma.$WellnessEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WellnessEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessEntryFindFirstArgs} args - Arguments to find a WellnessEntry
     * @example
     * // Get one WellnessEntry
     * const wellnessEntry = await prisma.wellnessEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WellnessEntryFindFirstArgs>(args?: SelectSubset<T, WellnessEntryFindFirstArgs<ExtArgs>>): Prisma__WellnessEntryClient<$Result.GetResult<Prisma.$WellnessEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WellnessEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessEntryFindFirstOrThrowArgs} args - Arguments to find a WellnessEntry
     * @example
     * // Get one WellnessEntry
     * const wellnessEntry = await prisma.wellnessEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WellnessEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, WellnessEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__WellnessEntryClient<$Result.GetResult<Prisma.$WellnessEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WellnessEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WellnessEntries
     * const wellnessEntries = await prisma.wellnessEntry.findMany()
     * 
     * // Get first 10 WellnessEntries
     * const wellnessEntries = await prisma.wellnessEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wellnessEntryWithIdOnly = await prisma.wellnessEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WellnessEntryFindManyArgs>(args?: SelectSubset<T, WellnessEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellnessEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WellnessEntry.
     * @param {WellnessEntryCreateArgs} args - Arguments to create a WellnessEntry.
     * @example
     * // Create one WellnessEntry
     * const WellnessEntry = await prisma.wellnessEntry.create({
     *   data: {
     *     // ... data to create a WellnessEntry
     *   }
     * })
     * 
     */
    create<T extends WellnessEntryCreateArgs>(args: SelectSubset<T, WellnessEntryCreateArgs<ExtArgs>>): Prisma__WellnessEntryClient<$Result.GetResult<Prisma.$WellnessEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WellnessEntries.
     * @param {WellnessEntryCreateManyArgs} args - Arguments to create many WellnessEntries.
     * @example
     * // Create many WellnessEntries
     * const wellnessEntry = await prisma.wellnessEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WellnessEntryCreateManyArgs>(args?: SelectSubset<T, WellnessEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WellnessEntries and returns the data saved in the database.
     * @param {WellnessEntryCreateManyAndReturnArgs} args - Arguments to create many WellnessEntries.
     * @example
     * // Create many WellnessEntries
     * const wellnessEntry = await prisma.wellnessEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WellnessEntries and only return the `id`
     * const wellnessEntryWithIdOnly = await prisma.wellnessEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WellnessEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, WellnessEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WellnessEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WellnessEntry.
     * @param {WellnessEntryDeleteArgs} args - Arguments to delete one WellnessEntry.
     * @example
     * // Delete one WellnessEntry
     * const WellnessEntry = await prisma.wellnessEntry.delete({
     *   where: {
     *     // ... filter to delete one WellnessEntry
     *   }
     * })
     * 
     */
    delete<T extends WellnessEntryDeleteArgs>(args: SelectSubset<T, WellnessEntryDeleteArgs<ExtArgs>>): Prisma__WellnessEntryClient<$Result.GetResult<Prisma.$WellnessEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WellnessEntry.
     * @param {WellnessEntryUpdateArgs} args - Arguments to update one WellnessEntry.
     * @example
     * // Update one WellnessEntry
     * const wellnessEntry = await prisma.wellnessEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WellnessEntryUpdateArgs>(args: SelectSubset<T, WellnessEntryUpdateArgs<ExtArgs>>): Prisma__WellnessEntryClient<$Result.GetResult<Prisma.$WellnessEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WellnessEntries.
     * @param {WellnessEntryDeleteManyArgs} args - Arguments to filter WellnessEntries to delete.
     * @example
     * // Delete a few WellnessEntries
     * const { count } = await prisma.wellnessEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WellnessEntryDeleteManyArgs>(args?: SelectSubset<T, WellnessEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WellnessEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WellnessEntries
     * const wellnessEntry = await prisma.wellnessEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WellnessEntryUpdateManyArgs>(args: SelectSubset<T, WellnessEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WellnessEntry.
     * @param {WellnessEntryUpsertArgs} args - Arguments to update or create a WellnessEntry.
     * @example
     * // Update or create a WellnessEntry
     * const wellnessEntry = await prisma.wellnessEntry.upsert({
     *   create: {
     *     // ... data to create a WellnessEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WellnessEntry we want to update
     *   }
     * })
     */
    upsert<T extends WellnessEntryUpsertArgs>(args: SelectSubset<T, WellnessEntryUpsertArgs<ExtArgs>>): Prisma__WellnessEntryClient<$Result.GetResult<Prisma.$WellnessEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WellnessEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessEntryCountArgs} args - Arguments to filter WellnessEntries to count.
     * @example
     * // Count the number of WellnessEntries
     * const count = await prisma.wellnessEntry.count({
     *   where: {
     *     // ... the filter for the WellnessEntries we want to count
     *   }
     * })
    **/
    count<T extends WellnessEntryCountArgs>(
      args?: Subset<T, WellnessEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WellnessEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WellnessEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WellnessEntryAggregateArgs>(args: Subset<T, WellnessEntryAggregateArgs>): Prisma.PrismaPromise<GetWellnessEntryAggregateType<T>>

    /**
     * Group by WellnessEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WellnessEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WellnessEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WellnessEntryGroupByArgs['orderBy'] }
        : { orderBy?: WellnessEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WellnessEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWellnessEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WellnessEntry model
   */
  readonly fields: WellnessEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WellnessEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WellnessEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WellnessEntry model
   */ 
  interface WellnessEntryFieldRefs {
    readonly id: FieldRef<"WellnessEntry", 'String'>
    readonly userId: FieldRef<"WellnessEntry", 'String'>
    readonly date: FieldRef<"WellnessEntry", 'DateTime'>
    readonly sleepQuality: FieldRef<"WellnessEntry", 'Int'>
    readonly sleepHours: FieldRef<"WellnessEntry", 'Float'>
    readonly fatigue: FieldRef<"WellnessEntry", 'Int'>
    readonly muscleSoreness: FieldRef<"WellnessEntry", 'Int'>
    readonly stress: FieldRef<"WellnessEntry", 'Int'>
    readonly mood: FieldRef<"WellnessEntry", 'Int'>
    readonly comment: FieldRef<"WellnessEntry", 'String'>
    readonly total: FieldRef<"WellnessEntry", 'Int'>
    readonly createdAt: FieldRef<"WellnessEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"WellnessEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WellnessEntry findUnique
   */
  export type WellnessEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessEntry
     */
    select?: WellnessEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessEntryInclude<ExtArgs> | null
    /**
     * Filter, which WellnessEntry to fetch.
     */
    where: WellnessEntryWhereUniqueInput
  }

  /**
   * WellnessEntry findUniqueOrThrow
   */
  export type WellnessEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessEntry
     */
    select?: WellnessEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessEntryInclude<ExtArgs> | null
    /**
     * Filter, which WellnessEntry to fetch.
     */
    where: WellnessEntryWhereUniqueInput
  }

  /**
   * WellnessEntry findFirst
   */
  export type WellnessEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessEntry
     */
    select?: WellnessEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessEntryInclude<ExtArgs> | null
    /**
     * Filter, which WellnessEntry to fetch.
     */
    where?: WellnessEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellnessEntries to fetch.
     */
    orderBy?: WellnessEntryOrderByWithRelationInput | WellnessEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WellnessEntries.
     */
    cursor?: WellnessEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellnessEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellnessEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WellnessEntries.
     */
    distinct?: WellnessEntryScalarFieldEnum | WellnessEntryScalarFieldEnum[]
  }

  /**
   * WellnessEntry findFirstOrThrow
   */
  export type WellnessEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessEntry
     */
    select?: WellnessEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessEntryInclude<ExtArgs> | null
    /**
     * Filter, which WellnessEntry to fetch.
     */
    where?: WellnessEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellnessEntries to fetch.
     */
    orderBy?: WellnessEntryOrderByWithRelationInput | WellnessEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WellnessEntries.
     */
    cursor?: WellnessEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellnessEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellnessEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WellnessEntries.
     */
    distinct?: WellnessEntryScalarFieldEnum | WellnessEntryScalarFieldEnum[]
  }

  /**
   * WellnessEntry findMany
   */
  export type WellnessEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessEntry
     */
    select?: WellnessEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessEntryInclude<ExtArgs> | null
    /**
     * Filter, which WellnessEntries to fetch.
     */
    where?: WellnessEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WellnessEntries to fetch.
     */
    orderBy?: WellnessEntryOrderByWithRelationInput | WellnessEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WellnessEntries.
     */
    cursor?: WellnessEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WellnessEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WellnessEntries.
     */
    skip?: number
    distinct?: WellnessEntryScalarFieldEnum | WellnessEntryScalarFieldEnum[]
  }

  /**
   * WellnessEntry create
   */
  export type WellnessEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessEntry
     */
    select?: WellnessEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a WellnessEntry.
     */
    data: XOR<WellnessEntryCreateInput, WellnessEntryUncheckedCreateInput>
  }

  /**
   * WellnessEntry createMany
   */
  export type WellnessEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WellnessEntries.
     */
    data: WellnessEntryCreateManyInput | WellnessEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WellnessEntry createManyAndReturn
   */
  export type WellnessEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessEntry
     */
    select?: WellnessEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WellnessEntries.
     */
    data: WellnessEntryCreateManyInput | WellnessEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WellnessEntry update
   */
  export type WellnessEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessEntry
     */
    select?: WellnessEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a WellnessEntry.
     */
    data: XOR<WellnessEntryUpdateInput, WellnessEntryUncheckedUpdateInput>
    /**
     * Choose, which WellnessEntry to update.
     */
    where: WellnessEntryWhereUniqueInput
  }

  /**
   * WellnessEntry updateMany
   */
  export type WellnessEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WellnessEntries.
     */
    data: XOR<WellnessEntryUpdateManyMutationInput, WellnessEntryUncheckedUpdateManyInput>
    /**
     * Filter which WellnessEntries to update
     */
    where?: WellnessEntryWhereInput
  }

  /**
   * WellnessEntry upsert
   */
  export type WellnessEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessEntry
     */
    select?: WellnessEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the WellnessEntry to update in case it exists.
     */
    where: WellnessEntryWhereUniqueInput
    /**
     * In case the WellnessEntry found by the `where` argument doesn't exist, create a new WellnessEntry with this data.
     */
    create: XOR<WellnessEntryCreateInput, WellnessEntryUncheckedCreateInput>
    /**
     * In case the WellnessEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WellnessEntryUpdateInput, WellnessEntryUncheckedUpdateInput>
  }

  /**
   * WellnessEntry delete
   */
  export type WellnessEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessEntry
     */
    select?: WellnessEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessEntryInclude<ExtArgs> | null
    /**
     * Filter which WellnessEntry to delete.
     */
    where: WellnessEntryWhereUniqueInput
  }

  /**
   * WellnessEntry deleteMany
   */
  export type WellnessEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WellnessEntries to delete
     */
    where?: WellnessEntryWhereInput
  }

  /**
   * WellnessEntry without action
   */
  export type WellnessEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WellnessEntry
     */
    select?: WellnessEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WellnessEntryInclude<ExtArgs> | null
  }


  /**
   * Model PlannerPrefs
   */

  export type AggregatePlannerPrefs = {
    _count: PlannerPrefsCountAggregateOutputType | null
    _min: PlannerPrefsMinAggregateOutputType | null
    _max: PlannerPrefsMaxAggregateOutputType | null
  }

  export type PlannerPrefsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    teamId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlannerPrefsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    teamId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlannerPrefsCountAggregateOutputType = {
    id: number
    userId: number
    teamId: number
    rowLabels: number
    places: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlannerPrefsMinAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlannerPrefsMaxAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlannerPrefsCountAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    rowLabels?: true
    places?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlannerPrefsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlannerPrefs to aggregate.
     */
    where?: PlannerPrefsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlannerPrefs to fetch.
     */
    orderBy?: PlannerPrefsOrderByWithRelationInput | PlannerPrefsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlannerPrefsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlannerPrefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlannerPrefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlannerPrefs
    **/
    _count?: true | PlannerPrefsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlannerPrefsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlannerPrefsMaxAggregateInputType
  }

  export type GetPlannerPrefsAggregateType<T extends PlannerPrefsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlannerPrefs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlannerPrefs[P]>
      : GetScalarType<T[P], AggregatePlannerPrefs[P]>
  }




  export type PlannerPrefsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlannerPrefsWhereInput
    orderBy?: PlannerPrefsOrderByWithAggregationInput | PlannerPrefsOrderByWithAggregationInput[]
    by: PlannerPrefsScalarFieldEnum[] | PlannerPrefsScalarFieldEnum
    having?: PlannerPrefsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlannerPrefsCountAggregateInputType | true
    _min?: PlannerPrefsMinAggregateInputType
    _max?: PlannerPrefsMaxAggregateInputType
  }

  export type PlannerPrefsGroupByOutputType = {
    id: string
    userId: string
    teamId: string
    rowLabels: JsonValue
    places: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PlannerPrefsCountAggregateOutputType | null
    _min: PlannerPrefsMinAggregateOutputType | null
    _max: PlannerPrefsMaxAggregateOutputType | null
  }

  type GetPlannerPrefsGroupByPayload<T extends PlannerPrefsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlannerPrefsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlannerPrefsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlannerPrefsGroupByOutputType[P]>
            : GetScalarType<T[P], PlannerPrefsGroupByOutputType[P]>
        }
      >
    >


  export type PlannerPrefsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    teamId?: boolean
    rowLabels?: boolean
    places?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plannerPrefs"]>

  export type PlannerPrefsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    teamId?: boolean
    rowLabels?: boolean
    places?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plannerPrefs"]>

  export type PlannerPrefsSelectScalar = {
    id?: boolean
    userId?: boolean
    teamId?: boolean
    rowLabels?: boolean
    places?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlannerPrefsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type PlannerPrefsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $PlannerPrefsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlannerPrefs"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      teamId: string
      rowLabels: Prisma.JsonValue
      places: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["plannerPrefs"]>
    composites: {}
  }

  type PlannerPrefsGetPayload<S extends boolean | null | undefined | PlannerPrefsDefaultArgs> = $Result.GetResult<Prisma.$PlannerPrefsPayload, S>

  type PlannerPrefsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlannerPrefsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlannerPrefsCountAggregateInputType | true
    }

  export interface PlannerPrefsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlannerPrefs'], meta: { name: 'PlannerPrefs' } }
    /**
     * Find zero or one PlannerPrefs that matches the filter.
     * @param {PlannerPrefsFindUniqueArgs} args - Arguments to find a PlannerPrefs
     * @example
     * // Get one PlannerPrefs
     * const plannerPrefs = await prisma.plannerPrefs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlannerPrefsFindUniqueArgs>(args: SelectSubset<T, PlannerPrefsFindUniqueArgs<ExtArgs>>): Prisma__PlannerPrefsClient<$Result.GetResult<Prisma.$PlannerPrefsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlannerPrefs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlannerPrefsFindUniqueOrThrowArgs} args - Arguments to find a PlannerPrefs
     * @example
     * // Get one PlannerPrefs
     * const plannerPrefs = await prisma.plannerPrefs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlannerPrefsFindUniqueOrThrowArgs>(args: SelectSubset<T, PlannerPrefsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlannerPrefsClient<$Result.GetResult<Prisma.$PlannerPrefsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlannerPrefs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannerPrefsFindFirstArgs} args - Arguments to find a PlannerPrefs
     * @example
     * // Get one PlannerPrefs
     * const plannerPrefs = await prisma.plannerPrefs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlannerPrefsFindFirstArgs>(args?: SelectSubset<T, PlannerPrefsFindFirstArgs<ExtArgs>>): Prisma__PlannerPrefsClient<$Result.GetResult<Prisma.$PlannerPrefsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlannerPrefs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannerPrefsFindFirstOrThrowArgs} args - Arguments to find a PlannerPrefs
     * @example
     * // Get one PlannerPrefs
     * const plannerPrefs = await prisma.plannerPrefs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlannerPrefsFindFirstOrThrowArgs>(args?: SelectSubset<T, PlannerPrefsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlannerPrefsClient<$Result.GetResult<Prisma.$PlannerPrefsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlannerPrefs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannerPrefsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlannerPrefs
     * const plannerPrefs = await prisma.plannerPrefs.findMany()
     * 
     * // Get first 10 PlannerPrefs
     * const plannerPrefs = await prisma.plannerPrefs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plannerPrefsWithIdOnly = await prisma.plannerPrefs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlannerPrefsFindManyArgs>(args?: SelectSubset<T, PlannerPrefsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlannerPrefsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlannerPrefs.
     * @param {PlannerPrefsCreateArgs} args - Arguments to create a PlannerPrefs.
     * @example
     * // Create one PlannerPrefs
     * const PlannerPrefs = await prisma.plannerPrefs.create({
     *   data: {
     *     // ... data to create a PlannerPrefs
     *   }
     * })
     * 
     */
    create<T extends PlannerPrefsCreateArgs>(args: SelectSubset<T, PlannerPrefsCreateArgs<ExtArgs>>): Prisma__PlannerPrefsClient<$Result.GetResult<Prisma.$PlannerPrefsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlannerPrefs.
     * @param {PlannerPrefsCreateManyArgs} args - Arguments to create many PlannerPrefs.
     * @example
     * // Create many PlannerPrefs
     * const plannerPrefs = await prisma.plannerPrefs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlannerPrefsCreateManyArgs>(args?: SelectSubset<T, PlannerPrefsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlannerPrefs and returns the data saved in the database.
     * @param {PlannerPrefsCreateManyAndReturnArgs} args - Arguments to create many PlannerPrefs.
     * @example
     * // Create many PlannerPrefs
     * const plannerPrefs = await prisma.plannerPrefs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlannerPrefs and only return the `id`
     * const plannerPrefsWithIdOnly = await prisma.plannerPrefs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlannerPrefsCreateManyAndReturnArgs>(args?: SelectSubset<T, PlannerPrefsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlannerPrefsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlannerPrefs.
     * @param {PlannerPrefsDeleteArgs} args - Arguments to delete one PlannerPrefs.
     * @example
     * // Delete one PlannerPrefs
     * const PlannerPrefs = await prisma.plannerPrefs.delete({
     *   where: {
     *     // ... filter to delete one PlannerPrefs
     *   }
     * })
     * 
     */
    delete<T extends PlannerPrefsDeleteArgs>(args: SelectSubset<T, PlannerPrefsDeleteArgs<ExtArgs>>): Prisma__PlannerPrefsClient<$Result.GetResult<Prisma.$PlannerPrefsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlannerPrefs.
     * @param {PlannerPrefsUpdateArgs} args - Arguments to update one PlannerPrefs.
     * @example
     * // Update one PlannerPrefs
     * const plannerPrefs = await prisma.plannerPrefs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlannerPrefsUpdateArgs>(args: SelectSubset<T, PlannerPrefsUpdateArgs<ExtArgs>>): Prisma__PlannerPrefsClient<$Result.GetResult<Prisma.$PlannerPrefsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlannerPrefs.
     * @param {PlannerPrefsDeleteManyArgs} args - Arguments to filter PlannerPrefs to delete.
     * @example
     * // Delete a few PlannerPrefs
     * const { count } = await prisma.plannerPrefs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlannerPrefsDeleteManyArgs>(args?: SelectSubset<T, PlannerPrefsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlannerPrefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannerPrefsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlannerPrefs
     * const plannerPrefs = await prisma.plannerPrefs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlannerPrefsUpdateManyArgs>(args: SelectSubset<T, PlannerPrefsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlannerPrefs.
     * @param {PlannerPrefsUpsertArgs} args - Arguments to update or create a PlannerPrefs.
     * @example
     * // Update or create a PlannerPrefs
     * const plannerPrefs = await prisma.plannerPrefs.upsert({
     *   create: {
     *     // ... data to create a PlannerPrefs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlannerPrefs we want to update
     *   }
     * })
     */
    upsert<T extends PlannerPrefsUpsertArgs>(args: SelectSubset<T, PlannerPrefsUpsertArgs<ExtArgs>>): Prisma__PlannerPrefsClient<$Result.GetResult<Prisma.$PlannerPrefsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlannerPrefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannerPrefsCountArgs} args - Arguments to filter PlannerPrefs to count.
     * @example
     * // Count the number of PlannerPrefs
     * const count = await prisma.plannerPrefs.count({
     *   where: {
     *     // ... the filter for the PlannerPrefs we want to count
     *   }
     * })
    **/
    count<T extends PlannerPrefsCountArgs>(
      args?: Subset<T, PlannerPrefsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlannerPrefsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlannerPrefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannerPrefsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlannerPrefsAggregateArgs>(args: Subset<T, PlannerPrefsAggregateArgs>): Prisma.PrismaPromise<GetPlannerPrefsAggregateType<T>>

    /**
     * Group by PlannerPrefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannerPrefsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlannerPrefsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlannerPrefsGroupByArgs['orderBy'] }
        : { orderBy?: PlannerPrefsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlannerPrefsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlannerPrefsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlannerPrefs model
   */
  readonly fields: PlannerPrefsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlannerPrefs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlannerPrefsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlannerPrefs model
   */ 
  interface PlannerPrefsFieldRefs {
    readonly id: FieldRef<"PlannerPrefs", 'String'>
    readonly userId: FieldRef<"PlannerPrefs", 'String'>
    readonly teamId: FieldRef<"PlannerPrefs", 'String'>
    readonly rowLabels: FieldRef<"PlannerPrefs", 'Json'>
    readonly places: FieldRef<"PlannerPrefs", 'Json'>
    readonly createdAt: FieldRef<"PlannerPrefs", 'DateTime'>
    readonly updatedAt: FieldRef<"PlannerPrefs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlannerPrefs findUnique
   */
  export type PlannerPrefsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerPrefs
     */
    select?: PlannerPrefsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerPrefsInclude<ExtArgs> | null
    /**
     * Filter, which PlannerPrefs to fetch.
     */
    where: PlannerPrefsWhereUniqueInput
  }

  /**
   * PlannerPrefs findUniqueOrThrow
   */
  export type PlannerPrefsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerPrefs
     */
    select?: PlannerPrefsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerPrefsInclude<ExtArgs> | null
    /**
     * Filter, which PlannerPrefs to fetch.
     */
    where: PlannerPrefsWhereUniqueInput
  }

  /**
   * PlannerPrefs findFirst
   */
  export type PlannerPrefsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerPrefs
     */
    select?: PlannerPrefsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerPrefsInclude<ExtArgs> | null
    /**
     * Filter, which PlannerPrefs to fetch.
     */
    where?: PlannerPrefsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlannerPrefs to fetch.
     */
    orderBy?: PlannerPrefsOrderByWithRelationInput | PlannerPrefsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlannerPrefs.
     */
    cursor?: PlannerPrefsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlannerPrefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlannerPrefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlannerPrefs.
     */
    distinct?: PlannerPrefsScalarFieldEnum | PlannerPrefsScalarFieldEnum[]
  }

  /**
   * PlannerPrefs findFirstOrThrow
   */
  export type PlannerPrefsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerPrefs
     */
    select?: PlannerPrefsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerPrefsInclude<ExtArgs> | null
    /**
     * Filter, which PlannerPrefs to fetch.
     */
    where?: PlannerPrefsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlannerPrefs to fetch.
     */
    orderBy?: PlannerPrefsOrderByWithRelationInput | PlannerPrefsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlannerPrefs.
     */
    cursor?: PlannerPrefsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlannerPrefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlannerPrefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlannerPrefs.
     */
    distinct?: PlannerPrefsScalarFieldEnum | PlannerPrefsScalarFieldEnum[]
  }

  /**
   * PlannerPrefs findMany
   */
  export type PlannerPrefsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerPrefs
     */
    select?: PlannerPrefsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerPrefsInclude<ExtArgs> | null
    /**
     * Filter, which PlannerPrefs to fetch.
     */
    where?: PlannerPrefsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlannerPrefs to fetch.
     */
    orderBy?: PlannerPrefsOrderByWithRelationInput | PlannerPrefsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlannerPrefs.
     */
    cursor?: PlannerPrefsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlannerPrefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlannerPrefs.
     */
    skip?: number
    distinct?: PlannerPrefsScalarFieldEnum | PlannerPrefsScalarFieldEnum[]
  }

  /**
   * PlannerPrefs create
   */
  export type PlannerPrefsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerPrefs
     */
    select?: PlannerPrefsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerPrefsInclude<ExtArgs> | null
    /**
     * The data needed to create a PlannerPrefs.
     */
    data: XOR<PlannerPrefsCreateInput, PlannerPrefsUncheckedCreateInput>
  }

  /**
   * PlannerPrefs createMany
   */
  export type PlannerPrefsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlannerPrefs.
     */
    data: PlannerPrefsCreateManyInput | PlannerPrefsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlannerPrefs createManyAndReturn
   */
  export type PlannerPrefsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerPrefs
     */
    select?: PlannerPrefsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlannerPrefs.
     */
    data: PlannerPrefsCreateManyInput | PlannerPrefsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerPrefsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlannerPrefs update
   */
  export type PlannerPrefsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerPrefs
     */
    select?: PlannerPrefsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerPrefsInclude<ExtArgs> | null
    /**
     * The data needed to update a PlannerPrefs.
     */
    data: XOR<PlannerPrefsUpdateInput, PlannerPrefsUncheckedUpdateInput>
    /**
     * Choose, which PlannerPrefs to update.
     */
    where: PlannerPrefsWhereUniqueInput
  }

  /**
   * PlannerPrefs updateMany
   */
  export type PlannerPrefsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlannerPrefs.
     */
    data: XOR<PlannerPrefsUpdateManyMutationInput, PlannerPrefsUncheckedUpdateManyInput>
    /**
     * Filter which PlannerPrefs to update
     */
    where?: PlannerPrefsWhereInput
  }

  /**
   * PlannerPrefs upsert
   */
  export type PlannerPrefsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerPrefs
     */
    select?: PlannerPrefsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerPrefsInclude<ExtArgs> | null
    /**
     * The filter to search for the PlannerPrefs to update in case it exists.
     */
    where: PlannerPrefsWhereUniqueInput
    /**
     * In case the PlannerPrefs found by the `where` argument doesn't exist, create a new PlannerPrefs with this data.
     */
    create: XOR<PlannerPrefsCreateInput, PlannerPrefsUncheckedCreateInput>
    /**
     * In case the PlannerPrefs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlannerPrefsUpdateInput, PlannerPrefsUncheckedUpdateInput>
  }

  /**
   * PlannerPrefs delete
   */
  export type PlannerPrefsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerPrefs
     */
    select?: PlannerPrefsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerPrefsInclude<ExtArgs> | null
    /**
     * Filter which PlannerPrefs to delete.
     */
    where: PlannerPrefsWhereUniqueInput
  }

  /**
   * PlannerPrefs deleteMany
   */
  export type PlannerPrefsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlannerPrefs to delete
     */
    where?: PlannerPrefsWhereInput
  }

  /**
   * PlannerPrefs without action
   */
  export type PlannerPrefsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerPrefs
     */
    select?: PlannerPrefsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerPrefsInclude<ExtArgs> | null
  }


  /**
   * Model ClinicalEntry
   */

  export type AggregateClinicalEntry = {
    _count: ClinicalEntryCountAggregateOutputType | null
    _avg: ClinicalEntryAvgAggregateOutputType | null
    _sum: ClinicalEntrySumAggregateOutputType | null
    _min: ClinicalEntryMinAggregateOutputType | null
    _max: ClinicalEntryMaxAggregateOutputType | null
  }

  export type ClinicalEntryAvgAggregateOutputType = {
    illIsolationDays: number | null
    feverMax: number | null
    daysPlanned: number | null
    capMinutes: number | null
  }

  export type ClinicalEntrySumAggregateOutputType = {
    illIsolationDays: number | null
    feverMax: number | null
    daysPlanned: number | null
    capMinutes: number | null
  }

  export type ClinicalEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    status: $Enums.ClinicalStatus | null
    leaveStage: $Enums.LeaveStage | null
    leaveKind: $Enums.LeaveKind | null
    diagnosis: string | null
    bodyPart: string | null
    laterality: $Enums.Laterality | null
    mechanism: $Enums.Mechanism | null
    severity: $Enums.Severity | null
    illSystem: $Enums.SystemAffected | null
    illSymptoms: string | null
    illContagious: boolean | null
    illIsolationDays: number | null
    illAptitude: $Enums.IllAptitude | null
    feverMax: number | null
    startDate: Date | null
    daysPlanned: number | null
    expectedReturn: Date | null
    expectedReturnManual: boolean | null
    capMinutes: number | null
    noSprint: boolean | null
    noChangeOfDirection: boolean | null
    gymOnly: boolean | null
    noContact: boolean | null
    notes: string | null
    medSignature: string | null
    protocolObjectives: string | null
    protocolTasks: string | null
    protocolControls: string | null
    protocolCriteria: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicalEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    status: $Enums.ClinicalStatus | null
    leaveStage: $Enums.LeaveStage | null
    leaveKind: $Enums.LeaveKind | null
    diagnosis: string | null
    bodyPart: string | null
    laterality: $Enums.Laterality | null
    mechanism: $Enums.Mechanism | null
    severity: $Enums.Severity | null
    illSystem: $Enums.SystemAffected | null
    illSymptoms: string | null
    illContagious: boolean | null
    illIsolationDays: number | null
    illAptitude: $Enums.IllAptitude | null
    feverMax: number | null
    startDate: Date | null
    daysPlanned: number | null
    expectedReturn: Date | null
    expectedReturnManual: boolean | null
    capMinutes: number | null
    noSprint: boolean | null
    noChangeOfDirection: boolean | null
    gymOnly: boolean | null
    noContact: boolean | null
    notes: string | null
    medSignature: string | null
    protocolObjectives: string | null
    protocolTasks: string | null
    protocolControls: string | null
    protocolCriteria: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicalEntryCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    status: number
    leaveStage: number
    leaveKind: number
    diagnosis: number
    bodyPart: number
    laterality: number
    mechanism: number
    severity: number
    illSystem: number
    illSymptoms: number
    illContagious: number
    illIsolationDays: number
    illAptitude: number
    feverMax: number
    startDate: number
    daysPlanned: number
    expectedReturn: number
    expectedReturnManual: number
    capMinutes: number
    noSprint: number
    noChangeOfDirection: number
    gymOnly: number
    noContact: number
    notes: number
    medSignature: number
    protocolObjectives: number
    protocolTasks: number
    protocolControls: number
    protocolCriteria: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClinicalEntryAvgAggregateInputType = {
    illIsolationDays?: true
    feverMax?: true
    daysPlanned?: true
    capMinutes?: true
  }

  export type ClinicalEntrySumAggregateInputType = {
    illIsolationDays?: true
    feverMax?: true
    daysPlanned?: true
    capMinutes?: true
  }

  export type ClinicalEntryMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    status?: true
    leaveStage?: true
    leaveKind?: true
    diagnosis?: true
    bodyPart?: true
    laterality?: true
    mechanism?: true
    severity?: true
    illSystem?: true
    illSymptoms?: true
    illContagious?: true
    illIsolationDays?: true
    illAptitude?: true
    feverMax?: true
    startDate?: true
    daysPlanned?: true
    expectedReturn?: true
    expectedReturnManual?: true
    capMinutes?: true
    noSprint?: true
    noChangeOfDirection?: true
    gymOnly?: true
    noContact?: true
    notes?: true
    medSignature?: true
    protocolObjectives?: true
    protocolTasks?: true
    protocolControls?: true
    protocolCriteria?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicalEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    status?: true
    leaveStage?: true
    leaveKind?: true
    diagnosis?: true
    bodyPart?: true
    laterality?: true
    mechanism?: true
    severity?: true
    illSystem?: true
    illSymptoms?: true
    illContagious?: true
    illIsolationDays?: true
    illAptitude?: true
    feverMax?: true
    startDate?: true
    daysPlanned?: true
    expectedReturn?: true
    expectedReturnManual?: true
    capMinutes?: true
    noSprint?: true
    noChangeOfDirection?: true
    gymOnly?: true
    noContact?: true
    notes?: true
    medSignature?: true
    protocolObjectives?: true
    protocolTasks?: true
    protocolControls?: true
    protocolCriteria?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicalEntryCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    status?: true
    leaveStage?: true
    leaveKind?: true
    diagnosis?: true
    bodyPart?: true
    laterality?: true
    mechanism?: true
    severity?: true
    illSystem?: true
    illSymptoms?: true
    illContagious?: true
    illIsolationDays?: true
    illAptitude?: true
    feverMax?: true
    startDate?: true
    daysPlanned?: true
    expectedReturn?: true
    expectedReturnManual?: true
    capMinutes?: true
    noSprint?: true
    noChangeOfDirection?: true
    gymOnly?: true
    noContact?: true
    notes?: true
    medSignature?: true
    protocolObjectives?: true
    protocolTasks?: true
    protocolControls?: true
    protocolCriteria?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClinicalEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicalEntry to aggregate.
     */
    where?: ClinicalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalEntries to fetch.
     */
    orderBy?: ClinicalEntryOrderByWithRelationInput | ClinicalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClinicalEntries
    **/
    _count?: true | ClinicalEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClinicalEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClinicalEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicalEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicalEntryMaxAggregateInputType
  }

  export type GetClinicalEntryAggregateType<T extends ClinicalEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateClinicalEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinicalEntry[P]>
      : GetScalarType<T[P], AggregateClinicalEntry[P]>
  }




  export type ClinicalEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalEntryWhereInput
    orderBy?: ClinicalEntryOrderByWithAggregationInput | ClinicalEntryOrderByWithAggregationInput[]
    by: ClinicalEntryScalarFieldEnum[] | ClinicalEntryScalarFieldEnum
    having?: ClinicalEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicalEntryCountAggregateInputType | true
    _avg?: ClinicalEntryAvgAggregateInputType
    _sum?: ClinicalEntrySumAggregateInputType
    _min?: ClinicalEntryMinAggregateInputType
    _max?: ClinicalEntryMaxAggregateInputType
  }

  export type ClinicalEntryGroupByOutputType = {
    id: string
    userId: string
    date: Date
    status: $Enums.ClinicalStatus
    leaveStage: $Enums.LeaveStage | null
    leaveKind: $Enums.LeaveKind | null
    diagnosis: string | null
    bodyPart: string | null
    laterality: $Enums.Laterality | null
    mechanism: $Enums.Mechanism | null
    severity: $Enums.Severity | null
    illSystem: $Enums.SystemAffected | null
    illSymptoms: string | null
    illContagious: boolean | null
    illIsolationDays: number | null
    illAptitude: $Enums.IllAptitude | null
    feverMax: number | null
    startDate: Date | null
    daysPlanned: number | null
    expectedReturn: Date | null
    expectedReturnManual: boolean | null
    capMinutes: number | null
    noSprint: boolean
    noChangeOfDirection: boolean
    gymOnly: boolean
    noContact: boolean
    notes: string | null
    medSignature: string | null
    protocolObjectives: string | null
    protocolTasks: string | null
    protocolControls: string | null
    protocolCriteria: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClinicalEntryCountAggregateOutputType | null
    _avg: ClinicalEntryAvgAggregateOutputType | null
    _sum: ClinicalEntrySumAggregateOutputType | null
    _min: ClinicalEntryMinAggregateOutputType | null
    _max: ClinicalEntryMaxAggregateOutputType | null
  }

  type GetClinicalEntryGroupByPayload<T extends ClinicalEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicalEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicalEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicalEntryGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicalEntryGroupByOutputType[P]>
        }
      >
    >


  export type ClinicalEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    status?: boolean
    leaveStage?: boolean
    leaveKind?: boolean
    diagnosis?: boolean
    bodyPart?: boolean
    laterality?: boolean
    mechanism?: boolean
    severity?: boolean
    illSystem?: boolean
    illSymptoms?: boolean
    illContagious?: boolean
    illIsolationDays?: boolean
    illAptitude?: boolean
    feverMax?: boolean
    startDate?: boolean
    daysPlanned?: boolean
    expectedReturn?: boolean
    expectedReturnManual?: boolean
    capMinutes?: boolean
    noSprint?: boolean
    noChangeOfDirection?: boolean
    gymOnly?: boolean
    noContact?: boolean
    notes?: boolean
    medSignature?: boolean
    protocolObjectives?: boolean
    protocolTasks?: boolean
    protocolControls?: boolean
    protocolCriteria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicalEntry"]>

  export type ClinicalEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    status?: boolean
    leaveStage?: boolean
    leaveKind?: boolean
    diagnosis?: boolean
    bodyPart?: boolean
    laterality?: boolean
    mechanism?: boolean
    severity?: boolean
    illSystem?: boolean
    illSymptoms?: boolean
    illContagious?: boolean
    illIsolationDays?: boolean
    illAptitude?: boolean
    feverMax?: boolean
    startDate?: boolean
    daysPlanned?: boolean
    expectedReturn?: boolean
    expectedReturnManual?: boolean
    capMinutes?: boolean
    noSprint?: boolean
    noChangeOfDirection?: boolean
    gymOnly?: boolean
    noContact?: boolean
    notes?: boolean
    medSignature?: boolean
    protocolObjectives?: boolean
    protocolTasks?: boolean
    protocolControls?: boolean
    protocolCriteria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicalEntry"]>

  export type ClinicalEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    status?: boolean
    leaveStage?: boolean
    leaveKind?: boolean
    diagnosis?: boolean
    bodyPart?: boolean
    laterality?: boolean
    mechanism?: boolean
    severity?: boolean
    illSystem?: boolean
    illSymptoms?: boolean
    illContagious?: boolean
    illIsolationDays?: boolean
    illAptitude?: boolean
    feverMax?: boolean
    startDate?: boolean
    daysPlanned?: boolean
    expectedReturn?: boolean
    expectedReturnManual?: boolean
    capMinutes?: boolean
    noSprint?: boolean
    noChangeOfDirection?: boolean
    gymOnly?: boolean
    noContact?: boolean
    notes?: boolean
    medSignature?: boolean
    protocolObjectives?: boolean
    protocolTasks?: boolean
    protocolControls?: boolean
    protocolCriteria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClinicalEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClinicalEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClinicalEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClinicalEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      status: $Enums.ClinicalStatus
      leaveStage: $Enums.LeaveStage | null
      leaveKind: $Enums.LeaveKind | null
      diagnosis: string | null
      bodyPart: string | null
      laterality: $Enums.Laterality | null
      mechanism: $Enums.Mechanism | null
      severity: $Enums.Severity | null
      illSystem: $Enums.SystemAffected | null
      illSymptoms: string | null
      illContagious: boolean | null
      illIsolationDays: number | null
      illAptitude: $Enums.IllAptitude | null
      feverMax: number | null
      startDate: Date | null
      daysPlanned: number | null
      expectedReturn: Date | null
      expectedReturnManual: boolean | null
      capMinutes: number | null
      noSprint: boolean
      noChangeOfDirection: boolean
      gymOnly: boolean
      noContact: boolean
      notes: string | null
      medSignature: string | null
      protocolObjectives: string | null
      protocolTasks: string | null
      protocolControls: string | null
      protocolCriteria: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clinicalEntry"]>
    composites: {}
  }

  type ClinicalEntryGetPayload<S extends boolean | null | undefined | ClinicalEntryDefaultArgs> = $Result.GetResult<Prisma.$ClinicalEntryPayload, S>

  type ClinicalEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClinicalEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClinicalEntryCountAggregateInputType | true
    }

  export interface ClinicalEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClinicalEntry'], meta: { name: 'ClinicalEntry' } }
    /**
     * Find zero or one ClinicalEntry that matches the filter.
     * @param {ClinicalEntryFindUniqueArgs} args - Arguments to find a ClinicalEntry
     * @example
     * // Get one ClinicalEntry
     * const clinicalEntry = await prisma.clinicalEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicalEntryFindUniqueArgs>(args: SelectSubset<T, ClinicalEntryFindUniqueArgs<ExtArgs>>): Prisma__ClinicalEntryClient<$Result.GetResult<Prisma.$ClinicalEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClinicalEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClinicalEntryFindUniqueOrThrowArgs} args - Arguments to find a ClinicalEntry
     * @example
     * // Get one ClinicalEntry
     * const clinicalEntry = await prisma.clinicalEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicalEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicalEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicalEntryClient<$Result.GetResult<Prisma.$ClinicalEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClinicalEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalEntryFindFirstArgs} args - Arguments to find a ClinicalEntry
     * @example
     * // Get one ClinicalEntry
     * const clinicalEntry = await prisma.clinicalEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicalEntryFindFirstArgs>(args?: SelectSubset<T, ClinicalEntryFindFirstArgs<ExtArgs>>): Prisma__ClinicalEntryClient<$Result.GetResult<Prisma.$ClinicalEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClinicalEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalEntryFindFirstOrThrowArgs} args - Arguments to find a ClinicalEntry
     * @example
     * // Get one ClinicalEntry
     * const clinicalEntry = await prisma.clinicalEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicalEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicalEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicalEntryClient<$Result.GetResult<Prisma.$ClinicalEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClinicalEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClinicalEntries
     * const clinicalEntries = await prisma.clinicalEntry.findMany()
     * 
     * // Get first 10 ClinicalEntries
     * const clinicalEntries = await prisma.clinicalEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicalEntryWithIdOnly = await prisma.clinicalEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicalEntryFindManyArgs>(args?: SelectSubset<T, ClinicalEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClinicalEntry.
     * @param {ClinicalEntryCreateArgs} args - Arguments to create a ClinicalEntry.
     * @example
     * // Create one ClinicalEntry
     * const ClinicalEntry = await prisma.clinicalEntry.create({
     *   data: {
     *     // ... data to create a ClinicalEntry
     *   }
     * })
     * 
     */
    create<T extends ClinicalEntryCreateArgs>(args: SelectSubset<T, ClinicalEntryCreateArgs<ExtArgs>>): Prisma__ClinicalEntryClient<$Result.GetResult<Prisma.$ClinicalEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClinicalEntries.
     * @param {ClinicalEntryCreateManyArgs} args - Arguments to create many ClinicalEntries.
     * @example
     * // Create many ClinicalEntries
     * const clinicalEntry = await prisma.clinicalEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicalEntryCreateManyArgs>(args?: SelectSubset<T, ClinicalEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClinicalEntries and returns the data saved in the database.
     * @param {ClinicalEntryCreateManyAndReturnArgs} args - Arguments to create many ClinicalEntries.
     * @example
     * // Create many ClinicalEntries
     * const clinicalEntry = await prisma.clinicalEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClinicalEntries and only return the `id`
     * const clinicalEntryWithIdOnly = await prisma.clinicalEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicalEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicalEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClinicalEntry.
     * @param {ClinicalEntryDeleteArgs} args - Arguments to delete one ClinicalEntry.
     * @example
     * // Delete one ClinicalEntry
     * const ClinicalEntry = await prisma.clinicalEntry.delete({
     *   where: {
     *     // ... filter to delete one ClinicalEntry
     *   }
     * })
     * 
     */
    delete<T extends ClinicalEntryDeleteArgs>(args: SelectSubset<T, ClinicalEntryDeleteArgs<ExtArgs>>): Prisma__ClinicalEntryClient<$Result.GetResult<Prisma.$ClinicalEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClinicalEntry.
     * @param {ClinicalEntryUpdateArgs} args - Arguments to update one ClinicalEntry.
     * @example
     * // Update one ClinicalEntry
     * const clinicalEntry = await prisma.clinicalEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicalEntryUpdateArgs>(args: SelectSubset<T, ClinicalEntryUpdateArgs<ExtArgs>>): Prisma__ClinicalEntryClient<$Result.GetResult<Prisma.$ClinicalEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClinicalEntries.
     * @param {ClinicalEntryDeleteManyArgs} args - Arguments to filter ClinicalEntries to delete.
     * @example
     * // Delete a few ClinicalEntries
     * const { count } = await prisma.clinicalEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicalEntryDeleteManyArgs>(args?: SelectSubset<T, ClinicalEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClinicalEntries
     * const clinicalEntry = await prisma.clinicalEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicalEntryUpdateManyArgs>(args: SelectSubset<T, ClinicalEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClinicalEntry.
     * @param {ClinicalEntryUpsertArgs} args - Arguments to update or create a ClinicalEntry.
     * @example
     * // Update or create a ClinicalEntry
     * const clinicalEntry = await prisma.clinicalEntry.upsert({
     *   create: {
     *     // ... data to create a ClinicalEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClinicalEntry we want to update
     *   }
     * })
     */
    upsert<T extends ClinicalEntryUpsertArgs>(args: SelectSubset<T, ClinicalEntryUpsertArgs<ExtArgs>>): Prisma__ClinicalEntryClient<$Result.GetResult<Prisma.$ClinicalEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClinicalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalEntryCountArgs} args - Arguments to filter ClinicalEntries to count.
     * @example
     * // Count the number of ClinicalEntries
     * const count = await prisma.clinicalEntry.count({
     *   where: {
     *     // ... the filter for the ClinicalEntries we want to count
     *   }
     * })
    **/
    count<T extends ClinicalEntryCountArgs>(
      args?: Subset<T, ClinicalEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicalEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClinicalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicalEntryAggregateArgs>(args: Subset<T, ClinicalEntryAggregateArgs>): Prisma.PrismaPromise<GetClinicalEntryAggregateType<T>>

    /**
     * Group by ClinicalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicalEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicalEntryGroupByArgs['orderBy'] }
        : { orderBy?: ClinicalEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicalEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicalEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClinicalEntry model
   */
  readonly fields: ClinicalEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClinicalEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicalEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClinicalEntry model
   */ 
  interface ClinicalEntryFieldRefs {
    readonly id: FieldRef<"ClinicalEntry", 'String'>
    readonly userId: FieldRef<"ClinicalEntry", 'String'>
    readonly date: FieldRef<"ClinicalEntry", 'DateTime'>
    readonly status: FieldRef<"ClinicalEntry", 'ClinicalStatus'>
    readonly leaveStage: FieldRef<"ClinicalEntry", 'LeaveStage'>
    readonly leaveKind: FieldRef<"ClinicalEntry", 'LeaveKind'>
    readonly diagnosis: FieldRef<"ClinicalEntry", 'String'>
    readonly bodyPart: FieldRef<"ClinicalEntry", 'String'>
    readonly laterality: FieldRef<"ClinicalEntry", 'Laterality'>
    readonly mechanism: FieldRef<"ClinicalEntry", 'Mechanism'>
    readonly severity: FieldRef<"ClinicalEntry", 'Severity'>
    readonly illSystem: FieldRef<"ClinicalEntry", 'SystemAffected'>
    readonly illSymptoms: FieldRef<"ClinicalEntry", 'String'>
    readonly illContagious: FieldRef<"ClinicalEntry", 'Boolean'>
    readonly illIsolationDays: FieldRef<"ClinicalEntry", 'Int'>
    readonly illAptitude: FieldRef<"ClinicalEntry", 'IllAptitude'>
    readonly feverMax: FieldRef<"ClinicalEntry", 'Float'>
    readonly startDate: FieldRef<"ClinicalEntry", 'DateTime'>
    readonly daysPlanned: FieldRef<"ClinicalEntry", 'Int'>
    readonly expectedReturn: FieldRef<"ClinicalEntry", 'DateTime'>
    readonly expectedReturnManual: FieldRef<"ClinicalEntry", 'Boolean'>
    readonly capMinutes: FieldRef<"ClinicalEntry", 'Int'>
    readonly noSprint: FieldRef<"ClinicalEntry", 'Boolean'>
    readonly noChangeOfDirection: FieldRef<"ClinicalEntry", 'Boolean'>
    readonly gymOnly: FieldRef<"ClinicalEntry", 'Boolean'>
    readonly noContact: FieldRef<"ClinicalEntry", 'Boolean'>
    readonly notes: FieldRef<"ClinicalEntry", 'String'>
    readonly medSignature: FieldRef<"ClinicalEntry", 'String'>
    readonly protocolObjectives: FieldRef<"ClinicalEntry", 'String'>
    readonly protocolTasks: FieldRef<"ClinicalEntry", 'String'>
    readonly protocolControls: FieldRef<"ClinicalEntry", 'String'>
    readonly protocolCriteria: FieldRef<"ClinicalEntry", 'String'>
    readonly createdAt: FieldRef<"ClinicalEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"ClinicalEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClinicalEntry findUnique
   */
  export type ClinicalEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalEntry
     */
    select?: ClinicalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalEntryInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalEntry to fetch.
     */
    where: ClinicalEntryWhereUniqueInput
  }

  /**
   * ClinicalEntry findUniqueOrThrow
   */
  export type ClinicalEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalEntry
     */
    select?: ClinicalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalEntryInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalEntry to fetch.
     */
    where: ClinicalEntryWhereUniqueInput
  }

  /**
   * ClinicalEntry findFirst
   */
  export type ClinicalEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalEntry
     */
    select?: ClinicalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalEntryInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalEntry to fetch.
     */
    where?: ClinicalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalEntries to fetch.
     */
    orderBy?: ClinicalEntryOrderByWithRelationInput | ClinicalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicalEntries.
     */
    cursor?: ClinicalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicalEntries.
     */
    distinct?: ClinicalEntryScalarFieldEnum | ClinicalEntryScalarFieldEnum[]
  }

  /**
   * ClinicalEntry findFirstOrThrow
   */
  export type ClinicalEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalEntry
     */
    select?: ClinicalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalEntryInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalEntry to fetch.
     */
    where?: ClinicalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalEntries to fetch.
     */
    orderBy?: ClinicalEntryOrderByWithRelationInput | ClinicalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicalEntries.
     */
    cursor?: ClinicalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicalEntries.
     */
    distinct?: ClinicalEntryScalarFieldEnum | ClinicalEntryScalarFieldEnum[]
  }

  /**
   * ClinicalEntry findMany
   */
  export type ClinicalEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalEntry
     */
    select?: ClinicalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalEntryInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalEntries to fetch.
     */
    where?: ClinicalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalEntries to fetch.
     */
    orderBy?: ClinicalEntryOrderByWithRelationInput | ClinicalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClinicalEntries.
     */
    cursor?: ClinicalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalEntries.
     */
    skip?: number
    distinct?: ClinicalEntryScalarFieldEnum | ClinicalEntryScalarFieldEnum[]
  }

  /**
   * ClinicalEntry create
   */
  export type ClinicalEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalEntry
     */
    select?: ClinicalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a ClinicalEntry.
     */
    data: XOR<ClinicalEntryCreateInput, ClinicalEntryUncheckedCreateInput>
  }

  /**
   * ClinicalEntry createMany
   */
  export type ClinicalEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClinicalEntries.
     */
    data: ClinicalEntryCreateManyInput | ClinicalEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicalEntry createManyAndReturn
   */
  export type ClinicalEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalEntry
     */
    select?: ClinicalEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClinicalEntries.
     */
    data: ClinicalEntryCreateManyInput | ClinicalEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicalEntry update
   */
  export type ClinicalEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalEntry
     */
    select?: ClinicalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a ClinicalEntry.
     */
    data: XOR<ClinicalEntryUpdateInput, ClinicalEntryUncheckedUpdateInput>
    /**
     * Choose, which ClinicalEntry to update.
     */
    where: ClinicalEntryWhereUniqueInput
  }

  /**
   * ClinicalEntry updateMany
   */
  export type ClinicalEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClinicalEntries.
     */
    data: XOR<ClinicalEntryUpdateManyMutationInput, ClinicalEntryUncheckedUpdateManyInput>
    /**
     * Filter which ClinicalEntries to update
     */
    where?: ClinicalEntryWhereInput
  }

  /**
   * ClinicalEntry upsert
   */
  export type ClinicalEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalEntry
     */
    select?: ClinicalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the ClinicalEntry to update in case it exists.
     */
    where: ClinicalEntryWhereUniqueInput
    /**
     * In case the ClinicalEntry found by the `where` argument doesn't exist, create a new ClinicalEntry with this data.
     */
    create: XOR<ClinicalEntryCreateInput, ClinicalEntryUncheckedCreateInput>
    /**
     * In case the ClinicalEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicalEntryUpdateInput, ClinicalEntryUncheckedUpdateInput>
  }

  /**
   * ClinicalEntry delete
   */
  export type ClinicalEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalEntry
     */
    select?: ClinicalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalEntryInclude<ExtArgs> | null
    /**
     * Filter which ClinicalEntry to delete.
     */
    where: ClinicalEntryWhereUniqueInput
  }

  /**
   * ClinicalEntry deleteMany
   */
  export type ClinicalEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicalEntries to delete
     */
    where?: ClinicalEntryWhereInput
  }

  /**
   * ClinicalEntry without action
   */
  export type ClinicalEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalEntry
     */
    select?: ClinicalEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalEntryInclude<ExtArgs> | null
  }


  /**
   * Model ScoutingCategory
   */

  export type AggregateScoutingCategory = {
    _count: ScoutingCategoryCountAggregateOutputType | null
    _avg: ScoutingCategoryAvgAggregateOutputType | null
    _sum: ScoutingCategorySumAggregateOutputType | null
    _min: ScoutingCategoryMinAggregateOutputType | null
    _max: ScoutingCategoryMaxAggregateOutputType | null
  }

  export type ScoutingCategoryAvgAggregateOutputType = {
    orden: number | null
  }

  export type ScoutingCategorySumAggregateOutputType = {
    orden: number | null
  }

  export type ScoutingCategoryMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    nombre: string | null
    slug: string | null
    orden: number | null
    color: string | null
    activa: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScoutingCategoryMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    nombre: string | null
    slug: string | null
    orden: number | null
    color: string | null
    activa: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScoutingCategoryCountAggregateOutputType = {
    id: number
    teamId: number
    nombre: number
    slug: number
    orden: number
    color: number
    activa: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScoutingCategoryAvgAggregateInputType = {
    orden?: true
  }

  export type ScoutingCategorySumAggregateInputType = {
    orden?: true
  }

  export type ScoutingCategoryMinAggregateInputType = {
    id?: true
    teamId?: true
    nombre?: true
    slug?: true
    orden?: true
    color?: true
    activa?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScoutingCategoryMaxAggregateInputType = {
    id?: true
    teamId?: true
    nombre?: true
    slug?: true
    orden?: true
    color?: true
    activa?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScoutingCategoryCountAggregateInputType = {
    id?: true
    teamId?: true
    nombre?: true
    slug?: true
    orden?: true
    color?: true
    activa?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScoutingCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScoutingCategory to aggregate.
     */
    where?: ScoutingCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoutingCategories to fetch.
     */
    orderBy?: ScoutingCategoryOrderByWithRelationInput | ScoutingCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScoutingCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoutingCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoutingCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScoutingCategories
    **/
    _count?: true | ScoutingCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScoutingCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScoutingCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScoutingCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScoutingCategoryMaxAggregateInputType
  }

  export type GetScoutingCategoryAggregateType<T extends ScoutingCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateScoutingCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScoutingCategory[P]>
      : GetScalarType<T[P], AggregateScoutingCategory[P]>
  }




  export type ScoutingCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScoutingCategoryWhereInput
    orderBy?: ScoutingCategoryOrderByWithAggregationInput | ScoutingCategoryOrderByWithAggregationInput[]
    by: ScoutingCategoryScalarFieldEnum[] | ScoutingCategoryScalarFieldEnum
    having?: ScoutingCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScoutingCategoryCountAggregateInputType | true
    _avg?: ScoutingCategoryAvgAggregateInputType
    _sum?: ScoutingCategorySumAggregateInputType
    _min?: ScoutingCategoryMinAggregateInputType
    _max?: ScoutingCategoryMaxAggregateInputType
  }

  export type ScoutingCategoryGroupByOutputType = {
    id: string
    teamId: string | null
    nombre: string
    slug: string
    orden: number
    color: string | null
    activa: boolean
    createdAt: Date
    updatedAt: Date
    _count: ScoutingCategoryCountAggregateOutputType | null
    _avg: ScoutingCategoryAvgAggregateOutputType | null
    _sum: ScoutingCategorySumAggregateOutputType | null
    _min: ScoutingCategoryMinAggregateOutputType | null
    _max: ScoutingCategoryMaxAggregateOutputType | null
  }

  type GetScoutingCategoryGroupByPayload<T extends ScoutingCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScoutingCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScoutingCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScoutingCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ScoutingCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ScoutingCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    nombre?: boolean
    slug?: boolean
    orden?: boolean
    color?: boolean
    activa?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | ScoutingCategory$teamArgs<ExtArgs>
    players?: boolean | ScoutingCategory$playersArgs<ExtArgs>
    _count?: boolean | ScoutingCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scoutingCategory"]>

  export type ScoutingCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    nombre?: boolean
    slug?: boolean
    orden?: boolean
    color?: boolean
    activa?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | ScoutingCategory$teamArgs<ExtArgs>
  }, ExtArgs["result"]["scoutingCategory"]>

  export type ScoutingCategorySelectScalar = {
    id?: boolean
    teamId?: boolean
    nombre?: boolean
    slug?: boolean
    orden?: boolean
    color?: boolean
    activa?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScoutingCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | ScoutingCategory$teamArgs<ExtArgs>
    players?: boolean | ScoutingCategory$playersArgs<ExtArgs>
    _count?: boolean | ScoutingCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScoutingCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | ScoutingCategory$teamArgs<ExtArgs>
  }

  export type $ScoutingCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScoutingCategory"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs> | null
      players: Prisma.$ScoutingPlayerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string | null
      nombre: string
      slug: string
      orden: number
      color: string | null
      activa: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scoutingCategory"]>
    composites: {}
  }

  type ScoutingCategoryGetPayload<S extends boolean | null | undefined | ScoutingCategoryDefaultArgs> = $Result.GetResult<Prisma.$ScoutingCategoryPayload, S>

  type ScoutingCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScoutingCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScoutingCategoryCountAggregateInputType | true
    }

  export interface ScoutingCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScoutingCategory'], meta: { name: 'ScoutingCategory' } }
    /**
     * Find zero or one ScoutingCategory that matches the filter.
     * @param {ScoutingCategoryFindUniqueArgs} args - Arguments to find a ScoutingCategory
     * @example
     * // Get one ScoutingCategory
     * const scoutingCategory = await prisma.scoutingCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScoutingCategoryFindUniqueArgs>(args: SelectSubset<T, ScoutingCategoryFindUniqueArgs<ExtArgs>>): Prisma__ScoutingCategoryClient<$Result.GetResult<Prisma.$ScoutingCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScoutingCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScoutingCategoryFindUniqueOrThrowArgs} args - Arguments to find a ScoutingCategory
     * @example
     * // Get one ScoutingCategory
     * const scoutingCategory = await prisma.scoutingCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScoutingCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ScoutingCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScoutingCategoryClient<$Result.GetResult<Prisma.$ScoutingCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScoutingCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutingCategoryFindFirstArgs} args - Arguments to find a ScoutingCategory
     * @example
     * // Get one ScoutingCategory
     * const scoutingCategory = await prisma.scoutingCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScoutingCategoryFindFirstArgs>(args?: SelectSubset<T, ScoutingCategoryFindFirstArgs<ExtArgs>>): Prisma__ScoutingCategoryClient<$Result.GetResult<Prisma.$ScoutingCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScoutingCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutingCategoryFindFirstOrThrowArgs} args - Arguments to find a ScoutingCategory
     * @example
     * // Get one ScoutingCategory
     * const scoutingCategory = await prisma.scoutingCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScoutingCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ScoutingCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScoutingCategoryClient<$Result.GetResult<Prisma.$ScoutingCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScoutingCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutingCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScoutingCategories
     * const scoutingCategories = await prisma.scoutingCategory.findMany()
     * 
     * // Get first 10 ScoutingCategories
     * const scoutingCategories = await prisma.scoutingCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scoutingCategoryWithIdOnly = await prisma.scoutingCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScoutingCategoryFindManyArgs>(args?: SelectSubset<T, ScoutingCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScoutingCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScoutingCategory.
     * @param {ScoutingCategoryCreateArgs} args - Arguments to create a ScoutingCategory.
     * @example
     * // Create one ScoutingCategory
     * const ScoutingCategory = await prisma.scoutingCategory.create({
     *   data: {
     *     // ... data to create a ScoutingCategory
     *   }
     * })
     * 
     */
    create<T extends ScoutingCategoryCreateArgs>(args: SelectSubset<T, ScoutingCategoryCreateArgs<ExtArgs>>): Prisma__ScoutingCategoryClient<$Result.GetResult<Prisma.$ScoutingCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScoutingCategories.
     * @param {ScoutingCategoryCreateManyArgs} args - Arguments to create many ScoutingCategories.
     * @example
     * // Create many ScoutingCategories
     * const scoutingCategory = await prisma.scoutingCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScoutingCategoryCreateManyArgs>(args?: SelectSubset<T, ScoutingCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScoutingCategories and returns the data saved in the database.
     * @param {ScoutingCategoryCreateManyAndReturnArgs} args - Arguments to create many ScoutingCategories.
     * @example
     * // Create many ScoutingCategories
     * const scoutingCategory = await prisma.scoutingCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScoutingCategories and only return the `id`
     * const scoutingCategoryWithIdOnly = await prisma.scoutingCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScoutingCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ScoutingCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScoutingCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScoutingCategory.
     * @param {ScoutingCategoryDeleteArgs} args - Arguments to delete one ScoutingCategory.
     * @example
     * // Delete one ScoutingCategory
     * const ScoutingCategory = await prisma.scoutingCategory.delete({
     *   where: {
     *     // ... filter to delete one ScoutingCategory
     *   }
     * })
     * 
     */
    delete<T extends ScoutingCategoryDeleteArgs>(args: SelectSubset<T, ScoutingCategoryDeleteArgs<ExtArgs>>): Prisma__ScoutingCategoryClient<$Result.GetResult<Prisma.$ScoutingCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScoutingCategory.
     * @param {ScoutingCategoryUpdateArgs} args - Arguments to update one ScoutingCategory.
     * @example
     * // Update one ScoutingCategory
     * const scoutingCategory = await prisma.scoutingCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScoutingCategoryUpdateArgs>(args: SelectSubset<T, ScoutingCategoryUpdateArgs<ExtArgs>>): Prisma__ScoutingCategoryClient<$Result.GetResult<Prisma.$ScoutingCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScoutingCategories.
     * @param {ScoutingCategoryDeleteManyArgs} args - Arguments to filter ScoutingCategories to delete.
     * @example
     * // Delete a few ScoutingCategories
     * const { count } = await prisma.scoutingCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScoutingCategoryDeleteManyArgs>(args?: SelectSubset<T, ScoutingCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScoutingCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutingCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScoutingCategories
     * const scoutingCategory = await prisma.scoutingCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScoutingCategoryUpdateManyArgs>(args: SelectSubset<T, ScoutingCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScoutingCategory.
     * @param {ScoutingCategoryUpsertArgs} args - Arguments to update or create a ScoutingCategory.
     * @example
     * // Update or create a ScoutingCategory
     * const scoutingCategory = await prisma.scoutingCategory.upsert({
     *   create: {
     *     // ... data to create a ScoutingCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScoutingCategory we want to update
     *   }
     * })
     */
    upsert<T extends ScoutingCategoryUpsertArgs>(args: SelectSubset<T, ScoutingCategoryUpsertArgs<ExtArgs>>): Prisma__ScoutingCategoryClient<$Result.GetResult<Prisma.$ScoutingCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScoutingCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutingCategoryCountArgs} args - Arguments to filter ScoutingCategories to count.
     * @example
     * // Count the number of ScoutingCategories
     * const count = await prisma.scoutingCategory.count({
     *   where: {
     *     // ... the filter for the ScoutingCategories we want to count
     *   }
     * })
    **/
    count<T extends ScoutingCategoryCountArgs>(
      args?: Subset<T, ScoutingCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScoutingCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScoutingCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutingCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScoutingCategoryAggregateArgs>(args: Subset<T, ScoutingCategoryAggregateArgs>): Prisma.PrismaPromise<GetScoutingCategoryAggregateType<T>>

    /**
     * Group by ScoutingCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutingCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScoutingCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScoutingCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ScoutingCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScoutingCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScoutingCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScoutingCategory model
   */
  readonly fields: ScoutingCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScoutingCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScoutingCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends ScoutingCategory$teamArgs<ExtArgs> = {}>(args?: Subset<T, ScoutingCategory$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    players<T extends ScoutingCategory$playersArgs<ExtArgs> = {}>(args?: Subset<T, ScoutingCategory$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScoutingPlayerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScoutingCategory model
   */ 
  interface ScoutingCategoryFieldRefs {
    readonly id: FieldRef<"ScoutingCategory", 'String'>
    readonly teamId: FieldRef<"ScoutingCategory", 'String'>
    readonly nombre: FieldRef<"ScoutingCategory", 'String'>
    readonly slug: FieldRef<"ScoutingCategory", 'String'>
    readonly orden: FieldRef<"ScoutingCategory", 'Int'>
    readonly color: FieldRef<"ScoutingCategory", 'String'>
    readonly activa: FieldRef<"ScoutingCategory", 'Boolean'>
    readonly createdAt: FieldRef<"ScoutingCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ScoutingCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScoutingCategory findUnique
   */
  export type ScoutingCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingCategory
     */
    select?: ScoutingCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ScoutingCategory to fetch.
     */
    where: ScoutingCategoryWhereUniqueInput
  }

  /**
   * ScoutingCategory findUniqueOrThrow
   */
  export type ScoutingCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingCategory
     */
    select?: ScoutingCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ScoutingCategory to fetch.
     */
    where: ScoutingCategoryWhereUniqueInput
  }

  /**
   * ScoutingCategory findFirst
   */
  export type ScoutingCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingCategory
     */
    select?: ScoutingCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ScoutingCategory to fetch.
     */
    where?: ScoutingCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoutingCategories to fetch.
     */
    orderBy?: ScoutingCategoryOrderByWithRelationInput | ScoutingCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScoutingCategories.
     */
    cursor?: ScoutingCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoutingCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoutingCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScoutingCategories.
     */
    distinct?: ScoutingCategoryScalarFieldEnum | ScoutingCategoryScalarFieldEnum[]
  }

  /**
   * ScoutingCategory findFirstOrThrow
   */
  export type ScoutingCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingCategory
     */
    select?: ScoutingCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ScoutingCategory to fetch.
     */
    where?: ScoutingCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoutingCategories to fetch.
     */
    orderBy?: ScoutingCategoryOrderByWithRelationInput | ScoutingCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScoutingCategories.
     */
    cursor?: ScoutingCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoutingCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoutingCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScoutingCategories.
     */
    distinct?: ScoutingCategoryScalarFieldEnum | ScoutingCategoryScalarFieldEnum[]
  }

  /**
   * ScoutingCategory findMany
   */
  export type ScoutingCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingCategory
     */
    select?: ScoutingCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ScoutingCategories to fetch.
     */
    where?: ScoutingCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoutingCategories to fetch.
     */
    orderBy?: ScoutingCategoryOrderByWithRelationInput | ScoutingCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScoutingCategories.
     */
    cursor?: ScoutingCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoutingCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoutingCategories.
     */
    skip?: number
    distinct?: ScoutingCategoryScalarFieldEnum | ScoutingCategoryScalarFieldEnum[]
  }

  /**
   * ScoutingCategory create
   */
  export type ScoutingCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingCategory
     */
    select?: ScoutingCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ScoutingCategory.
     */
    data: XOR<ScoutingCategoryCreateInput, ScoutingCategoryUncheckedCreateInput>
  }

  /**
   * ScoutingCategory createMany
   */
  export type ScoutingCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScoutingCategories.
     */
    data: ScoutingCategoryCreateManyInput | ScoutingCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScoutingCategory createManyAndReturn
   */
  export type ScoutingCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingCategory
     */
    select?: ScoutingCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScoutingCategories.
     */
    data: ScoutingCategoryCreateManyInput | ScoutingCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScoutingCategory update
   */
  export type ScoutingCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingCategory
     */
    select?: ScoutingCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ScoutingCategory.
     */
    data: XOR<ScoutingCategoryUpdateInput, ScoutingCategoryUncheckedUpdateInput>
    /**
     * Choose, which ScoutingCategory to update.
     */
    where: ScoutingCategoryWhereUniqueInput
  }

  /**
   * ScoutingCategory updateMany
   */
  export type ScoutingCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScoutingCategories.
     */
    data: XOR<ScoutingCategoryUpdateManyMutationInput, ScoutingCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ScoutingCategories to update
     */
    where?: ScoutingCategoryWhereInput
  }

  /**
   * ScoutingCategory upsert
   */
  export type ScoutingCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingCategory
     */
    select?: ScoutingCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ScoutingCategory to update in case it exists.
     */
    where: ScoutingCategoryWhereUniqueInput
    /**
     * In case the ScoutingCategory found by the `where` argument doesn't exist, create a new ScoutingCategory with this data.
     */
    create: XOR<ScoutingCategoryCreateInput, ScoutingCategoryUncheckedCreateInput>
    /**
     * In case the ScoutingCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScoutingCategoryUpdateInput, ScoutingCategoryUncheckedUpdateInput>
  }

  /**
   * ScoutingCategory delete
   */
  export type ScoutingCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingCategory
     */
    select?: ScoutingCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingCategoryInclude<ExtArgs> | null
    /**
     * Filter which ScoutingCategory to delete.
     */
    where: ScoutingCategoryWhereUniqueInput
  }

  /**
   * ScoutingCategory deleteMany
   */
  export type ScoutingCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScoutingCategories to delete
     */
    where?: ScoutingCategoryWhereInput
  }

  /**
   * ScoutingCategory.team
   */
  export type ScoutingCategory$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * ScoutingCategory.players
   */
  export type ScoutingCategory$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingPlayer
     */
    select?: ScoutingPlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingPlayerInclude<ExtArgs> | null
    where?: ScoutingPlayerWhereInput
    orderBy?: ScoutingPlayerOrderByWithRelationInput | ScoutingPlayerOrderByWithRelationInput[]
    cursor?: ScoutingPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScoutingPlayerScalarFieldEnum | ScoutingPlayerScalarFieldEnum[]
  }

  /**
   * ScoutingCategory without action
   */
  export type ScoutingCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingCategory
     */
    select?: ScoutingCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Player
   */

  export type AggregatePlayer = {
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  export type PlayerAvgAggregateOutputType = {
    shirtNumber: number | null
  }

  export type PlayerSumAggregateOutputType = {
    shirtNumber: number | null
  }

  export type PlayerMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    name: string | null
    shirtNumber: number | null
    position: string | null
    photoUrl: string | null
    birthDate: Date | null
    status: $Enums.PlayerStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    name: string | null
    shirtNumber: number | null
    position: string | null
    photoUrl: string | null
    birthDate: Date | null
    status: $Enums.PlayerStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerCountAggregateOutputType = {
    id: number
    teamId: number
    userId: number
    name: number
    shirtNumber: number
    position: number
    photoUrl: number
    birthDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerAvgAggregateInputType = {
    shirtNumber?: true
  }

  export type PlayerSumAggregateInputType = {
    shirtNumber?: true
  }

  export type PlayerMinAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    name?: true
    shirtNumber?: true
    position?: true
    photoUrl?: true
    birthDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerMaxAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    name?: true
    shirtNumber?: true
    position?: true
    photoUrl?: true
    birthDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerCountAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    name?: true
    shirtNumber?: true
    position?: true
    photoUrl?: true
    birthDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Player to aggregate.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Players
    **/
    _count?: true | PlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMaxAggregateInputType
  }

  export type GetPlayerAggregateType<T extends PlayerAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer[P]>
      : GetScalarType<T[P], AggregatePlayer[P]>
  }




  export type PlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithAggregationInput | PlayerOrderByWithAggregationInput[]
    by: PlayerScalarFieldEnum[] | PlayerScalarFieldEnum
    having?: PlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCountAggregateInputType | true
    _avg?: PlayerAvgAggregateInputType
    _sum?: PlayerSumAggregateInputType
    _min?: PlayerMinAggregateInputType
    _max?: PlayerMaxAggregateInputType
  }

  export type PlayerGroupByOutputType = {
    id: string
    teamId: string
    userId: string | null
    name: string
    shirtNumber: number | null
    position: string | null
    photoUrl: string | null
    birthDate: Date | null
    status: $Enums.PlayerStatus
    createdAt: Date
    updatedAt: Date
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  type GetPlayerGroupByPayload<T extends PlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    name?: boolean
    shirtNumber?: boolean
    position?: boolean
    photoUrl?: boolean
    birthDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | Player$userArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    name?: boolean
    shirtNumber?: boolean
    position?: boolean
    photoUrl?: boolean
    birthDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | Player$userArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectScalar = {
    id?: boolean
    teamId?: boolean
    userId?: boolean
    name?: boolean
    shirtNumber?: boolean
    position?: boolean
    photoUrl?: boolean
    birthDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | Player$userArgs<ExtArgs>
  }
  export type PlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | Player$userArgs<ExtArgs>
  }

  export type $PlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Player"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      userId: string | null
      name: string
      shirtNumber: number | null
      position: string | null
      photoUrl: string | null
      birthDate: Date | null
      status: $Enums.PlayerStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["player"]>
    composites: {}
  }

  type PlayerGetPayload<S extends boolean | null | undefined | PlayerDefaultArgs> = $Result.GetResult<Prisma.$PlayerPayload, S>

  type PlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerCountAggregateInputType | true
    }

  export interface PlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Player'], meta: { name: 'Player' } }
    /**
     * Find zero or one Player that matches the filter.
     * @param {PlayerFindUniqueArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerFindUniqueArgs>(args: SelectSubset<T, PlayerFindUniqueArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Player that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerFindUniqueOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Player that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerFindFirstArgs>(args?: SelectSubset<T, PlayerFindFirstArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Player that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Players
     * const players = await prisma.player.findMany()
     * 
     * // Get first 10 Players
     * const players = await prisma.player.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerWithIdOnly = await prisma.player.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerFindManyArgs>(args?: SelectSubset<T, PlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Player.
     * @param {PlayerCreateArgs} args - Arguments to create a Player.
     * @example
     * // Create one Player
     * const Player = await prisma.player.create({
     *   data: {
     *     // ... data to create a Player
     *   }
     * })
     * 
     */
    create<T extends PlayerCreateArgs>(args: SelectSubset<T, PlayerCreateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Players.
     * @param {PlayerCreateManyArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerCreateManyArgs>(args?: SelectSubset<T, PlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Players and returns the data saved in the database.
     * @param {PlayerCreateManyAndReturnArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Players and only return the `id`
     * const playerWithIdOnly = await prisma.player.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Player.
     * @param {PlayerDeleteArgs} args - Arguments to delete one Player.
     * @example
     * // Delete one Player
     * const Player = await prisma.player.delete({
     *   where: {
     *     // ... filter to delete one Player
     *   }
     * })
     * 
     */
    delete<T extends PlayerDeleteArgs>(args: SelectSubset<T, PlayerDeleteArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Player.
     * @param {PlayerUpdateArgs} args - Arguments to update one Player.
     * @example
     * // Update one Player
     * const player = await prisma.player.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerUpdateArgs>(args: SelectSubset<T, PlayerUpdateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Players.
     * @param {PlayerDeleteManyArgs} args - Arguments to filter Players to delete.
     * @example
     * // Delete a few Players
     * const { count } = await prisma.player.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerDeleteManyArgs>(args?: SelectSubset<T, PlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerUpdateManyArgs>(args: SelectSubset<T, PlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Player.
     * @param {PlayerUpsertArgs} args - Arguments to update or create a Player.
     * @example
     * // Update or create a Player
     * const player = await prisma.player.upsert({
     *   create: {
     *     // ... data to create a Player
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player we want to update
     *   }
     * })
     */
    upsert<T extends PlayerUpsertArgs>(args: SelectSubset<T, PlayerUpsertArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCountArgs} args - Arguments to filter Players to count.
     * @example
     * // Count the number of Players
     * const count = await prisma.player.count({
     *   where: {
     *     // ... the filter for the Players we want to count
     *   }
     * })
    **/
    count<T extends PlayerCountArgs>(
      args?: Subset<T, PlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerAggregateArgs>(args: Subset<T, PlayerAggregateArgs>): Prisma.PrismaPromise<GetPlayerAggregateType<T>>

    /**
     * Group by Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerGroupByArgs['orderBy'] }
        : { orderBy?: PlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Player model
   */
  readonly fields: PlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Player.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends Player$userArgs<ExtArgs> = {}>(args?: Subset<T, Player$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Player model
   */ 
  interface PlayerFieldRefs {
    readonly id: FieldRef<"Player", 'String'>
    readonly teamId: FieldRef<"Player", 'String'>
    readonly userId: FieldRef<"Player", 'String'>
    readonly name: FieldRef<"Player", 'String'>
    readonly shirtNumber: FieldRef<"Player", 'Int'>
    readonly position: FieldRef<"Player", 'String'>
    readonly photoUrl: FieldRef<"Player", 'String'>
    readonly birthDate: FieldRef<"Player", 'DateTime'>
    readonly status: FieldRef<"Player", 'PlayerStatus'>
    readonly createdAt: FieldRef<"Player", 'DateTime'>
    readonly updatedAt: FieldRef<"Player", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Player findUnique
   */
  export type PlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findUniqueOrThrow
   */
  export type PlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findFirst
   */
  export type PlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findFirstOrThrow
   */
  export type PlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findMany
   */
  export type PlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Players to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player create
   */
  export type PlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a Player.
     */
    data: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
  }

  /**
   * Player createMany
   */
  export type PlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Player createManyAndReturn
   */
  export type PlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Player update
   */
  export type PlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a Player.
     */
    data: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
    /**
     * Choose, which Player to update.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player updateMany
   */
  export type PlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
  }

  /**
   * Player upsert
   */
  export type PlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the Player to update in case it exists.
     */
    where: PlayerWhereUniqueInput
    /**
     * In case the Player found by the `where` argument doesn't exist, create a new Player with this data.
     */
    create: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
    /**
     * In case the Player was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
  }

  /**
   * Player delete
   */
  export type PlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter which Player to delete.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player deleteMany
   */
  export type PlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Players to delete
     */
    where?: PlayerWhereInput
  }

  /**
   * Player.user
   */
  export type Player$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Player without action
   */
  export type PlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
  }


  /**
   * Model ScoutingPlayer
   */

  export type AggregateScoutingPlayer = {
    _count: ScoutingPlayerCountAggregateOutputType | null
    _avg: ScoutingPlayerAvgAggregateOutputType | null
    _sum: ScoutingPlayerSumAggregateOutputType | null
    _min: ScoutingPlayerMinAggregateOutputType | null
    _max: ScoutingPlayerMaxAggregateOutputType | null
  }

  export type ScoutingPlayerAvgAggregateOutputType = {
    rating: number | null
  }

  export type ScoutingPlayerSumAggregateOutputType = {
    rating: number | null
  }

  export type ScoutingPlayerMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    fullName: string | null
    club: string | null
    estado: $Enums.ScoutingStatus | null
    categoriaId: string | null
    agentName: string | null
    agentPhone: string | null
    agentEmail: string | null
    playerPhone: string | null
    playerEmail: string | null
    instagram: string | null
    notes: string | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScoutingPlayerMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    fullName: string | null
    club: string | null
    estado: $Enums.ScoutingStatus | null
    categoriaId: string | null
    agentName: string | null
    agentPhone: string | null
    agentEmail: string | null
    playerPhone: string | null
    playerEmail: string | null
    instagram: string | null
    notes: string | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScoutingPlayerCountAggregateOutputType = {
    id: number
    teamId: number
    fullName: number
    positions: number
    club: number
    estado: number
    categoriaId: number
    agentName: number
    agentPhone: number
    agentEmail: number
    playerPhone: number
    playerEmail: number
    instagram: number
    videos: number
    notes: number
    rating: number
    tags: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScoutingPlayerAvgAggregateInputType = {
    rating?: true
  }

  export type ScoutingPlayerSumAggregateInputType = {
    rating?: true
  }

  export type ScoutingPlayerMinAggregateInputType = {
    id?: true
    teamId?: true
    fullName?: true
    club?: true
    estado?: true
    categoriaId?: true
    agentName?: true
    agentPhone?: true
    agentEmail?: true
    playerPhone?: true
    playerEmail?: true
    instagram?: true
    notes?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScoutingPlayerMaxAggregateInputType = {
    id?: true
    teamId?: true
    fullName?: true
    club?: true
    estado?: true
    categoriaId?: true
    agentName?: true
    agentPhone?: true
    agentEmail?: true
    playerPhone?: true
    playerEmail?: true
    instagram?: true
    notes?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScoutingPlayerCountAggregateInputType = {
    id?: true
    teamId?: true
    fullName?: true
    positions?: true
    club?: true
    estado?: true
    categoriaId?: true
    agentName?: true
    agentPhone?: true
    agentEmail?: true
    playerPhone?: true
    playerEmail?: true
    instagram?: true
    videos?: true
    notes?: true
    rating?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScoutingPlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScoutingPlayer to aggregate.
     */
    where?: ScoutingPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoutingPlayers to fetch.
     */
    orderBy?: ScoutingPlayerOrderByWithRelationInput | ScoutingPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScoutingPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoutingPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoutingPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScoutingPlayers
    **/
    _count?: true | ScoutingPlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScoutingPlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScoutingPlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScoutingPlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScoutingPlayerMaxAggregateInputType
  }

  export type GetScoutingPlayerAggregateType<T extends ScoutingPlayerAggregateArgs> = {
        [P in keyof T & keyof AggregateScoutingPlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScoutingPlayer[P]>
      : GetScalarType<T[P], AggregateScoutingPlayer[P]>
  }




  export type ScoutingPlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScoutingPlayerWhereInput
    orderBy?: ScoutingPlayerOrderByWithAggregationInput | ScoutingPlayerOrderByWithAggregationInput[]
    by: ScoutingPlayerScalarFieldEnum[] | ScoutingPlayerScalarFieldEnum
    having?: ScoutingPlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScoutingPlayerCountAggregateInputType | true
    _avg?: ScoutingPlayerAvgAggregateInputType
    _sum?: ScoutingPlayerSumAggregateInputType
    _min?: ScoutingPlayerMinAggregateInputType
    _max?: ScoutingPlayerMaxAggregateInputType
  }

  export type ScoutingPlayerGroupByOutputType = {
    id: string
    teamId: string | null
    fullName: string
    positions: string[]
    club: string | null
    estado: $Enums.ScoutingStatus
    categoriaId: string | null
    agentName: string | null
    agentPhone: string | null
    agentEmail: string | null
    playerPhone: string | null
    playerEmail: string | null
    instagram: string | null
    videos: string[]
    notes: string | null
    rating: number | null
    tags: string[]
    createdAt: Date
    updatedAt: Date
    _count: ScoutingPlayerCountAggregateOutputType | null
    _avg: ScoutingPlayerAvgAggregateOutputType | null
    _sum: ScoutingPlayerSumAggregateOutputType | null
    _min: ScoutingPlayerMinAggregateOutputType | null
    _max: ScoutingPlayerMaxAggregateOutputType | null
  }

  type GetScoutingPlayerGroupByPayload<T extends ScoutingPlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScoutingPlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScoutingPlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScoutingPlayerGroupByOutputType[P]>
            : GetScalarType<T[P], ScoutingPlayerGroupByOutputType[P]>
        }
      >
    >


  export type ScoutingPlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    fullName?: boolean
    positions?: boolean
    club?: boolean
    estado?: boolean
    categoriaId?: boolean
    agentName?: boolean
    agentPhone?: boolean
    agentEmail?: boolean
    playerPhone?: boolean
    playerEmail?: boolean
    instagram?: boolean
    videos?: boolean
    notes?: boolean
    rating?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | ScoutingPlayer$teamArgs<ExtArgs>
    categoria?: boolean | ScoutingPlayer$categoriaArgs<ExtArgs>
  }, ExtArgs["result"]["scoutingPlayer"]>

  export type ScoutingPlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    fullName?: boolean
    positions?: boolean
    club?: boolean
    estado?: boolean
    categoriaId?: boolean
    agentName?: boolean
    agentPhone?: boolean
    agentEmail?: boolean
    playerPhone?: boolean
    playerEmail?: boolean
    instagram?: boolean
    videos?: boolean
    notes?: boolean
    rating?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | ScoutingPlayer$teamArgs<ExtArgs>
    categoria?: boolean | ScoutingPlayer$categoriaArgs<ExtArgs>
  }, ExtArgs["result"]["scoutingPlayer"]>

  export type ScoutingPlayerSelectScalar = {
    id?: boolean
    teamId?: boolean
    fullName?: boolean
    positions?: boolean
    club?: boolean
    estado?: boolean
    categoriaId?: boolean
    agentName?: boolean
    agentPhone?: boolean
    agentEmail?: boolean
    playerPhone?: boolean
    playerEmail?: boolean
    instagram?: boolean
    videos?: boolean
    notes?: boolean
    rating?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScoutingPlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | ScoutingPlayer$teamArgs<ExtArgs>
    categoria?: boolean | ScoutingPlayer$categoriaArgs<ExtArgs>
  }
  export type ScoutingPlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | ScoutingPlayer$teamArgs<ExtArgs>
    categoria?: boolean | ScoutingPlayer$categoriaArgs<ExtArgs>
  }

  export type $ScoutingPlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScoutingPlayer"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs> | null
      categoria: Prisma.$ScoutingCategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string | null
      fullName: string
      positions: string[]
      club: string | null
      estado: $Enums.ScoutingStatus
      categoriaId: string | null
      agentName: string | null
      agentPhone: string | null
      agentEmail: string | null
      playerPhone: string | null
      playerEmail: string | null
      instagram: string | null
      videos: string[]
      notes: string | null
      rating: number | null
      tags: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scoutingPlayer"]>
    composites: {}
  }

  type ScoutingPlayerGetPayload<S extends boolean | null | undefined | ScoutingPlayerDefaultArgs> = $Result.GetResult<Prisma.$ScoutingPlayerPayload, S>

  type ScoutingPlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScoutingPlayerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScoutingPlayerCountAggregateInputType | true
    }

  export interface ScoutingPlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScoutingPlayer'], meta: { name: 'ScoutingPlayer' } }
    /**
     * Find zero or one ScoutingPlayer that matches the filter.
     * @param {ScoutingPlayerFindUniqueArgs} args - Arguments to find a ScoutingPlayer
     * @example
     * // Get one ScoutingPlayer
     * const scoutingPlayer = await prisma.scoutingPlayer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScoutingPlayerFindUniqueArgs>(args: SelectSubset<T, ScoutingPlayerFindUniqueArgs<ExtArgs>>): Prisma__ScoutingPlayerClient<$Result.GetResult<Prisma.$ScoutingPlayerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScoutingPlayer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScoutingPlayerFindUniqueOrThrowArgs} args - Arguments to find a ScoutingPlayer
     * @example
     * // Get one ScoutingPlayer
     * const scoutingPlayer = await prisma.scoutingPlayer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScoutingPlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, ScoutingPlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScoutingPlayerClient<$Result.GetResult<Prisma.$ScoutingPlayerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScoutingPlayer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutingPlayerFindFirstArgs} args - Arguments to find a ScoutingPlayer
     * @example
     * // Get one ScoutingPlayer
     * const scoutingPlayer = await prisma.scoutingPlayer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScoutingPlayerFindFirstArgs>(args?: SelectSubset<T, ScoutingPlayerFindFirstArgs<ExtArgs>>): Prisma__ScoutingPlayerClient<$Result.GetResult<Prisma.$ScoutingPlayerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScoutingPlayer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutingPlayerFindFirstOrThrowArgs} args - Arguments to find a ScoutingPlayer
     * @example
     * // Get one ScoutingPlayer
     * const scoutingPlayer = await prisma.scoutingPlayer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScoutingPlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, ScoutingPlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScoutingPlayerClient<$Result.GetResult<Prisma.$ScoutingPlayerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScoutingPlayers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutingPlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScoutingPlayers
     * const scoutingPlayers = await prisma.scoutingPlayer.findMany()
     * 
     * // Get first 10 ScoutingPlayers
     * const scoutingPlayers = await prisma.scoutingPlayer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scoutingPlayerWithIdOnly = await prisma.scoutingPlayer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScoutingPlayerFindManyArgs>(args?: SelectSubset<T, ScoutingPlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScoutingPlayerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScoutingPlayer.
     * @param {ScoutingPlayerCreateArgs} args - Arguments to create a ScoutingPlayer.
     * @example
     * // Create one ScoutingPlayer
     * const ScoutingPlayer = await prisma.scoutingPlayer.create({
     *   data: {
     *     // ... data to create a ScoutingPlayer
     *   }
     * })
     * 
     */
    create<T extends ScoutingPlayerCreateArgs>(args: SelectSubset<T, ScoutingPlayerCreateArgs<ExtArgs>>): Prisma__ScoutingPlayerClient<$Result.GetResult<Prisma.$ScoutingPlayerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScoutingPlayers.
     * @param {ScoutingPlayerCreateManyArgs} args - Arguments to create many ScoutingPlayers.
     * @example
     * // Create many ScoutingPlayers
     * const scoutingPlayer = await prisma.scoutingPlayer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScoutingPlayerCreateManyArgs>(args?: SelectSubset<T, ScoutingPlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScoutingPlayers and returns the data saved in the database.
     * @param {ScoutingPlayerCreateManyAndReturnArgs} args - Arguments to create many ScoutingPlayers.
     * @example
     * // Create many ScoutingPlayers
     * const scoutingPlayer = await prisma.scoutingPlayer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScoutingPlayers and only return the `id`
     * const scoutingPlayerWithIdOnly = await prisma.scoutingPlayer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScoutingPlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, ScoutingPlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScoutingPlayerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScoutingPlayer.
     * @param {ScoutingPlayerDeleteArgs} args - Arguments to delete one ScoutingPlayer.
     * @example
     * // Delete one ScoutingPlayer
     * const ScoutingPlayer = await prisma.scoutingPlayer.delete({
     *   where: {
     *     // ... filter to delete one ScoutingPlayer
     *   }
     * })
     * 
     */
    delete<T extends ScoutingPlayerDeleteArgs>(args: SelectSubset<T, ScoutingPlayerDeleteArgs<ExtArgs>>): Prisma__ScoutingPlayerClient<$Result.GetResult<Prisma.$ScoutingPlayerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScoutingPlayer.
     * @param {ScoutingPlayerUpdateArgs} args - Arguments to update one ScoutingPlayer.
     * @example
     * // Update one ScoutingPlayer
     * const scoutingPlayer = await prisma.scoutingPlayer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScoutingPlayerUpdateArgs>(args: SelectSubset<T, ScoutingPlayerUpdateArgs<ExtArgs>>): Prisma__ScoutingPlayerClient<$Result.GetResult<Prisma.$ScoutingPlayerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScoutingPlayers.
     * @param {ScoutingPlayerDeleteManyArgs} args - Arguments to filter ScoutingPlayers to delete.
     * @example
     * // Delete a few ScoutingPlayers
     * const { count } = await prisma.scoutingPlayer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScoutingPlayerDeleteManyArgs>(args?: SelectSubset<T, ScoutingPlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScoutingPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutingPlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScoutingPlayers
     * const scoutingPlayer = await prisma.scoutingPlayer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScoutingPlayerUpdateManyArgs>(args: SelectSubset<T, ScoutingPlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScoutingPlayer.
     * @param {ScoutingPlayerUpsertArgs} args - Arguments to update or create a ScoutingPlayer.
     * @example
     * // Update or create a ScoutingPlayer
     * const scoutingPlayer = await prisma.scoutingPlayer.upsert({
     *   create: {
     *     // ... data to create a ScoutingPlayer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScoutingPlayer we want to update
     *   }
     * })
     */
    upsert<T extends ScoutingPlayerUpsertArgs>(args: SelectSubset<T, ScoutingPlayerUpsertArgs<ExtArgs>>): Prisma__ScoutingPlayerClient<$Result.GetResult<Prisma.$ScoutingPlayerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScoutingPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutingPlayerCountArgs} args - Arguments to filter ScoutingPlayers to count.
     * @example
     * // Count the number of ScoutingPlayers
     * const count = await prisma.scoutingPlayer.count({
     *   where: {
     *     // ... the filter for the ScoutingPlayers we want to count
     *   }
     * })
    **/
    count<T extends ScoutingPlayerCountArgs>(
      args?: Subset<T, ScoutingPlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScoutingPlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScoutingPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutingPlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScoutingPlayerAggregateArgs>(args: Subset<T, ScoutingPlayerAggregateArgs>): Prisma.PrismaPromise<GetScoutingPlayerAggregateType<T>>

    /**
     * Group by ScoutingPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoutingPlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScoutingPlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScoutingPlayerGroupByArgs['orderBy'] }
        : { orderBy?: ScoutingPlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScoutingPlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScoutingPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScoutingPlayer model
   */
  readonly fields: ScoutingPlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScoutingPlayer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScoutingPlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends ScoutingPlayer$teamArgs<ExtArgs> = {}>(args?: Subset<T, ScoutingPlayer$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    categoria<T extends ScoutingPlayer$categoriaArgs<ExtArgs> = {}>(args?: Subset<T, ScoutingPlayer$categoriaArgs<ExtArgs>>): Prisma__ScoutingCategoryClient<$Result.GetResult<Prisma.$ScoutingCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScoutingPlayer model
   */ 
  interface ScoutingPlayerFieldRefs {
    readonly id: FieldRef<"ScoutingPlayer", 'String'>
    readonly teamId: FieldRef<"ScoutingPlayer", 'String'>
    readonly fullName: FieldRef<"ScoutingPlayer", 'String'>
    readonly positions: FieldRef<"ScoutingPlayer", 'String[]'>
    readonly club: FieldRef<"ScoutingPlayer", 'String'>
    readonly estado: FieldRef<"ScoutingPlayer", 'ScoutingStatus'>
    readonly categoriaId: FieldRef<"ScoutingPlayer", 'String'>
    readonly agentName: FieldRef<"ScoutingPlayer", 'String'>
    readonly agentPhone: FieldRef<"ScoutingPlayer", 'String'>
    readonly agentEmail: FieldRef<"ScoutingPlayer", 'String'>
    readonly playerPhone: FieldRef<"ScoutingPlayer", 'String'>
    readonly playerEmail: FieldRef<"ScoutingPlayer", 'String'>
    readonly instagram: FieldRef<"ScoutingPlayer", 'String'>
    readonly videos: FieldRef<"ScoutingPlayer", 'String[]'>
    readonly notes: FieldRef<"ScoutingPlayer", 'String'>
    readonly rating: FieldRef<"ScoutingPlayer", 'Int'>
    readonly tags: FieldRef<"ScoutingPlayer", 'String[]'>
    readonly createdAt: FieldRef<"ScoutingPlayer", 'DateTime'>
    readonly updatedAt: FieldRef<"ScoutingPlayer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScoutingPlayer findUnique
   */
  export type ScoutingPlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingPlayer
     */
    select?: ScoutingPlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingPlayerInclude<ExtArgs> | null
    /**
     * Filter, which ScoutingPlayer to fetch.
     */
    where: ScoutingPlayerWhereUniqueInput
  }

  /**
   * ScoutingPlayer findUniqueOrThrow
   */
  export type ScoutingPlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingPlayer
     */
    select?: ScoutingPlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingPlayerInclude<ExtArgs> | null
    /**
     * Filter, which ScoutingPlayer to fetch.
     */
    where: ScoutingPlayerWhereUniqueInput
  }

  /**
   * ScoutingPlayer findFirst
   */
  export type ScoutingPlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingPlayer
     */
    select?: ScoutingPlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingPlayerInclude<ExtArgs> | null
    /**
     * Filter, which ScoutingPlayer to fetch.
     */
    where?: ScoutingPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoutingPlayers to fetch.
     */
    orderBy?: ScoutingPlayerOrderByWithRelationInput | ScoutingPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScoutingPlayers.
     */
    cursor?: ScoutingPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoutingPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoutingPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScoutingPlayers.
     */
    distinct?: ScoutingPlayerScalarFieldEnum | ScoutingPlayerScalarFieldEnum[]
  }

  /**
   * ScoutingPlayer findFirstOrThrow
   */
  export type ScoutingPlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingPlayer
     */
    select?: ScoutingPlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingPlayerInclude<ExtArgs> | null
    /**
     * Filter, which ScoutingPlayer to fetch.
     */
    where?: ScoutingPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoutingPlayers to fetch.
     */
    orderBy?: ScoutingPlayerOrderByWithRelationInput | ScoutingPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScoutingPlayers.
     */
    cursor?: ScoutingPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoutingPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoutingPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScoutingPlayers.
     */
    distinct?: ScoutingPlayerScalarFieldEnum | ScoutingPlayerScalarFieldEnum[]
  }

  /**
   * ScoutingPlayer findMany
   */
  export type ScoutingPlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingPlayer
     */
    select?: ScoutingPlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingPlayerInclude<ExtArgs> | null
    /**
     * Filter, which ScoutingPlayers to fetch.
     */
    where?: ScoutingPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScoutingPlayers to fetch.
     */
    orderBy?: ScoutingPlayerOrderByWithRelationInput | ScoutingPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScoutingPlayers.
     */
    cursor?: ScoutingPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScoutingPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScoutingPlayers.
     */
    skip?: number
    distinct?: ScoutingPlayerScalarFieldEnum | ScoutingPlayerScalarFieldEnum[]
  }

  /**
   * ScoutingPlayer create
   */
  export type ScoutingPlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingPlayer
     */
    select?: ScoutingPlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingPlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a ScoutingPlayer.
     */
    data: XOR<ScoutingPlayerCreateInput, ScoutingPlayerUncheckedCreateInput>
  }

  /**
   * ScoutingPlayer createMany
   */
  export type ScoutingPlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScoutingPlayers.
     */
    data: ScoutingPlayerCreateManyInput | ScoutingPlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScoutingPlayer createManyAndReturn
   */
  export type ScoutingPlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingPlayer
     */
    select?: ScoutingPlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScoutingPlayers.
     */
    data: ScoutingPlayerCreateManyInput | ScoutingPlayerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingPlayerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScoutingPlayer update
   */
  export type ScoutingPlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingPlayer
     */
    select?: ScoutingPlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingPlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a ScoutingPlayer.
     */
    data: XOR<ScoutingPlayerUpdateInput, ScoutingPlayerUncheckedUpdateInput>
    /**
     * Choose, which ScoutingPlayer to update.
     */
    where: ScoutingPlayerWhereUniqueInput
  }

  /**
   * ScoutingPlayer updateMany
   */
  export type ScoutingPlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScoutingPlayers.
     */
    data: XOR<ScoutingPlayerUpdateManyMutationInput, ScoutingPlayerUncheckedUpdateManyInput>
    /**
     * Filter which ScoutingPlayers to update
     */
    where?: ScoutingPlayerWhereInput
  }

  /**
   * ScoutingPlayer upsert
   */
  export type ScoutingPlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingPlayer
     */
    select?: ScoutingPlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingPlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the ScoutingPlayer to update in case it exists.
     */
    where: ScoutingPlayerWhereUniqueInput
    /**
     * In case the ScoutingPlayer found by the `where` argument doesn't exist, create a new ScoutingPlayer with this data.
     */
    create: XOR<ScoutingPlayerCreateInput, ScoutingPlayerUncheckedCreateInput>
    /**
     * In case the ScoutingPlayer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScoutingPlayerUpdateInput, ScoutingPlayerUncheckedUpdateInput>
  }

  /**
   * ScoutingPlayer delete
   */
  export type ScoutingPlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingPlayer
     */
    select?: ScoutingPlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingPlayerInclude<ExtArgs> | null
    /**
     * Filter which ScoutingPlayer to delete.
     */
    where: ScoutingPlayerWhereUniqueInput
  }

  /**
   * ScoutingPlayer deleteMany
   */
  export type ScoutingPlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScoutingPlayers to delete
     */
    where?: ScoutingPlayerWhereInput
  }

  /**
   * ScoutingPlayer.team
   */
  export type ScoutingPlayer$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * ScoutingPlayer.categoria
   */
  export type ScoutingPlayer$categoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingCategory
     */
    select?: ScoutingCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingCategoryInclude<ExtArgs> | null
    where?: ScoutingCategoryWhereInput
  }

  /**
   * ScoutingPlayer without action
   */
  export type ScoutingPlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScoutingPlayer
     */
    select?: ScoutingPlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoutingPlayerInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    title: string | null
    summary: string | null
    content: string | null
    type: string | null
    authorId: string | null
    visibleToDirectivo: boolean | null
    createdAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    title: string | null
    summary: string | null
    content: string | null
    type: string | null
    authorId: string | null
    visibleToDirectivo: boolean | null
    createdAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    teamId: number
    title: number
    summary: number
    content: number
    type: number
    authorId: number
    visibleToDirectivo: number
    createdAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    teamId?: true
    title?: true
    summary?: true
    content?: true
    type?: true
    authorId?: true
    visibleToDirectivo?: true
    createdAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    teamId?: true
    title?: true
    summary?: true
    content?: true
    type?: true
    authorId?: true
    visibleToDirectivo?: true
    createdAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    teamId?: true
    title?: true
    summary?: true
    content?: true
    type?: true
    authorId?: true
    visibleToDirectivo?: true
    createdAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    teamId: string
    title: string
    summary: string | null
    content: string
    type: string
    authorId: string
    visibleToDirectivo: boolean
    createdAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    title?: boolean
    summary?: boolean
    content?: boolean
    type?: boolean
    authorId?: boolean
    visibleToDirectivo?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    title?: boolean
    summary?: boolean
    content?: boolean
    type?: boolean
    authorId?: boolean
    visibleToDirectivo?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    teamId?: boolean
    title?: boolean
    summary?: boolean
    content?: boolean
    type?: boolean
    authorId?: boolean
    visibleToDirectivo?: boolean
    createdAt?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      title: string
      summary: string | null
      content: string
      type: string
      authorId: string
      visibleToDirectivo: boolean
      createdAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly teamId: FieldRef<"Report", 'String'>
    readonly title: FieldRef<"Report", 'String'>
    readonly summary: FieldRef<"Report", 'String'>
    readonly content: FieldRef<"Report", 'String'>
    readonly type: FieldRef<"Report", 'String'>
    readonly authorId: FieldRef<"Report", 'String'>
    readonly visibleToDirectivo: FieldRef<"Report", 'Boolean'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model TeamVideo
   */

  export type AggregateTeamVideo = {
    _count: TeamVideoCountAggregateOutputType | null
    _min: TeamVideoMinAggregateOutputType | null
    _max: TeamVideoMaxAggregateOutputType | null
  }

  export type TeamVideoMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    url: string | null
    title: string | null
    notes: string | null
    type: string | null
    visibleToDirectivo: boolean | null
    createdAt: Date | null
  }

  export type TeamVideoMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    url: string | null
    title: string | null
    notes: string | null
    type: string | null
    visibleToDirectivo: boolean | null
    createdAt: Date | null
  }

  export type TeamVideoCountAggregateOutputType = {
    id: number
    teamId: number
    url: number
    title: number
    notes: number
    type: number
    visibleToDirectivo: number
    createdAt: number
    _all: number
  }


  export type TeamVideoMinAggregateInputType = {
    id?: true
    teamId?: true
    url?: true
    title?: true
    notes?: true
    type?: true
    visibleToDirectivo?: true
    createdAt?: true
  }

  export type TeamVideoMaxAggregateInputType = {
    id?: true
    teamId?: true
    url?: true
    title?: true
    notes?: true
    type?: true
    visibleToDirectivo?: true
    createdAt?: true
  }

  export type TeamVideoCountAggregateInputType = {
    id?: true
    teamId?: true
    url?: true
    title?: true
    notes?: true
    type?: true
    visibleToDirectivo?: true
    createdAt?: true
    _all?: true
  }

  export type TeamVideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamVideo to aggregate.
     */
    where?: TeamVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamVideos to fetch.
     */
    orderBy?: TeamVideoOrderByWithRelationInput | TeamVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamVideos
    **/
    _count?: true | TeamVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamVideoMaxAggregateInputType
  }

  export type GetTeamVideoAggregateType<T extends TeamVideoAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamVideo[P]>
      : GetScalarType<T[P], AggregateTeamVideo[P]>
  }




  export type TeamVideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamVideoWhereInput
    orderBy?: TeamVideoOrderByWithAggregationInput | TeamVideoOrderByWithAggregationInput[]
    by: TeamVideoScalarFieldEnum[] | TeamVideoScalarFieldEnum
    having?: TeamVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamVideoCountAggregateInputType | true
    _min?: TeamVideoMinAggregateInputType
    _max?: TeamVideoMaxAggregateInputType
  }

  export type TeamVideoGroupByOutputType = {
    id: string
    teamId: string
    url: string
    title: string
    notes: string | null
    type: string
    visibleToDirectivo: boolean
    createdAt: Date
    _count: TeamVideoCountAggregateOutputType | null
    _min: TeamVideoMinAggregateOutputType | null
    _max: TeamVideoMaxAggregateOutputType | null
  }

  type GetTeamVideoGroupByPayload<T extends TeamVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamVideoGroupByOutputType[P]>
            : GetScalarType<T[P], TeamVideoGroupByOutputType[P]>
        }
      >
    >


  export type TeamVideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    url?: boolean
    title?: boolean
    notes?: boolean
    type?: boolean
    visibleToDirectivo?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamVideo"]>

  export type TeamVideoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    url?: boolean
    title?: boolean
    notes?: boolean
    type?: boolean
    visibleToDirectivo?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamVideo"]>

  export type TeamVideoSelectScalar = {
    id?: boolean
    teamId?: boolean
    url?: boolean
    title?: boolean
    notes?: boolean
    type?: boolean
    visibleToDirectivo?: boolean
    createdAt?: boolean
  }

  export type TeamVideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type TeamVideoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $TeamVideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamVideo"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      url: string
      title: string
      notes: string | null
      type: string
      visibleToDirectivo: boolean
      createdAt: Date
    }, ExtArgs["result"]["teamVideo"]>
    composites: {}
  }

  type TeamVideoGetPayload<S extends boolean | null | undefined | TeamVideoDefaultArgs> = $Result.GetResult<Prisma.$TeamVideoPayload, S>

  type TeamVideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamVideoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamVideoCountAggregateInputType | true
    }

  export interface TeamVideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamVideo'], meta: { name: 'TeamVideo' } }
    /**
     * Find zero or one TeamVideo that matches the filter.
     * @param {TeamVideoFindUniqueArgs} args - Arguments to find a TeamVideo
     * @example
     * // Get one TeamVideo
     * const teamVideo = await prisma.teamVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamVideoFindUniqueArgs>(args: SelectSubset<T, TeamVideoFindUniqueArgs<ExtArgs>>): Prisma__TeamVideoClient<$Result.GetResult<Prisma.$TeamVideoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeamVideo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamVideoFindUniqueOrThrowArgs} args - Arguments to find a TeamVideo
     * @example
     * // Get one TeamVideo
     * const teamVideo = await prisma.teamVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamVideoFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamVideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamVideoClient<$Result.GetResult<Prisma.$TeamVideoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeamVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamVideoFindFirstArgs} args - Arguments to find a TeamVideo
     * @example
     * // Get one TeamVideo
     * const teamVideo = await prisma.teamVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamVideoFindFirstArgs>(args?: SelectSubset<T, TeamVideoFindFirstArgs<ExtArgs>>): Prisma__TeamVideoClient<$Result.GetResult<Prisma.$TeamVideoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeamVideo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamVideoFindFirstOrThrowArgs} args - Arguments to find a TeamVideo
     * @example
     * // Get one TeamVideo
     * const teamVideo = await prisma.teamVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamVideoFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamVideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamVideoClient<$Result.GetResult<Prisma.$TeamVideoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeamVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamVideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamVideos
     * const teamVideos = await prisma.teamVideo.findMany()
     * 
     * // Get first 10 TeamVideos
     * const teamVideos = await prisma.teamVideo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamVideoWithIdOnly = await prisma.teamVideo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamVideoFindManyArgs>(args?: SelectSubset<T, TeamVideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamVideoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeamVideo.
     * @param {TeamVideoCreateArgs} args - Arguments to create a TeamVideo.
     * @example
     * // Create one TeamVideo
     * const TeamVideo = await prisma.teamVideo.create({
     *   data: {
     *     // ... data to create a TeamVideo
     *   }
     * })
     * 
     */
    create<T extends TeamVideoCreateArgs>(args: SelectSubset<T, TeamVideoCreateArgs<ExtArgs>>): Prisma__TeamVideoClient<$Result.GetResult<Prisma.$TeamVideoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeamVideos.
     * @param {TeamVideoCreateManyArgs} args - Arguments to create many TeamVideos.
     * @example
     * // Create many TeamVideos
     * const teamVideo = await prisma.teamVideo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamVideoCreateManyArgs>(args?: SelectSubset<T, TeamVideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamVideos and returns the data saved in the database.
     * @param {TeamVideoCreateManyAndReturnArgs} args - Arguments to create many TeamVideos.
     * @example
     * // Create many TeamVideos
     * const teamVideo = await prisma.teamVideo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamVideos and only return the `id`
     * const teamVideoWithIdOnly = await prisma.teamVideo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamVideoCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamVideoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamVideoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TeamVideo.
     * @param {TeamVideoDeleteArgs} args - Arguments to delete one TeamVideo.
     * @example
     * // Delete one TeamVideo
     * const TeamVideo = await prisma.teamVideo.delete({
     *   where: {
     *     // ... filter to delete one TeamVideo
     *   }
     * })
     * 
     */
    delete<T extends TeamVideoDeleteArgs>(args: SelectSubset<T, TeamVideoDeleteArgs<ExtArgs>>): Prisma__TeamVideoClient<$Result.GetResult<Prisma.$TeamVideoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeamVideo.
     * @param {TeamVideoUpdateArgs} args - Arguments to update one TeamVideo.
     * @example
     * // Update one TeamVideo
     * const teamVideo = await prisma.teamVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamVideoUpdateArgs>(args: SelectSubset<T, TeamVideoUpdateArgs<ExtArgs>>): Prisma__TeamVideoClient<$Result.GetResult<Prisma.$TeamVideoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeamVideos.
     * @param {TeamVideoDeleteManyArgs} args - Arguments to filter TeamVideos to delete.
     * @example
     * // Delete a few TeamVideos
     * const { count } = await prisma.teamVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamVideoDeleteManyArgs>(args?: SelectSubset<T, TeamVideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamVideos
     * const teamVideo = await prisma.teamVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamVideoUpdateManyArgs>(args: SelectSubset<T, TeamVideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamVideo.
     * @param {TeamVideoUpsertArgs} args - Arguments to update or create a TeamVideo.
     * @example
     * // Update or create a TeamVideo
     * const teamVideo = await prisma.teamVideo.upsert({
     *   create: {
     *     // ... data to create a TeamVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamVideo we want to update
     *   }
     * })
     */
    upsert<T extends TeamVideoUpsertArgs>(args: SelectSubset<T, TeamVideoUpsertArgs<ExtArgs>>): Prisma__TeamVideoClient<$Result.GetResult<Prisma.$TeamVideoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeamVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamVideoCountArgs} args - Arguments to filter TeamVideos to count.
     * @example
     * // Count the number of TeamVideos
     * const count = await prisma.teamVideo.count({
     *   where: {
     *     // ... the filter for the TeamVideos we want to count
     *   }
     * })
    **/
    count<T extends TeamVideoCountArgs>(
      args?: Subset<T, TeamVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamVideoAggregateArgs>(args: Subset<T, TeamVideoAggregateArgs>): Prisma.PrismaPromise<GetTeamVideoAggregateType<T>>

    /**
     * Group by TeamVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamVideoGroupByArgs['orderBy'] }
        : { orderBy?: TeamVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamVideo model
   */
  readonly fields: TeamVideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamVideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamVideo model
   */ 
  interface TeamVideoFieldRefs {
    readonly id: FieldRef<"TeamVideo", 'String'>
    readonly teamId: FieldRef<"TeamVideo", 'String'>
    readonly url: FieldRef<"TeamVideo", 'String'>
    readonly title: FieldRef<"TeamVideo", 'String'>
    readonly notes: FieldRef<"TeamVideo", 'String'>
    readonly type: FieldRef<"TeamVideo", 'String'>
    readonly visibleToDirectivo: FieldRef<"TeamVideo", 'Boolean'>
    readonly createdAt: FieldRef<"TeamVideo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamVideo findUnique
   */
  export type TeamVideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamVideo
     */
    select?: TeamVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamVideoInclude<ExtArgs> | null
    /**
     * Filter, which TeamVideo to fetch.
     */
    where: TeamVideoWhereUniqueInput
  }

  /**
   * TeamVideo findUniqueOrThrow
   */
  export type TeamVideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamVideo
     */
    select?: TeamVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamVideoInclude<ExtArgs> | null
    /**
     * Filter, which TeamVideo to fetch.
     */
    where: TeamVideoWhereUniqueInput
  }

  /**
   * TeamVideo findFirst
   */
  export type TeamVideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamVideo
     */
    select?: TeamVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamVideoInclude<ExtArgs> | null
    /**
     * Filter, which TeamVideo to fetch.
     */
    where?: TeamVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamVideos to fetch.
     */
    orderBy?: TeamVideoOrderByWithRelationInput | TeamVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamVideos.
     */
    cursor?: TeamVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamVideos.
     */
    distinct?: TeamVideoScalarFieldEnum | TeamVideoScalarFieldEnum[]
  }

  /**
   * TeamVideo findFirstOrThrow
   */
  export type TeamVideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamVideo
     */
    select?: TeamVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamVideoInclude<ExtArgs> | null
    /**
     * Filter, which TeamVideo to fetch.
     */
    where?: TeamVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamVideos to fetch.
     */
    orderBy?: TeamVideoOrderByWithRelationInput | TeamVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamVideos.
     */
    cursor?: TeamVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamVideos.
     */
    distinct?: TeamVideoScalarFieldEnum | TeamVideoScalarFieldEnum[]
  }

  /**
   * TeamVideo findMany
   */
  export type TeamVideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamVideo
     */
    select?: TeamVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamVideoInclude<ExtArgs> | null
    /**
     * Filter, which TeamVideos to fetch.
     */
    where?: TeamVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamVideos to fetch.
     */
    orderBy?: TeamVideoOrderByWithRelationInput | TeamVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamVideos.
     */
    cursor?: TeamVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamVideos.
     */
    skip?: number
    distinct?: TeamVideoScalarFieldEnum | TeamVideoScalarFieldEnum[]
  }

  /**
   * TeamVideo create
   */
  export type TeamVideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamVideo
     */
    select?: TeamVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamVideoInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamVideo.
     */
    data: XOR<TeamVideoCreateInput, TeamVideoUncheckedCreateInput>
  }

  /**
   * TeamVideo createMany
   */
  export type TeamVideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamVideos.
     */
    data: TeamVideoCreateManyInput | TeamVideoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamVideo createManyAndReturn
   */
  export type TeamVideoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamVideo
     */
    select?: TeamVideoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TeamVideos.
     */
    data: TeamVideoCreateManyInput | TeamVideoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamVideoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamVideo update
   */
  export type TeamVideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamVideo
     */
    select?: TeamVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamVideoInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamVideo.
     */
    data: XOR<TeamVideoUpdateInput, TeamVideoUncheckedUpdateInput>
    /**
     * Choose, which TeamVideo to update.
     */
    where: TeamVideoWhereUniqueInput
  }

  /**
   * TeamVideo updateMany
   */
  export type TeamVideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamVideos.
     */
    data: XOR<TeamVideoUpdateManyMutationInput, TeamVideoUncheckedUpdateManyInput>
    /**
     * Filter which TeamVideos to update
     */
    where?: TeamVideoWhereInput
  }

  /**
   * TeamVideo upsert
   */
  export type TeamVideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamVideo
     */
    select?: TeamVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamVideoInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamVideo to update in case it exists.
     */
    where: TeamVideoWhereUniqueInput
    /**
     * In case the TeamVideo found by the `where` argument doesn't exist, create a new TeamVideo with this data.
     */
    create: XOR<TeamVideoCreateInput, TeamVideoUncheckedCreateInput>
    /**
     * In case the TeamVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamVideoUpdateInput, TeamVideoUncheckedUpdateInput>
  }

  /**
   * TeamVideo delete
   */
  export type TeamVideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamVideo
     */
    select?: TeamVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamVideoInclude<ExtArgs> | null
    /**
     * Filter which TeamVideo to delete.
     */
    where: TeamVideoWhereUniqueInput
  }

  /**
   * TeamVideo deleteMany
   */
  export type TeamVideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamVideos to delete
     */
    where?: TeamVideoWhereInput
  }

  /**
   * TeamVideo without action
   */
  export type TeamVideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamVideo
     */
    select?: TeamVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamVideoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    isActive: 'isActive',
    logoUrl: 'logoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const GlobalConfigScalarFieldEnum: {
    id: 'id',
    systemName: 'systemName',
    logoUrl: 'logoUrl',
    mainColor: 'mainColor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GlobalConfigScalarFieldEnum = (typeof GlobalConfigScalarFieldEnum)[keyof typeof GlobalConfigScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    passwordHash: 'passwordHash',
    role: 'role',
    isApproved: 'isApproved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserTeamScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    teamId: 'teamId',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type UserTeamScalarFieldEnum = (typeof UserTeamScalarFieldEnum)[keyof typeof UserTeamScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    date: 'date',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    teamId: 'teamId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const RivalScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    name: 'name',
    logoUrl: 'logoUrl',
    coach: 'coach',
    baseSystem: 'baseSystem',
    nextMatchDate: 'nextMatchDate',
    nextMatchCompetition: 'nextMatchCompetition',
    planCharlaUrl: 'planCharlaUrl',
    planReport: 'planReport',
    planVideos: 'planVideos',
    planStats: 'planStats',
    planNotes: 'planNotes',
    planVisibility: 'planVisibility',
    planSquad: 'planSquad',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RivalScalarFieldEnum = (typeof RivalScalarFieldEnum)[keyof typeof RivalScalarFieldEnum]


  export const PlayerFeedbackScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    playerId: 'playerId',
    subject: 'subject',
    text: 'text',
    rating: 'rating',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type PlayerFeedbackScalarFieldEnum = (typeof PlayerFeedbackScalarFieldEnum)[keyof typeof PlayerFeedbackScalarFieldEnum]


  export const PlaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    teamId: 'teamId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlaceScalarFieldEnum = (typeof PlaceScalarFieldEnum)[keyof typeof PlaceScalarFieldEnum]


  export const ExerciseKindScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExerciseKindScalarFieldEnum = (typeof ExerciseKindScalarFieldEnum)[keyof typeof ExerciseKindScalarFieldEnum]


  export const ExerciseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    kindId: 'kindId',
    space: 'space',
    players: 'players',
    duration: 'duration',
    description: 'description',
    imageUrl: 'imageUrl',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExerciseScalarFieldEnum = (typeof ExerciseScalarFieldEnum)[keyof typeof ExerciseScalarFieldEnum]


  export const RPEEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    session: 'session',
    sessionLabel: 'sessionLabel',
    sessionUid: 'sessionUid',
    rpe: 'rpe',
    duration: 'duration',
    load: 'load',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RPEEntryScalarFieldEnum = (typeof RPEEntryScalarFieldEnum)[keyof typeof RPEEntryScalarFieldEnum]


  export const WellnessEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    sleepQuality: 'sleepQuality',
    sleepHours: 'sleepHours',
    fatigue: 'fatigue',
    muscleSoreness: 'muscleSoreness',
    stress: 'stress',
    mood: 'mood',
    comment: 'comment',
    total: 'total',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WellnessEntryScalarFieldEnum = (typeof WellnessEntryScalarFieldEnum)[keyof typeof WellnessEntryScalarFieldEnum]


  export const PlannerPrefsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    teamId: 'teamId',
    rowLabels: 'rowLabels',
    places: 'places',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlannerPrefsScalarFieldEnum = (typeof PlannerPrefsScalarFieldEnum)[keyof typeof PlannerPrefsScalarFieldEnum]


  export const ClinicalEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    status: 'status',
    leaveStage: 'leaveStage',
    leaveKind: 'leaveKind',
    diagnosis: 'diagnosis',
    bodyPart: 'bodyPart',
    laterality: 'laterality',
    mechanism: 'mechanism',
    severity: 'severity',
    illSystem: 'illSystem',
    illSymptoms: 'illSymptoms',
    illContagious: 'illContagious',
    illIsolationDays: 'illIsolationDays',
    illAptitude: 'illAptitude',
    feverMax: 'feverMax',
    startDate: 'startDate',
    daysPlanned: 'daysPlanned',
    expectedReturn: 'expectedReturn',
    expectedReturnManual: 'expectedReturnManual',
    capMinutes: 'capMinutes',
    noSprint: 'noSprint',
    noChangeOfDirection: 'noChangeOfDirection',
    gymOnly: 'gymOnly',
    noContact: 'noContact',
    notes: 'notes',
    medSignature: 'medSignature',
    protocolObjectives: 'protocolObjectives',
    protocolTasks: 'protocolTasks',
    protocolControls: 'protocolControls',
    protocolCriteria: 'protocolCriteria',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClinicalEntryScalarFieldEnum = (typeof ClinicalEntryScalarFieldEnum)[keyof typeof ClinicalEntryScalarFieldEnum]


  export const ScoutingCategoryScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    nombre: 'nombre',
    slug: 'slug',
    orden: 'orden',
    color: 'color',
    activa: 'activa',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScoutingCategoryScalarFieldEnum = (typeof ScoutingCategoryScalarFieldEnum)[keyof typeof ScoutingCategoryScalarFieldEnum]


  export const PlayerScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    userId: 'userId',
    name: 'name',
    shirtNumber: 'shirtNumber',
    position: 'position',
    photoUrl: 'photoUrl',
    birthDate: 'birthDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerScalarFieldEnum = (typeof PlayerScalarFieldEnum)[keyof typeof PlayerScalarFieldEnum]


  export const ScoutingPlayerScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    fullName: 'fullName',
    positions: 'positions',
    club: 'club',
    estado: 'estado',
    categoriaId: 'categoriaId',
    agentName: 'agentName',
    agentPhone: 'agentPhone',
    agentEmail: 'agentEmail',
    playerPhone: 'playerPhone',
    playerEmail: 'playerEmail',
    instagram: 'instagram',
    videos: 'videos',
    notes: 'notes',
    rating: 'rating',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScoutingPlayerScalarFieldEnum = (typeof ScoutingPlayerScalarFieldEnum)[keyof typeof ScoutingPlayerScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    title: 'title',
    summary: 'summary',
    content: 'content',
    type: 'type',
    authorId: 'authorId',
    visibleToDirectivo: 'visibleToDirectivo',
    createdAt: 'createdAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const TeamVideoScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    url: 'url',
    title: 'title',
    notes: 'notes',
    type: 'type',
    visibleToDirectivo: 'visibleToDirectivo',
    createdAt: 'createdAt'
  };

  export type TeamVideoScalarFieldEnum = (typeof TeamVideoScalarFieldEnum)[keyof typeof TeamVideoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'TeamRole'
   */
  export type EnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamRole'>
    


  /**
   * Reference to a field of type 'TeamRole[]'
   */
  export type ListEnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamRole[]'>
    


  /**
   * Reference to a field of type 'SessionType'
   */
  export type EnumSessionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionType'>
    


  /**
   * Reference to a field of type 'SessionType[]'
   */
  export type ListEnumSessionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ClinicalStatus'
   */
  export type EnumClinicalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClinicalStatus'>
    


  /**
   * Reference to a field of type 'ClinicalStatus[]'
   */
  export type ListEnumClinicalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClinicalStatus[]'>
    


  /**
   * Reference to a field of type 'LeaveStage'
   */
  export type EnumLeaveStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStage'>
    


  /**
   * Reference to a field of type 'LeaveStage[]'
   */
  export type ListEnumLeaveStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStage[]'>
    


  /**
   * Reference to a field of type 'LeaveKind'
   */
  export type EnumLeaveKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveKind'>
    


  /**
   * Reference to a field of type 'LeaveKind[]'
   */
  export type ListEnumLeaveKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveKind[]'>
    


  /**
   * Reference to a field of type 'Laterality'
   */
  export type EnumLateralityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Laterality'>
    


  /**
   * Reference to a field of type 'Laterality[]'
   */
  export type ListEnumLateralityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Laterality[]'>
    


  /**
   * Reference to a field of type 'Mechanism'
   */
  export type EnumMechanismFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Mechanism'>
    


  /**
   * Reference to a field of type 'Mechanism[]'
   */
  export type ListEnumMechanismFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Mechanism[]'>
    


  /**
   * Reference to a field of type 'Severity'
   */
  export type EnumSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Severity'>
    


  /**
   * Reference to a field of type 'Severity[]'
   */
  export type ListEnumSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Severity[]'>
    


  /**
   * Reference to a field of type 'SystemAffected'
   */
  export type EnumSystemAffectedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SystemAffected'>
    


  /**
   * Reference to a field of type 'SystemAffected[]'
   */
  export type ListEnumSystemAffectedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SystemAffected[]'>
    


  /**
   * Reference to a field of type 'IllAptitude'
   */
  export type EnumIllAptitudeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IllAptitude'>
    


  /**
   * Reference to a field of type 'IllAptitude[]'
   */
  export type ListEnumIllAptitudeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IllAptitude[]'>
    


  /**
   * Reference to a field of type 'PlayerStatus'
   */
  export type EnumPlayerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlayerStatus'>
    


  /**
   * Reference to a field of type 'PlayerStatus[]'
   */
  export type ListEnumPlayerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlayerStatus[]'>
    


  /**
   * Reference to a field of type 'ScoutingStatus'
   */
  export type EnumScoutingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScoutingStatus'>
    


  /**
   * Reference to a field of type 'ScoutingStatus[]'
   */
  export type ListEnumScoutingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScoutingStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    slug?: StringFilter<"Team"> | string
    isActive?: BoolFilter<"Team"> | boolean
    logoUrl?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    members?: UserTeamListRelationFilter
    rivals?: RivalListRelationFilter
    feedback?: PlayerFeedbackListRelationFilter
    sessions?: SessionListRelationFilter
    places?: PlaceListRelationFilter
    plannerPrefs?: PlannerPrefsListRelationFilter
    scoutingCategories?: ScoutingCategoryListRelationFilter
    scoutingPlayers?: ScoutingPlayerListRelationFilter
    videos?: TeamVideoListRelationFilter
    reports?: ReportListRelationFilter
    players?: PlayerListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isActive?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: UserTeamOrderByRelationAggregateInput
    rivals?: RivalOrderByRelationAggregateInput
    feedback?: PlayerFeedbackOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    places?: PlaceOrderByRelationAggregateInput
    plannerPrefs?: PlannerPrefsOrderByRelationAggregateInput
    scoutingCategories?: ScoutingCategoryOrderByRelationAggregateInput
    scoutingPlayers?: ScoutingPlayerOrderByRelationAggregateInput
    videos?: TeamVideoOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    players?: PlayerOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    isActive?: BoolFilter<"Team"> | boolean
    logoUrl?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    members?: UserTeamListRelationFilter
    rivals?: RivalListRelationFilter
    feedback?: PlayerFeedbackListRelationFilter
    sessions?: SessionListRelationFilter
    places?: PlaceListRelationFilter
    plannerPrefs?: PlannerPrefsListRelationFilter
    scoutingCategories?: ScoutingCategoryListRelationFilter
    scoutingPlayers?: ScoutingPlayerListRelationFilter
    videos?: TeamVideoListRelationFilter
    reports?: ReportListRelationFilter
    players?: PlayerListRelationFilter
  }, "id" | "name" | "slug">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isActive?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    slug?: StringWithAggregatesFilter<"Team"> | string
    isActive?: BoolWithAggregatesFilter<"Team"> | boolean
    logoUrl?: StringNullableWithAggregatesFilter<"Team"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type GlobalConfigWhereInput = {
    AND?: GlobalConfigWhereInput | GlobalConfigWhereInput[]
    OR?: GlobalConfigWhereInput[]
    NOT?: GlobalConfigWhereInput | GlobalConfigWhereInput[]
    id?: StringFilter<"GlobalConfig"> | string
    systemName?: StringFilter<"GlobalConfig"> | string
    logoUrl?: StringNullableFilter<"GlobalConfig"> | string | null
    mainColor?: StringNullableFilter<"GlobalConfig"> | string | null
    createdAt?: DateTimeFilter<"GlobalConfig"> | Date | string
    updatedAt?: DateTimeFilter<"GlobalConfig"> | Date | string
  }

  export type GlobalConfigOrderByWithRelationInput = {
    id?: SortOrder
    systemName?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    mainColor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GlobalConfigWhereInput | GlobalConfigWhereInput[]
    OR?: GlobalConfigWhereInput[]
    NOT?: GlobalConfigWhereInput | GlobalConfigWhereInput[]
    systemName?: StringFilter<"GlobalConfig"> | string
    logoUrl?: StringNullableFilter<"GlobalConfig"> | string | null
    mainColor?: StringNullableFilter<"GlobalConfig"> | string | null
    createdAt?: DateTimeFilter<"GlobalConfig"> | Date | string
    updatedAt?: DateTimeFilter<"GlobalConfig"> | Date | string
  }, "id">

  export type GlobalConfigOrderByWithAggregationInput = {
    id?: SortOrder
    systemName?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    mainColor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GlobalConfigCountOrderByAggregateInput
    _max?: GlobalConfigMaxOrderByAggregateInput
    _min?: GlobalConfigMinOrderByAggregateInput
  }

  export type GlobalConfigScalarWhereWithAggregatesInput = {
    AND?: GlobalConfigScalarWhereWithAggregatesInput | GlobalConfigScalarWhereWithAggregatesInput[]
    OR?: GlobalConfigScalarWhereWithAggregatesInput[]
    NOT?: GlobalConfigScalarWhereWithAggregatesInput | GlobalConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GlobalConfig"> | string
    systemName?: StringWithAggregatesFilter<"GlobalConfig"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"GlobalConfig"> | string | null
    mainColor?: StringNullableWithAggregatesFilter<"GlobalConfig"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GlobalConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GlobalConfig"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isApproved?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    rpeEntries?: RPEEntryListRelationFilter
    wellnessEntries?: WellnessEntryListRelationFilter
    plannerPrefs?: PlannerPrefsListRelationFilter
    exercises?: ExerciseListRelationFilter
    clinicalEntries?: ClinicalEntryListRelationFilter
    teams?: UserTeamListRelationFilter
    reports?: ReportListRelationFilter
    players?: PlayerListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    rpeEntries?: RPEEntryOrderByRelationAggregateInput
    wellnessEntries?: WellnessEntryOrderByRelationAggregateInput
    plannerPrefs?: PlannerPrefsOrderByRelationAggregateInput
    exercises?: ExerciseOrderByRelationAggregateInput
    clinicalEntries?: ClinicalEntryOrderByRelationAggregateInput
    teams?: UserTeamOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    players?: PlayerOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isApproved?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    rpeEntries?: RPEEntryListRelationFilter
    wellnessEntries?: WellnessEntryListRelationFilter
    plannerPrefs?: PlannerPrefsListRelationFilter
    exercises?: ExerciseListRelationFilter
    clinicalEntries?: ClinicalEntryListRelationFilter
    teams?: UserTeamListRelationFilter
    reports?: ReportListRelationFilter
    players?: PlayerListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    isApproved?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserTeamWhereInput = {
    AND?: UserTeamWhereInput | UserTeamWhereInput[]
    OR?: UserTeamWhereInput[]
    NOT?: UserTeamWhereInput | UserTeamWhereInput[]
    id?: StringFilter<"UserTeam"> | string
    userId?: StringFilter<"UserTeam"> | string
    teamId?: StringFilter<"UserTeam"> | string
    role?: EnumTeamRoleFilter<"UserTeam"> | $Enums.TeamRole
    createdAt?: DateTimeFilter<"UserTeam"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }

  export type UserTeamOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type UserTeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_teamId?: UserTeamUserIdTeamIdCompoundUniqueInput
    AND?: UserTeamWhereInput | UserTeamWhereInput[]
    OR?: UserTeamWhereInput[]
    NOT?: UserTeamWhereInput | UserTeamWhereInput[]
    userId?: StringFilter<"UserTeam"> | string
    teamId?: StringFilter<"UserTeam"> | string
    role?: EnumTeamRoleFilter<"UserTeam"> | $Enums.TeamRole
    createdAt?: DateTimeFilter<"UserTeam"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }, "id" | "userId_teamId">

  export type UserTeamOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: UserTeamCountOrderByAggregateInput
    _max?: UserTeamMaxOrderByAggregateInput
    _min?: UserTeamMinOrderByAggregateInput
  }

  export type UserTeamScalarWhereWithAggregatesInput = {
    AND?: UserTeamScalarWhereWithAggregatesInput | UserTeamScalarWhereWithAggregatesInput[]
    OR?: UserTeamScalarWhereWithAggregatesInput[]
    NOT?: UserTeamScalarWhereWithAggregatesInput | UserTeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserTeam"> | string
    userId?: StringWithAggregatesFilter<"UserTeam"> | string
    teamId?: StringWithAggregatesFilter<"UserTeam"> | string
    role?: EnumTeamRoleWithAggregatesFilter<"UserTeam"> | $Enums.TeamRole
    createdAt?: DateTimeWithAggregatesFilter<"UserTeam"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    title?: StringFilter<"Session"> | string
    description?: StringNullableFilter<"Session"> | string | null
    date?: DateTimeFilter<"Session"> | Date | string
    type?: EnumSessionTypeFilter<"Session"> | $Enums.SessionType
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    createdBy?: StringFilter<"Session"> | string
    teamId?: StringFilter<"Session"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    teamId?: SortOrder
    user?: UserOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    title?: StringFilter<"Session"> | string
    description?: StringNullableFilter<"Session"> | string | null
    date?: DateTimeFilter<"Session"> | Date | string
    type?: EnumSessionTypeFilter<"Session"> | $Enums.SessionType
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    createdBy?: StringFilter<"Session"> | string
    teamId?: StringFilter<"Session"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    teamId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    title?: StringWithAggregatesFilter<"Session"> | string
    description?: StringNullableWithAggregatesFilter<"Session"> | string | null
    date?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    type?: EnumSessionTypeWithAggregatesFilter<"Session"> | $Enums.SessionType
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Session"> | string
    teamId?: StringWithAggregatesFilter<"Session"> | string
  }

  export type RivalWhereInput = {
    AND?: RivalWhereInput | RivalWhereInput[]
    OR?: RivalWhereInput[]
    NOT?: RivalWhereInput | RivalWhereInput[]
    id?: StringFilter<"Rival"> | string
    teamId?: StringFilter<"Rival"> | string
    name?: StringFilter<"Rival"> | string
    logoUrl?: StringNullableFilter<"Rival"> | string | null
    coach?: StringNullableFilter<"Rival"> | string | null
    baseSystem?: StringNullableFilter<"Rival"> | string | null
    nextMatchDate?: DateTimeNullableFilter<"Rival"> | Date | string | null
    nextMatchCompetition?: StringNullableFilter<"Rival"> | string | null
    planCharlaUrl?: StringNullableFilter<"Rival"> | string | null
    planReport?: JsonNullableFilter<"Rival">
    planVideos?: JsonNullableFilter<"Rival">
    planStats?: JsonNullableFilter<"Rival">
    planNotes?: JsonNullableFilter<"Rival">
    planVisibility?: JsonNullableFilter<"Rival">
    planSquad?: JsonNullableFilter<"Rival">
    createdAt?: DateTimeFilter<"Rival"> | Date | string
    updatedAt?: DateTimeFilter<"Rival"> | Date | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }

  export type RivalOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    coach?: SortOrderInput | SortOrder
    baseSystem?: SortOrderInput | SortOrder
    nextMatchDate?: SortOrderInput | SortOrder
    nextMatchCompetition?: SortOrderInput | SortOrder
    planCharlaUrl?: SortOrderInput | SortOrder
    planReport?: SortOrderInput | SortOrder
    planVideos?: SortOrderInput | SortOrder
    planStats?: SortOrderInput | SortOrder
    planNotes?: SortOrderInput | SortOrder
    planVisibility?: SortOrderInput | SortOrder
    planSquad?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
  }

  export type RivalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamId_name?: RivalTeamIdNameCompoundUniqueInput
    AND?: RivalWhereInput | RivalWhereInput[]
    OR?: RivalWhereInput[]
    NOT?: RivalWhereInput | RivalWhereInput[]
    teamId?: StringFilter<"Rival"> | string
    name?: StringFilter<"Rival"> | string
    logoUrl?: StringNullableFilter<"Rival"> | string | null
    coach?: StringNullableFilter<"Rival"> | string | null
    baseSystem?: StringNullableFilter<"Rival"> | string | null
    nextMatchDate?: DateTimeNullableFilter<"Rival"> | Date | string | null
    nextMatchCompetition?: StringNullableFilter<"Rival"> | string | null
    planCharlaUrl?: StringNullableFilter<"Rival"> | string | null
    planReport?: JsonNullableFilter<"Rival">
    planVideos?: JsonNullableFilter<"Rival">
    planStats?: JsonNullableFilter<"Rival">
    planNotes?: JsonNullableFilter<"Rival">
    planVisibility?: JsonNullableFilter<"Rival">
    planSquad?: JsonNullableFilter<"Rival">
    createdAt?: DateTimeFilter<"Rival"> | Date | string
    updatedAt?: DateTimeFilter<"Rival"> | Date | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }, "id" | "teamId_name">

  export type RivalOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    coach?: SortOrderInput | SortOrder
    baseSystem?: SortOrderInput | SortOrder
    nextMatchDate?: SortOrderInput | SortOrder
    nextMatchCompetition?: SortOrderInput | SortOrder
    planCharlaUrl?: SortOrderInput | SortOrder
    planReport?: SortOrderInput | SortOrder
    planVideos?: SortOrderInput | SortOrder
    planStats?: SortOrderInput | SortOrder
    planNotes?: SortOrderInput | SortOrder
    planVisibility?: SortOrderInput | SortOrder
    planSquad?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RivalCountOrderByAggregateInput
    _max?: RivalMaxOrderByAggregateInput
    _min?: RivalMinOrderByAggregateInput
  }

  export type RivalScalarWhereWithAggregatesInput = {
    AND?: RivalScalarWhereWithAggregatesInput | RivalScalarWhereWithAggregatesInput[]
    OR?: RivalScalarWhereWithAggregatesInput[]
    NOT?: RivalScalarWhereWithAggregatesInput | RivalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Rival"> | string
    teamId?: StringWithAggregatesFilter<"Rival"> | string
    name?: StringWithAggregatesFilter<"Rival"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"Rival"> | string | null
    coach?: StringNullableWithAggregatesFilter<"Rival"> | string | null
    baseSystem?: StringNullableWithAggregatesFilter<"Rival"> | string | null
    nextMatchDate?: DateTimeNullableWithAggregatesFilter<"Rival"> | Date | string | null
    nextMatchCompetition?: StringNullableWithAggregatesFilter<"Rival"> | string | null
    planCharlaUrl?: StringNullableWithAggregatesFilter<"Rival"> | string | null
    planReport?: JsonNullableWithAggregatesFilter<"Rival">
    planVideos?: JsonNullableWithAggregatesFilter<"Rival">
    planStats?: JsonNullableWithAggregatesFilter<"Rival">
    planNotes?: JsonNullableWithAggregatesFilter<"Rival">
    planVisibility?: JsonNullableWithAggregatesFilter<"Rival">
    planSquad?: JsonNullableWithAggregatesFilter<"Rival">
    createdAt?: DateTimeWithAggregatesFilter<"Rival"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Rival"> | Date | string
  }

  export type PlayerFeedbackWhereInput = {
    AND?: PlayerFeedbackWhereInput | PlayerFeedbackWhereInput[]
    OR?: PlayerFeedbackWhereInput[]
    NOT?: PlayerFeedbackWhereInput | PlayerFeedbackWhereInput[]
    id?: StringFilter<"PlayerFeedback"> | string
    teamId?: StringFilter<"PlayerFeedback"> | string
    playerId?: StringFilter<"PlayerFeedback"> | string
    subject?: StringNullableFilter<"PlayerFeedback"> | string | null
    text?: StringFilter<"PlayerFeedback"> | string
    rating?: IntNullableFilter<"PlayerFeedback"> | number | null
    createdBy?: StringFilter<"PlayerFeedback"> | string
    createdAt?: DateTimeFilter<"PlayerFeedback"> | Date | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }

  export type PlayerFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    subject?: SortOrderInput | SortOrder
    text?: SortOrder
    rating?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    team?: TeamOrderByWithRelationInput
  }

  export type PlayerFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlayerFeedbackWhereInput | PlayerFeedbackWhereInput[]
    OR?: PlayerFeedbackWhereInput[]
    NOT?: PlayerFeedbackWhereInput | PlayerFeedbackWhereInput[]
    teamId?: StringFilter<"PlayerFeedback"> | string
    playerId?: StringFilter<"PlayerFeedback"> | string
    subject?: StringNullableFilter<"PlayerFeedback"> | string | null
    text?: StringFilter<"PlayerFeedback"> | string
    rating?: IntNullableFilter<"PlayerFeedback"> | number | null
    createdBy?: StringFilter<"PlayerFeedback"> | string
    createdAt?: DateTimeFilter<"PlayerFeedback"> | Date | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }, "id">

  export type PlayerFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    subject?: SortOrderInput | SortOrder
    text?: SortOrder
    rating?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: PlayerFeedbackCountOrderByAggregateInput
    _avg?: PlayerFeedbackAvgOrderByAggregateInput
    _max?: PlayerFeedbackMaxOrderByAggregateInput
    _min?: PlayerFeedbackMinOrderByAggregateInput
    _sum?: PlayerFeedbackSumOrderByAggregateInput
  }

  export type PlayerFeedbackScalarWhereWithAggregatesInput = {
    AND?: PlayerFeedbackScalarWhereWithAggregatesInput | PlayerFeedbackScalarWhereWithAggregatesInput[]
    OR?: PlayerFeedbackScalarWhereWithAggregatesInput[]
    NOT?: PlayerFeedbackScalarWhereWithAggregatesInput | PlayerFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerFeedback"> | string
    teamId?: StringWithAggregatesFilter<"PlayerFeedback"> | string
    playerId?: StringWithAggregatesFilter<"PlayerFeedback"> | string
    subject?: StringNullableWithAggregatesFilter<"PlayerFeedback"> | string | null
    text?: StringWithAggregatesFilter<"PlayerFeedback"> | string
    rating?: IntNullableWithAggregatesFilter<"PlayerFeedback"> | number | null
    createdBy?: StringWithAggregatesFilter<"PlayerFeedback"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PlayerFeedback"> | Date | string
  }

  export type PlaceWhereInput = {
    AND?: PlaceWhereInput | PlaceWhereInput[]
    OR?: PlaceWhereInput[]
    NOT?: PlaceWhereInput | PlaceWhereInput[]
    id?: StringFilter<"Place"> | string
    name?: StringFilter<"Place"> | string
    teamId?: StringFilter<"Place"> | string
    createdAt?: DateTimeFilter<"Place"> | Date | string
    updatedAt?: DateTimeFilter<"Place"> | Date | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }

  export type PlaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
  }

  export type PlaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamId_name?: PlaceTeamIdNameCompoundUniqueInput
    AND?: PlaceWhereInput | PlaceWhereInput[]
    OR?: PlaceWhereInput[]
    NOT?: PlaceWhereInput | PlaceWhereInput[]
    name?: StringFilter<"Place"> | string
    teamId?: StringFilter<"Place"> | string
    createdAt?: DateTimeFilter<"Place"> | Date | string
    updatedAt?: DateTimeFilter<"Place"> | Date | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }, "id" | "teamId_name">

  export type PlaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlaceCountOrderByAggregateInput
    _max?: PlaceMaxOrderByAggregateInput
    _min?: PlaceMinOrderByAggregateInput
  }

  export type PlaceScalarWhereWithAggregatesInput = {
    AND?: PlaceScalarWhereWithAggregatesInput | PlaceScalarWhereWithAggregatesInput[]
    OR?: PlaceScalarWhereWithAggregatesInput[]
    NOT?: PlaceScalarWhereWithAggregatesInput | PlaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Place"> | string
    name?: StringWithAggregatesFilter<"Place"> | string
    teamId?: StringWithAggregatesFilter<"Place"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Place"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Place"> | Date | string
  }

  export type ExerciseKindWhereInput = {
    AND?: ExerciseKindWhereInput | ExerciseKindWhereInput[]
    OR?: ExerciseKindWhereInput[]
    NOT?: ExerciseKindWhereInput | ExerciseKindWhereInput[]
    id?: StringFilter<"ExerciseKind"> | string
    name?: StringFilter<"ExerciseKind"> | string
    createdAt?: DateTimeFilter<"ExerciseKind"> | Date | string
    updatedAt?: DateTimeFilter<"ExerciseKind"> | Date | string
    exercises?: ExerciseListRelationFilter
  }

  export type ExerciseKindOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exercises?: ExerciseOrderByRelationAggregateInput
  }

  export type ExerciseKindWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ExerciseKindWhereInput | ExerciseKindWhereInput[]
    OR?: ExerciseKindWhereInput[]
    NOT?: ExerciseKindWhereInput | ExerciseKindWhereInput[]
    createdAt?: DateTimeFilter<"ExerciseKind"> | Date | string
    updatedAt?: DateTimeFilter<"ExerciseKind"> | Date | string
    exercises?: ExerciseListRelationFilter
  }, "id" | "name">

  export type ExerciseKindOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExerciseKindCountOrderByAggregateInput
    _max?: ExerciseKindMaxOrderByAggregateInput
    _min?: ExerciseKindMinOrderByAggregateInput
  }

  export type ExerciseKindScalarWhereWithAggregatesInput = {
    AND?: ExerciseKindScalarWhereWithAggregatesInput | ExerciseKindScalarWhereWithAggregatesInput[]
    OR?: ExerciseKindScalarWhereWithAggregatesInput[]
    NOT?: ExerciseKindScalarWhereWithAggregatesInput | ExerciseKindScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExerciseKind"> | string
    name?: StringWithAggregatesFilter<"ExerciseKind"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ExerciseKind"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExerciseKind"> | Date | string
  }

  export type ExerciseWhereInput = {
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    id?: StringFilter<"Exercise"> | string
    userId?: StringFilter<"Exercise"> | string
    title?: StringFilter<"Exercise"> | string
    kindId?: StringNullableFilter<"Exercise"> | string | null
    space?: StringNullableFilter<"Exercise"> | string | null
    players?: StringNullableFilter<"Exercise"> | string | null
    duration?: StringNullableFilter<"Exercise"> | string | null
    description?: StringNullableFilter<"Exercise"> | string | null
    imageUrl?: StringNullableFilter<"Exercise"> | string | null
    tags?: StringNullableListFilter<"Exercise">
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    kind?: XOR<ExerciseKindNullableRelationFilter, ExerciseKindWhereInput> | null
  }

  export type ExerciseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    kindId?: SortOrderInput | SortOrder
    space?: SortOrderInput | SortOrder
    players?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    kind?: ExerciseKindOrderByWithRelationInput
  }

  export type ExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    userId?: StringFilter<"Exercise"> | string
    title?: StringFilter<"Exercise"> | string
    kindId?: StringNullableFilter<"Exercise"> | string | null
    space?: StringNullableFilter<"Exercise"> | string | null
    players?: StringNullableFilter<"Exercise"> | string | null
    duration?: StringNullableFilter<"Exercise"> | string | null
    description?: StringNullableFilter<"Exercise"> | string | null
    imageUrl?: StringNullableFilter<"Exercise"> | string | null
    tags?: StringNullableListFilter<"Exercise">
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    kind?: XOR<ExerciseKindNullableRelationFilter, ExerciseKindWhereInput> | null
  }, "id">

  export type ExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    kindId?: SortOrderInput | SortOrder
    space?: SortOrderInput | SortOrder
    players?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExerciseCountOrderByAggregateInput
    _max?: ExerciseMaxOrderByAggregateInput
    _min?: ExerciseMinOrderByAggregateInput
  }

  export type ExerciseScalarWhereWithAggregatesInput = {
    AND?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    OR?: ExerciseScalarWhereWithAggregatesInput[]
    NOT?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exercise"> | string
    userId?: StringWithAggregatesFilter<"Exercise"> | string
    title?: StringWithAggregatesFilter<"Exercise"> | string
    kindId?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    space?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    players?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    duration?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    description?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    tags?: StringNullableListFilter<"Exercise">
    createdAt?: DateTimeWithAggregatesFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exercise"> | Date | string
  }

  export type RPEEntryWhereInput = {
    AND?: RPEEntryWhereInput | RPEEntryWhereInput[]
    OR?: RPEEntryWhereInput[]
    NOT?: RPEEntryWhereInput | RPEEntryWhereInput[]
    id?: StringFilter<"RPEEntry"> | string
    userId?: StringFilter<"RPEEntry"> | string
    date?: DateTimeFilter<"RPEEntry"> | Date | string
    session?: IntFilter<"RPEEntry"> | number
    sessionLabel?: StringNullableFilter<"RPEEntry"> | string | null
    sessionUid?: StringNullableFilter<"RPEEntry"> | string | null
    rpe?: IntFilter<"RPEEntry"> | number
    duration?: IntNullableFilter<"RPEEntry"> | number | null
    load?: IntNullableFilter<"RPEEntry"> | number | null
    createdAt?: DateTimeFilter<"RPEEntry"> | Date | string
    updatedAt?: DateTimeFilter<"RPEEntry"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RPEEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    session?: SortOrder
    sessionLabel?: SortOrderInput | SortOrder
    sessionUid?: SortOrderInput | SortOrder
    rpe?: SortOrder
    duration?: SortOrderInput | SortOrder
    load?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RPEEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date_session?: RPEEntryUserId_date_sessionCompoundUniqueInput
    AND?: RPEEntryWhereInput | RPEEntryWhereInput[]
    OR?: RPEEntryWhereInput[]
    NOT?: RPEEntryWhereInput | RPEEntryWhereInput[]
    userId?: StringFilter<"RPEEntry"> | string
    date?: DateTimeFilter<"RPEEntry"> | Date | string
    session?: IntFilter<"RPEEntry"> | number
    sessionLabel?: StringNullableFilter<"RPEEntry"> | string | null
    sessionUid?: StringNullableFilter<"RPEEntry"> | string | null
    rpe?: IntFilter<"RPEEntry"> | number
    duration?: IntNullableFilter<"RPEEntry"> | number | null
    load?: IntNullableFilter<"RPEEntry"> | number | null
    createdAt?: DateTimeFilter<"RPEEntry"> | Date | string
    updatedAt?: DateTimeFilter<"RPEEntry"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_date_session">

  export type RPEEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    session?: SortOrder
    sessionLabel?: SortOrderInput | SortOrder
    sessionUid?: SortOrderInput | SortOrder
    rpe?: SortOrder
    duration?: SortOrderInput | SortOrder
    load?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RPEEntryCountOrderByAggregateInput
    _avg?: RPEEntryAvgOrderByAggregateInput
    _max?: RPEEntryMaxOrderByAggregateInput
    _min?: RPEEntryMinOrderByAggregateInput
    _sum?: RPEEntrySumOrderByAggregateInput
  }

  export type RPEEntryScalarWhereWithAggregatesInput = {
    AND?: RPEEntryScalarWhereWithAggregatesInput | RPEEntryScalarWhereWithAggregatesInput[]
    OR?: RPEEntryScalarWhereWithAggregatesInput[]
    NOT?: RPEEntryScalarWhereWithAggregatesInput | RPEEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RPEEntry"> | string
    userId?: StringWithAggregatesFilter<"RPEEntry"> | string
    date?: DateTimeWithAggregatesFilter<"RPEEntry"> | Date | string
    session?: IntWithAggregatesFilter<"RPEEntry"> | number
    sessionLabel?: StringNullableWithAggregatesFilter<"RPEEntry"> | string | null
    sessionUid?: StringNullableWithAggregatesFilter<"RPEEntry"> | string | null
    rpe?: IntWithAggregatesFilter<"RPEEntry"> | number
    duration?: IntNullableWithAggregatesFilter<"RPEEntry"> | number | null
    load?: IntNullableWithAggregatesFilter<"RPEEntry"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"RPEEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RPEEntry"> | Date | string
  }

  export type WellnessEntryWhereInput = {
    AND?: WellnessEntryWhereInput | WellnessEntryWhereInput[]
    OR?: WellnessEntryWhereInput[]
    NOT?: WellnessEntryWhereInput | WellnessEntryWhereInput[]
    id?: StringFilter<"WellnessEntry"> | string
    userId?: StringFilter<"WellnessEntry"> | string
    date?: DateTimeFilter<"WellnessEntry"> | Date | string
    sleepQuality?: IntFilter<"WellnessEntry"> | number
    sleepHours?: FloatNullableFilter<"WellnessEntry"> | number | null
    fatigue?: IntFilter<"WellnessEntry"> | number
    muscleSoreness?: IntFilter<"WellnessEntry"> | number
    stress?: IntFilter<"WellnessEntry"> | number
    mood?: IntFilter<"WellnessEntry"> | number
    comment?: StringNullableFilter<"WellnessEntry"> | string | null
    total?: IntNullableFilter<"WellnessEntry"> | number | null
    createdAt?: DateTimeFilter<"WellnessEntry"> | Date | string
    updatedAt?: DateTimeFilter<"WellnessEntry"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WellnessEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    sleepQuality?: SortOrder
    sleepHours?: SortOrderInput | SortOrder
    fatigue?: SortOrder
    muscleSoreness?: SortOrder
    stress?: SortOrder
    mood?: SortOrder
    comment?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WellnessEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: WellnessEntryUserId_dateCompoundUniqueInput
    AND?: WellnessEntryWhereInput | WellnessEntryWhereInput[]
    OR?: WellnessEntryWhereInput[]
    NOT?: WellnessEntryWhereInput | WellnessEntryWhereInput[]
    userId?: StringFilter<"WellnessEntry"> | string
    date?: DateTimeFilter<"WellnessEntry"> | Date | string
    sleepQuality?: IntFilter<"WellnessEntry"> | number
    sleepHours?: FloatNullableFilter<"WellnessEntry"> | number | null
    fatigue?: IntFilter<"WellnessEntry"> | number
    muscleSoreness?: IntFilter<"WellnessEntry"> | number
    stress?: IntFilter<"WellnessEntry"> | number
    mood?: IntFilter<"WellnessEntry"> | number
    comment?: StringNullableFilter<"WellnessEntry"> | string | null
    total?: IntNullableFilter<"WellnessEntry"> | number | null
    createdAt?: DateTimeFilter<"WellnessEntry"> | Date | string
    updatedAt?: DateTimeFilter<"WellnessEntry"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_date">

  export type WellnessEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    sleepQuality?: SortOrder
    sleepHours?: SortOrderInput | SortOrder
    fatigue?: SortOrder
    muscleSoreness?: SortOrder
    stress?: SortOrder
    mood?: SortOrder
    comment?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WellnessEntryCountOrderByAggregateInput
    _avg?: WellnessEntryAvgOrderByAggregateInput
    _max?: WellnessEntryMaxOrderByAggregateInput
    _min?: WellnessEntryMinOrderByAggregateInput
    _sum?: WellnessEntrySumOrderByAggregateInput
  }

  export type WellnessEntryScalarWhereWithAggregatesInput = {
    AND?: WellnessEntryScalarWhereWithAggregatesInput | WellnessEntryScalarWhereWithAggregatesInput[]
    OR?: WellnessEntryScalarWhereWithAggregatesInput[]
    NOT?: WellnessEntryScalarWhereWithAggregatesInput | WellnessEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WellnessEntry"> | string
    userId?: StringWithAggregatesFilter<"WellnessEntry"> | string
    date?: DateTimeWithAggregatesFilter<"WellnessEntry"> | Date | string
    sleepQuality?: IntWithAggregatesFilter<"WellnessEntry"> | number
    sleepHours?: FloatNullableWithAggregatesFilter<"WellnessEntry"> | number | null
    fatigue?: IntWithAggregatesFilter<"WellnessEntry"> | number
    muscleSoreness?: IntWithAggregatesFilter<"WellnessEntry"> | number
    stress?: IntWithAggregatesFilter<"WellnessEntry"> | number
    mood?: IntWithAggregatesFilter<"WellnessEntry"> | number
    comment?: StringNullableWithAggregatesFilter<"WellnessEntry"> | string | null
    total?: IntNullableWithAggregatesFilter<"WellnessEntry"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"WellnessEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WellnessEntry"> | Date | string
  }

  export type PlannerPrefsWhereInput = {
    AND?: PlannerPrefsWhereInput | PlannerPrefsWhereInput[]
    OR?: PlannerPrefsWhereInput[]
    NOT?: PlannerPrefsWhereInput | PlannerPrefsWhereInput[]
    id?: StringFilter<"PlannerPrefs"> | string
    userId?: StringFilter<"PlannerPrefs"> | string
    teamId?: StringFilter<"PlannerPrefs"> | string
    rowLabels?: JsonFilter<"PlannerPrefs">
    places?: JsonFilter<"PlannerPrefs">
    createdAt?: DateTimeFilter<"PlannerPrefs"> | Date | string
    updatedAt?: DateTimeFilter<"PlannerPrefs"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }

  export type PlannerPrefsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    rowLabels?: SortOrder
    places?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type PlannerPrefsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_teamId?: PlannerPrefsUserIdTeamIdCompoundUniqueInput
    AND?: PlannerPrefsWhereInput | PlannerPrefsWhereInput[]
    OR?: PlannerPrefsWhereInput[]
    NOT?: PlannerPrefsWhereInput | PlannerPrefsWhereInput[]
    userId?: StringFilter<"PlannerPrefs"> | string
    teamId?: StringFilter<"PlannerPrefs"> | string
    rowLabels?: JsonFilter<"PlannerPrefs">
    places?: JsonFilter<"PlannerPrefs">
    createdAt?: DateTimeFilter<"PlannerPrefs"> | Date | string
    updatedAt?: DateTimeFilter<"PlannerPrefs"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }, "id" | "userId_teamId">

  export type PlannerPrefsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    rowLabels?: SortOrder
    places?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlannerPrefsCountOrderByAggregateInput
    _max?: PlannerPrefsMaxOrderByAggregateInput
    _min?: PlannerPrefsMinOrderByAggregateInput
  }

  export type PlannerPrefsScalarWhereWithAggregatesInput = {
    AND?: PlannerPrefsScalarWhereWithAggregatesInput | PlannerPrefsScalarWhereWithAggregatesInput[]
    OR?: PlannerPrefsScalarWhereWithAggregatesInput[]
    NOT?: PlannerPrefsScalarWhereWithAggregatesInput | PlannerPrefsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlannerPrefs"> | string
    userId?: StringWithAggregatesFilter<"PlannerPrefs"> | string
    teamId?: StringWithAggregatesFilter<"PlannerPrefs"> | string
    rowLabels?: JsonWithAggregatesFilter<"PlannerPrefs">
    places?: JsonWithAggregatesFilter<"PlannerPrefs">
    createdAt?: DateTimeWithAggregatesFilter<"PlannerPrefs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlannerPrefs"> | Date | string
  }

  export type ClinicalEntryWhereInput = {
    AND?: ClinicalEntryWhereInput | ClinicalEntryWhereInput[]
    OR?: ClinicalEntryWhereInput[]
    NOT?: ClinicalEntryWhereInput | ClinicalEntryWhereInput[]
    id?: StringFilter<"ClinicalEntry"> | string
    userId?: StringFilter<"ClinicalEntry"> | string
    date?: DateTimeFilter<"ClinicalEntry"> | Date | string
    status?: EnumClinicalStatusFilter<"ClinicalEntry"> | $Enums.ClinicalStatus
    leaveStage?: EnumLeaveStageNullableFilter<"ClinicalEntry"> | $Enums.LeaveStage | null
    leaveKind?: EnumLeaveKindNullableFilter<"ClinicalEntry"> | $Enums.LeaveKind | null
    diagnosis?: StringNullableFilter<"ClinicalEntry"> | string | null
    bodyPart?: StringNullableFilter<"ClinicalEntry"> | string | null
    laterality?: EnumLateralityNullableFilter<"ClinicalEntry"> | $Enums.Laterality | null
    mechanism?: EnumMechanismNullableFilter<"ClinicalEntry"> | $Enums.Mechanism | null
    severity?: EnumSeverityNullableFilter<"ClinicalEntry"> | $Enums.Severity | null
    illSystem?: EnumSystemAffectedNullableFilter<"ClinicalEntry"> | $Enums.SystemAffected | null
    illSymptoms?: StringNullableFilter<"ClinicalEntry"> | string | null
    illContagious?: BoolNullableFilter<"ClinicalEntry"> | boolean | null
    illIsolationDays?: IntNullableFilter<"ClinicalEntry"> | number | null
    illAptitude?: EnumIllAptitudeNullableFilter<"ClinicalEntry"> | $Enums.IllAptitude | null
    feverMax?: FloatNullableFilter<"ClinicalEntry"> | number | null
    startDate?: DateTimeNullableFilter<"ClinicalEntry"> | Date | string | null
    daysPlanned?: IntNullableFilter<"ClinicalEntry"> | number | null
    expectedReturn?: DateTimeNullableFilter<"ClinicalEntry"> | Date | string | null
    expectedReturnManual?: BoolNullableFilter<"ClinicalEntry"> | boolean | null
    capMinutes?: IntNullableFilter<"ClinicalEntry"> | number | null
    noSprint?: BoolFilter<"ClinicalEntry"> | boolean
    noChangeOfDirection?: BoolFilter<"ClinicalEntry"> | boolean
    gymOnly?: BoolFilter<"ClinicalEntry"> | boolean
    noContact?: BoolFilter<"ClinicalEntry"> | boolean
    notes?: StringNullableFilter<"ClinicalEntry"> | string | null
    medSignature?: StringNullableFilter<"ClinicalEntry"> | string | null
    protocolObjectives?: StringNullableFilter<"ClinicalEntry"> | string | null
    protocolTasks?: StringNullableFilter<"ClinicalEntry"> | string | null
    protocolControls?: StringNullableFilter<"ClinicalEntry"> | string | null
    protocolCriteria?: StringNullableFilter<"ClinicalEntry"> | string | null
    createdAt?: DateTimeFilter<"ClinicalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicalEntry"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ClinicalEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    leaveStage?: SortOrderInput | SortOrder
    leaveKind?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    bodyPart?: SortOrderInput | SortOrder
    laterality?: SortOrderInput | SortOrder
    mechanism?: SortOrderInput | SortOrder
    severity?: SortOrderInput | SortOrder
    illSystem?: SortOrderInput | SortOrder
    illSymptoms?: SortOrderInput | SortOrder
    illContagious?: SortOrderInput | SortOrder
    illIsolationDays?: SortOrderInput | SortOrder
    illAptitude?: SortOrderInput | SortOrder
    feverMax?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    daysPlanned?: SortOrderInput | SortOrder
    expectedReturn?: SortOrderInput | SortOrder
    expectedReturnManual?: SortOrderInput | SortOrder
    capMinutes?: SortOrderInput | SortOrder
    noSprint?: SortOrder
    noChangeOfDirection?: SortOrder
    gymOnly?: SortOrder
    noContact?: SortOrder
    notes?: SortOrderInput | SortOrder
    medSignature?: SortOrderInput | SortOrder
    protocolObjectives?: SortOrderInput | SortOrder
    protocolTasks?: SortOrderInput | SortOrder
    protocolControls?: SortOrderInput | SortOrder
    protocolCriteria?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ClinicalEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: ClinicalEntryUserId_dateCompoundUniqueInput
    AND?: ClinicalEntryWhereInput | ClinicalEntryWhereInput[]
    OR?: ClinicalEntryWhereInput[]
    NOT?: ClinicalEntryWhereInput | ClinicalEntryWhereInput[]
    userId?: StringFilter<"ClinicalEntry"> | string
    date?: DateTimeFilter<"ClinicalEntry"> | Date | string
    status?: EnumClinicalStatusFilter<"ClinicalEntry"> | $Enums.ClinicalStatus
    leaveStage?: EnumLeaveStageNullableFilter<"ClinicalEntry"> | $Enums.LeaveStage | null
    leaveKind?: EnumLeaveKindNullableFilter<"ClinicalEntry"> | $Enums.LeaveKind | null
    diagnosis?: StringNullableFilter<"ClinicalEntry"> | string | null
    bodyPart?: StringNullableFilter<"ClinicalEntry"> | string | null
    laterality?: EnumLateralityNullableFilter<"ClinicalEntry"> | $Enums.Laterality | null
    mechanism?: EnumMechanismNullableFilter<"ClinicalEntry"> | $Enums.Mechanism | null
    severity?: EnumSeverityNullableFilter<"ClinicalEntry"> | $Enums.Severity | null
    illSystem?: EnumSystemAffectedNullableFilter<"ClinicalEntry"> | $Enums.SystemAffected | null
    illSymptoms?: StringNullableFilter<"ClinicalEntry"> | string | null
    illContagious?: BoolNullableFilter<"ClinicalEntry"> | boolean | null
    illIsolationDays?: IntNullableFilter<"ClinicalEntry"> | number | null
    illAptitude?: EnumIllAptitudeNullableFilter<"ClinicalEntry"> | $Enums.IllAptitude | null
    feverMax?: FloatNullableFilter<"ClinicalEntry"> | number | null
    startDate?: DateTimeNullableFilter<"ClinicalEntry"> | Date | string | null
    daysPlanned?: IntNullableFilter<"ClinicalEntry"> | number | null
    expectedReturn?: DateTimeNullableFilter<"ClinicalEntry"> | Date | string | null
    expectedReturnManual?: BoolNullableFilter<"ClinicalEntry"> | boolean | null
    capMinutes?: IntNullableFilter<"ClinicalEntry"> | number | null
    noSprint?: BoolFilter<"ClinicalEntry"> | boolean
    noChangeOfDirection?: BoolFilter<"ClinicalEntry"> | boolean
    gymOnly?: BoolFilter<"ClinicalEntry"> | boolean
    noContact?: BoolFilter<"ClinicalEntry"> | boolean
    notes?: StringNullableFilter<"ClinicalEntry"> | string | null
    medSignature?: StringNullableFilter<"ClinicalEntry"> | string | null
    protocolObjectives?: StringNullableFilter<"ClinicalEntry"> | string | null
    protocolTasks?: StringNullableFilter<"ClinicalEntry"> | string | null
    protocolControls?: StringNullableFilter<"ClinicalEntry"> | string | null
    protocolCriteria?: StringNullableFilter<"ClinicalEntry"> | string | null
    createdAt?: DateTimeFilter<"ClinicalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicalEntry"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_date">

  export type ClinicalEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    leaveStage?: SortOrderInput | SortOrder
    leaveKind?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    bodyPart?: SortOrderInput | SortOrder
    laterality?: SortOrderInput | SortOrder
    mechanism?: SortOrderInput | SortOrder
    severity?: SortOrderInput | SortOrder
    illSystem?: SortOrderInput | SortOrder
    illSymptoms?: SortOrderInput | SortOrder
    illContagious?: SortOrderInput | SortOrder
    illIsolationDays?: SortOrderInput | SortOrder
    illAptitude?: SortOrderInput | SortOrder
    feverMax?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    daysPlanned?: SortOrderInput | SortOrder
    expectedReturn?: SortOrderInput | SortOrder
    expectedReturnManual?: SortOrderInput | SortOrder
    capMinutes?: SortOrderInput | SortOrder
    noSprint?: SortOrder
    noChangeOfDirection?: SortOrder
    gymOnly?: SortOrder
    noContact?: SortOrder
    notes?: SortOrderInput | SortOrder
    medSignature?: SortOrderInput | SortOrder
    protocolObjectives?: SortOrderInput | SortOrder
    protocolTasks?: SortOrderInput | SortOrder
    protocolControls?: SortOrderInput | SortOrder
    protocolCriteria?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClinicalEntryCountOrderByAggregateInput
    _avg?: ClinicalEntryAvgOrderByAggregateInput
    _max?: ClinicalEntryMaxOrderByAggregateInput
    _min?: ClinicalEntryMinOrderByAggregateInput
    _sum?: ClinicalEntrySumOrderByAggregateInput
  }

  export type ClinicalEntryScalarWhereWithAggregatesInput = {
    AND?: ClinicalEntryScalarWhereWithAggregatesInput | ClinicalEntryScalarWhereWithAggregatesInput[]
    OR?: ClinicalEntryScalarWhereWithAggregatesInput[]
    NOT?: ClinicalEntryScalarWhereWithAggregatesInput | ClinicalEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClinicalEntry"> | string
    userId?: StringWithAggregatesFilter<"ClinicalEntry"> | string
    date?: DateTimeWithAggregatesFilter<"ClinicalEntry"> | Date | string
    status?: EnumClinicalStatusWithAggregatesFilter<"ClinicalEntry"> | $Enums.ClinicalStatus
    leaveStage?: EnumLeaveStageNullableWithAggregatesFilter<"ClinicalEntry"> | $Enums.LeaveStage | null
    leaveKind?: EnumLeaveKindNullableWithAggregatesFilter<"ClinicalEntry"> | $Enums.LeaveKind | null
    diagnosis?: StringNullableWithAggregatesFilter<"ClinicalEntry"> | string | null
    bodyPart?: StringNullableWithAggregatesFilter<"ClinicalEntry"> | string | null
    laterality?: EnumLateralityNullableWithAggregatesFilter<"ClinicalEntry"> | $Enums.Laterality | null
    mechanism?: EnumMechanismNullableWithAggregatesFilter<"ClinicalEntry"> | $Enums.Mechanism | null
    severity?: EnumSeverityNullableWithAggregatesFilter<"ClinicalEntry"> | $Enums.Severity | null
    illSystem?: EnumSystemAffectedNullableWithAggregatesFilter<"ClinicalEntry"> | $Enums.SystemAffected | null
    illSymptoms?: StringNullableWithAggregatesFilter<"ClinicalEntry"> | string | null
    illContagious?: BoolNullableWithAggregatesFilter<"ClinicalEntry"> | boolean | null
    illIsolationDays?: IntNullableWithAggregatesFilter<"ClinicalEntry"> | number | null
    illAptitude?: EnumIllAptitudeNullableWithAggregatesFilter<"ClinicalEntry"> | $Enums.IllAptitude | null
    feverMax?: FloatNullableWithAggregatesFilter<"ClinicalEntry"> | number | null
    startDate?: DateTimeNullableWithAggregatesFilter<"ClinicalEntry"> | Date | string | null
    daysPlanned?: IntNullableWithAggregatesFilter<"ClinicalEntry"> | number | null
    expectedReturn?: DateTimeNullableWithAggregatesFilter<"ClinicalEntry"> | Date | string | null
    expectedReturnManual?: BoolNullableWithAggregatesFilter<"ClinicalEntry"> | boolean | null
    capMinutes?: IntNullableWithAggregatesFilter<"ClinicalEntry"> | number | null
    noSprint?: BoolWithAggregatesFilter<"ClinicalEntry"> | boolean
    noChangeOfDirection?: BoolWithAggregatesFilter<"ClinicalEntry"> | boolean
    gymOnly?: BoolWithAggregatesFilter<"ClinicalEntry"> | boolean
    noContact?: BoolWithAggregatesFilter<"ClinicalEntry"> | boolean
    notes?: StringNullableWithAggregatesFilter<"ClinicalEntry"> | string | null
    medSignature?: StringNullableWithAggregatesFilter<"ClinicalEntry"> | string | null
    protocolObjectives?: StringNullableWithAggregatesFilter<"ClinicalEntry"> | string | null
    protocolTasks?: StringNullableWithAggregatesFilter<"ClinicalEntry"> | string | null
    protocolControls?: StringNullableWithAggregatesFilter<"ClinicalEntry"> | string | null
    protocolCriteria?: StringNullableWithAggregatesFilter<"ClinicalEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClinicalEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClinicalEntry"> | Date | string
  }

  export type ScoutingCategoryWhereInput = {
    AND?: ScoutingCategoryWhereInput | ScoutingCategoryWhereInput[]
    OR?: ScoutingCategoryWhereInput[]
    NOT?: ScoutingCategoryWhereInput | ScoutingCategoryWhereInput[]
    id?: StringFilter<"ScoutingCategory"> | string
    teamId?: StringNullableFilter<"ScoutingCategory"> | string | null
    nombre?: StringFilter<"ScoutingCategory"> | string
    slug?: StringFilter<"ScoutingCategory"> | string
    orden?: IntFilter<"ScoutingCategory"> | number
    color?: StringNullableFilter<"ScoutingCategory"> | string | null
    activa?: BoolFilter<"ScoutingCategory"> | boolean
    createdAt?: DateTimeFilter<"ScoutingCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ScoutingCategory"> | Date | string
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    players?: ScoutingPlayerListRelationFilter
  }

  export type ScoutingCategoryOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrderInput | SortOrder
    nombre?: SortOrder
    slug?: SortOrder
    orden?: SortOrder
    color?: SortOrderInput | SortOrder
    activa?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    players?: ScoutingPlayerOrderByRelationAggregateInput
  }

  export type ScoutingCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamId_slug?: ScoutingCategoryTeamIdSlugCompoundUniqueInput
    teamId_nombre?: ScoutingCategoryTeamIdNombreCompoundUniqueInput
    AND?: ScoutingCategoryWhereInput | ScoutingCategoryWhereInput[]
    OR?: ScoutingCategoryWhereInput[]
    NOT?: ScoutingCategoryWhereInput | ScoutingCategoryWhereInput[]
    teamId?: StringNullableFilter<"ScoutingCategory"> | string | null
    nombre?: StringFilter<"ScoutingCategory"> | string
    slug?: StringFilter<"ScoutingCategory"> | string
    orden?: IntFilter<"ScoutingCategory"> | number
    color?: StringNullableFilter<"ScoutingCategory"> | string | null
    activa?: BoolFilter<"ScoutingCategory"> | boolean
    createdAt?: DateTimeFilter<"ScoutingCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ScoutingCategory"> | Date | string
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    players?: ScoutingPlayerListRelationFilter
  }, "id" | "teamId_slug" | "teamId_nombre">

  export type ScoutingCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrderInput | SortOrder
    nombre?: SortOrder
    slug?: SortOrder
    orden?: SortOrder
    color?: SortOrderInput | SortOrder
    activa?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScoutingCategoryCountOrderByAggregateInput
    _avg?: ScoutingCategoryAvgOrderByAggregateInput
    _max?: ScoutingCategoryMaxOrderByAggregateInput
    _min?: ScoutingCategoryMinOrderByAggregateInput
    _sum?: ScoutingCategorySumOrderByAggregateInput
  }

  export type ScoutingCategoryScalarWhereWithAggregatesInput = {
    AND?: ScoutingCategoryScalarWhereWithAggregatesInput | ScoutingCategoryScalarWhereWithAggregatesInput[]
    OR?: ScoutingCategoryScalarWhereWithAggregatesInput[]
    NOT?: ScoutingCategoryScalarWhereWithAggregatesInput | ScoutingCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScoutingCategory"> | string
    teamId?: StringNullableWithAggregatesFilter<"ScoutingCategory"> | string | null
    nombre?: StringWithAggregatesFilter<"ScoutingCategory"> | string
    slug?: StringWithAggregatesFilter<"ScoutingCategory"> | string
    orden?: IntWithAggregatesFilter<"ScoutingCategory"> | number
    color?: StringNullableWithAggregatesFilter<"ScoutingCategory"> | string | null
    activa?: BoolWithAggregatesFilter<"ScoutingCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ScoutingCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScoutingCategory"> | Date | string
  }

  export type PlayerWhereInput = {
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    id?: StringFilter<"Player"> | string
    teamId?: StringFilter<"Player"> | string
    userId?: StringNullableFilter<"Player"> | string | null
    name?: StringFilter<"Player"> | string
    shirtNumber?: IntNullableFilter<"Player"> | number | null
    position?: StringNullableFilter<"Player"> | string | null
    photoUrl?: StringNullableFilter<"Player"> | string | null
    birthDate?: DateTimeNullableFilter<"Player"> | Date | string | null
    status?: EnumPlayerStatusFilter<"Player"> | $Enums.PlayerStatus
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type PlayerOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    shirtNumber?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    teamId?: StringFilter<"Player"> | string
    userId?: StringNullableFilter<"Player"> | string | null
    name?: StringFilter<"Player"> | string
    shirtNumber?: IntNullableFilter<"Player"> | number | null
    position?: StringNullableFilter<"Player"> | string | null
    photoUrl?: StringNullableFilter<"Player"> | string | null
    birthDate?: DateTimeNullableFilter<"Player"> | Date | string | null
    status?: EnumPlayerStatusFilter<"Player"> | $Enums.PlayerStatus
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type PlayerOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    shirtNumber?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerCountOrderByAggregateInput
    _avg?: PlayerAvgOrderByAggregateInput
    _max?: PlayerMaxOrderByAggregateInput
    _min?: PlayerMinOrderByAggregateInput
    _sum?: PlayerSumOrderByAggregateInput
  }

  export type PlayerScalarWhereWithAggregatesInput = {
    AND?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    OR?: PlayerScalarWhereWithAggregatesInput[]
    NOT?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Player"> | string
    teamId?: StringWithAggregatesFilter<"Player"> | string
    userId?: StringNullableWithAggregatesFilter<"Player"> | string | null
    name?: StringWithAggregatesFilter<"Player"> | string
    shirtNumber?: IntNullableWithAggregatesFilter<"Player"> | number | null
    position?: StringNullableWithAggregatesFilter<"Player"> | string | null
    photoUrl?: StringNullableWithAggregatesFilter<"Player"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"Player"> | Date | string | null
    status?: EnumPlayerStatusWithAggregatesFilter<"Player"> | $Enums.PlayerStatus
    createdAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
  }

  export type ScoutingPlayerWhereInput = {
    AND?: ScoutingPlayerWhereInput | ScoutingPlayerWhereInput[]
    OR?: ScoutingPlayerWhereInput[]
    NOT?: ScoutingPlayerWhereInput | ScoutingPlayerWhereInput[]
    id?: StringFilter<"ScoutingPlayer"> | string
    teamId?: StringNullableFilter<"ScoutingPlayer"> | string | null
    fullName?: StringFilter<"ScoutingPlayer"> | string
    positions?: StringNullableListFilter<"ScoutingPlayer">
    club?: StringNullableFilter<"ScoutingPlayer"> | string | null
    estado?: EnumScoutingStatusFilter<"ScoutingPlayer"> | $Enums.ScoutingStatus
    categoriaId?: StringNullableFilter<"ScoutingPlayer"> | string | null
    agentName?: StringNullableFilter<"ScoutingPlayer"> | string | null
    agentPhone?: StringNullableFilter<"ScoutingPlayer"> | string | null
    agentEmail?: StringNullableFilter<"ScoutingPlayer"> | string | null
    playerPhone?: StringNullableFilter<"ScoutingPlayer"> | string | null
    playerEmail?: StringNullableFilter<"ScoutingPlayer"> | string | null
    instagram?: StringNullableFilter<"ScoutingPlayer"> | string | null
    videos?: StringNullableListFilter<"ScoutingPlayer">
    notes?: StringNullableFilter<"ScoutingPlayer"> | string | null
    rating?: IntNullableFilter<"ScoutingPlayer"> | number | null
    tags?: StringNullableListFilter<"ScoutingPlayer">
    createdAt?: DateTimeFilter<"ScoutingPlayer"> | Date | string
    updatedAt?: DateTimeFilter<"ScoutingPlayer"> | Date | string
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    categoria?: XOR<ScoutingCategoryNullableRelationFilter, ScoutingCategoryWhereInput> | null
  }

  export type ScoutingPlayerOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrderInput | SortOrder
    fullName?: SortOrder
    positions?: SortOrder
    club?: SortOrderInput | SortOrder
    estado?: SortOrder
    categoriaId?: SortOrderInput | SortOrder
    agentName?: SortOrderInput | SortOrder
    agentPhone?: SortOrderInput | SortOrder
    agentEmail?: SortOrderInput | SortOrder
    playerPhone?: SortOrderInput | SortOrder
    playerEmail?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    videos?: SortOrder
    notes?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    categoria?: ScoutingCategoryOrderByWithRelationInput
  }

  export type ScoutingPlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScoutingPlayerWhereInput | ScoutingPlayerWhereInput[]
    OR?: ScoutingPlayerWhereInput[]
    NOT?: ScoutingPlayerWhereInput | ScoutingPlayerWhereInput[]
    teamId?: StringNullableFilter<"ScoutingPlayer"> | string | null
    fullName?: StringFilter<"ScoutingPlayer"> | string
    positions?: StringNullableListFilter<"ScoutingPlayer">
    club?: StringNullableFilter<"ScoutingPlayer"> | string | null
    estado?: EnumScoutingStatusFilter<"ScoutingPlayer"> | $Enums.ScoutingStatus
    categoriaId?: StringNullableFilter<"ScoutingPlayer"> | string | null
    agentName?: StringNullableFilter<"ScoutingPlayer"> | string | null
    agentPhone?: StringNullableFilter<"ScoutingPlayer"> | string | null
    agentEmail?: StringNullableFilter<"ScoutingPlayer"> | string | null
    playerPhone?: StringNullableFilter<"ScoutingPlayer"> | string | null
    playerEmail?: StringNullableFilter<"ScoutingPlayer"> | string | null
    instagram?: StringNullableFilter<"ScoutingPlayer"> | string | null
    videos?: StringNullableListFilter<"ScoutingPlayer">
    notes?: StringNullableFilter<"ScoutingPlayer"> | string | null
    rating?: IntNullableFilter<"ScoutingPlayer"> | number | null
    tags?: StringNullableListFilter<"ScoutingPlayer">
    createdAt?: DateTimeFilter<"ScoutingPlayer"> | Date | string
    updatedAt?: DateTimeFilter<"ScoutingPlayer"> | Date | string
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    categoria?: XOR<ScoutingCategoryNullableRelationFilter, ScoutingCategoryWhereInput> | null
  }, "id">

  export type ScoutingPlayerOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrderInput | SortOrder
    fullName?: SortOrder
    positions?: SortOrder
    club?: SortOrderInput | SortOrder
    estado?: SortOrder
    categoriaId?: SortOrderInput | SortOrder
    agentName?: SortOrderInput | SortOrder
    agentPhone?: SortOrderInput | SortOrder
    agentEmail?: SortOrderInput | SortOrder
    playerPhone?: SortOrderInput | SortOrder
    playerEmail?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    videos?: SortOrder
    notes?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScoutingPlayerCountOrderByAggregateInput
    _avg?: ScoutingPlayerAvgOrderByAggregateInput
    _max?: ScoutingPlayerMaxOrderByAggregateInput
    _min?: ScoutingPlayerMinOrderByAggregateInput
    _sum?: ScoutingPlayerSumOrderByAggregateInput
  }

  export type ScoutingPlayerScalarWhereWithAggregatesInput = {
    AND?: ScoutingPlayerScalarWhereWithAggregatesInput | ScoutingPlayerScalarWhereWithAggregatesInput[]
    OR?: ScoutingPlayerScalarWhereWithAggregatesInput[]
    NOT?: ScoutingPlayerScalarWhereWithAggregatesInput | ScoutingPlayerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScoutingPlayer"> | string
    teamId?: StringNullableWithAggregatesFilter<"ScoutingPlayer"> | string | null
    fullName?: StringWithAggregatesFilter<"ScoutingPlayer"> | string
    positions?: StringNullableListFilter<"ScoutingPlayer">
    club?: StringNullableWithAggregatesFilter<"ScoutingPlayer"> | string | null
    estado?: EnumScoutingStatusWithAggregatesFilter<"ScoutingPlayer"> | $Enums.ScoutingStatus
    categoriaId?: StringNullableWithAggregatesFilter<"ScoutingPlayer"> | string | null
    agentName?: StringNullableWithAggregatesFilter<"ScoutingPlayer"> | string | null
    agentPhone?: StringNullableWithAggregatesFilter<"ScoutingPlayer"> | string | null
    agentEmail?: StringNullableWithAggregatesFilter<"ScoutingPlayer"> | string | null
    playerPhone?: StringNullableWithAggregatesFilter<"ScoutingPlayer"> | string | null
    playerEmail?: StringNullableWithAggregatesFilter<"ScoutingPlayer"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"ScoutingPlayer"> | string | null
    videos?: StringNullableListFilter<"ScoutingPlayer">
    notes?: StringNullableWithAggregatesFilter<"ScoutingPlayer"> | string | null
    rating?: IntNullableWithAggregatesFilter<"ScoutingPlayer"> | number | null
    tags?: StringNullableListFilter<"ScoutingPlayer">
    createdAt?: DateTimeWithAggregatesFilter<"ScoutingPlayer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScoutingPlayer"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    teamId?: StringFilter<"Report"> | string
    title?: StringFilter<"Report"> | string
    summary?: StringNullableFilter<"Report"> | string | null
    content?: StringFilter<"Report"> | string
    type?: StringFilter<"Report"> | string
    authorId?: StringFilter<"Report"> | string
    visibleToDirectivo?: BoolFilter<"Report"> | boolean
    createdAt?: DateTimeFilter<"Report"> | Date | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    summary?: SortOrderInput | SortOrder
    content?: SortOrder
    type?: SortOrder
    authorId?: SortOrder
    visibleToDirectivo?: SortOrder
    createdAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    teamId?: StringFilter<"Report"> | string
    title?: StringFilter<"Report"> | string
    summary?: StringNullableFilter<"Report"> | string | null
    content?: StringFilter<"Report"> | string
    type?: StringFilter<"Report"> | string
    authorId?: StringFilter<"Report"> | string
    visibleToDirectivo?: BoolFilter<"Report"> | boolean
    createdAt?: DateTimeFilter<"Report"> | Date | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    summary?: SortOrderInput | SortOrder
    content?: SortOrder
    type?: SortOrder
    authorId?: SortOrder
    visibleToDirectivo?: SortOrder
    createdAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    teamId?: StringWithAggregatesFilter<"Report"> | string
    title?: StringWithAggregatesFilter<"Report"> | string
    summary?: StringNullableWithAggregatesFilter<"Report"> | string | null
    content?: StringWithAggregatesFilter<"Report"> | string
    type?: StringWithAggregatesFilter<"Report"> | string
    authorId?: StringWithAggregatesFilter<"Report"> | string
    visibleToDirectivo?: BoolWithAggregatesFilter<"Report"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type TeamVideoWhereInput = {
    AND?: TeamVideoWhereInput | TeamVideoWhereInput[]
    OR?: TeamVideoWhereInput[]
    NOT?: TeamVideoWhereInput | TeamVideoWhereInput[]
    id?: StringFilter<"TeamVideo"> | string
    teamId?: StringFilter<"TeamVideo"> | string
    url?: StringFilter<"TeamVideo"> | string
    title?: StringFilter<"TeamVideo"> | string
    notes?: StringNullableFilter<"TeamVideo"> | string | null
    type?: StringFilter<"TeamVideo"> | string
    visibleToDirectivo?: BoolFilter<"TeamVideo"> | boolean
    createdAt?: DateTimeFilter<"TeamVideo"> | Date | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }

  export type TeamVideoOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    url?: SortOrder
    title?: SortOrder
    notes?: SortOrderInput | SortOrder
    type?: SortOrder
    visibleToDirectivo?: SortOrder
    createdAt?: SortOrder
    team?: TeamOrderByWithRelationInput
  }

  export type TeamVideoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamVideoWhereInput | TeamVideoWhereInput[]
    OR?: TeamVideoWhereInput[]
    NOT?: TeamVideoWhereInput | TeamVideoWhereInput[]
    teamId?: StringFilter<"TeamVideo"> | string
    url?: StringFilter<"TeamVideo"> | string
    title?: StringFilter<"TeamVideo"> | string
    notes?: StringNullableFilter<"TeamVideo"> | string | null
    type?: StringFilter<"TeamVideo"> | string
    visibleToDirectivo?: BoolFilter<"TeamVideo"> | boolean
    createdAt?: DateTimeFilter<"TeamVideo"> | Date | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }, "id">

  export type TeamVideoOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    url?: SortOrder
    title?: SortOrder
    notes?: SortOrderInput | SortOrder
    type?: SortOrder
    visibleToDirectivo?: SortOrder
    createdAt?: SortOrder
    _count?: TeamVideoCountOrderByAggregateInput
    _max?: TeamVideoMaxOrderByAggregateInput
    _min?: TeamVideoMinOrderByAggregateInput
  }

  export type TeamVideoScalarWhereWithAggregatesInput = {
    AND?: TeamVideoScalarWhereWithAggregatesInput | TeamVideoScalarWhereWithAggregatesInput[]
    OR?: TeamVideoScalarWhereWithAggregatesInput[]
    NOT?: TeamVideoScalarWhereWithAggregatesInput | TeamVideoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamVideo"> | string
    teamId?: StringWithAggregatesFilter<"TeamVideo"> | string
    url?: StringWithAggregatesFilter<"TeamVideo"> | string
    title?: StringWithAggregatesFilter<"TeamVideo"> | string
    notes?: StringNullableWithAggregatesFilter<"TeamVideo"> | string | null
    type?: StringWithAggregatesFilter<"TeamVideo"> | string
    visibleToDirectivo?: BoolWithAggregatesFilter<"TeamVideo"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TeamVideo"> | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamCreateNestedManyWithoutTeamInput
    rivals?: RivalCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackCreateNestedManyWithoutTeamInput
    sessions?: SessionCreateNestedManyWithoutTeamInput
    places?: PlaceCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerCreateNestedManyWithoutTeamInput
    videos?: TeamVideoCreateNestedManyWithoutTeamInput
    reports?: ReportCreateNestedManyWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamUncheckedCreateNestedManyWithoutTeamInput
    rivals?: RivalUncheckedCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackUncheckedCreateNestedManyWithoutTeamInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTeamInput
    places?: PlaceUncheckedCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryUncheckedCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerUncheckedCreateNestedManyWithoutTeamInput
    videos?: TeamVideoUncheckedCreateNestedManyWithoutTeamInput
    reports?: ReportUncheckedCreateNestedManyWithoutTeamInput
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUpdateManyWithoutTeamNestedInput
    rivals?: RivalUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUpdateManyWithoutTeamNestedInput
    sessions?: SessionUpdateManyWithoutTeamNestedInput
    places?: PlaceUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUpdateManyWithoutTeamNestedInput
    reports?: ReportUpdateManyWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUncheckedUpdateManyWithoutTeamNestedInput
    rivals?: RivalUncheckedUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUncheckedUpdateManyWithoutTeamNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTeamNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUncheckedUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUncheckedUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUncheckedUpdateManyWithoutTeamNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTeamNestedInput
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalConfigCreateInput = {
    id?: string
    systemName: string
    logoUrl?: string | null
    mainColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalConfigUncheckedCreateInput = {
    id?: string
    systemName: string
    logoUrl?: string | null
    mainColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemName?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mainColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemName?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mainColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalConfigCreateManyInput = {
    id?: string
    systemName: string
    logoUrl?: string | null
    mainColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemName?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mainColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemName?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mainColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    rpeEntries?: RPEEntryCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryCreateNestedManyWithoutUserInput
    teams?: UserTeamCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    players?: PlayerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rpeEntries?: RPEEntryUncheckedCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryUncheckedCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryUncheckedCreateNestedManyWithoutUserInput
    teams?: UserTeamUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    players?: PlayerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rpeEntries?: RPEEntryUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUpdateManyWithoutUserNestedInput
    teams?: UserTeamUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    players?: PlayerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rpeEntries?: RPEEntryUncheckedUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUncheckedUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUncheckedUpdateManyWithoutUserNestedInput
    teams?: UserTeamUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    players?: PlayerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTeamCreateInput = {
    id?: string
    role: $Enums.TeamRole
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTeamsInput
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type UserTeamUncheckedCreateInput = {
    id?: string
    userId: string
    teamId: string
    role: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type UserTeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamsNestedInput
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type UserTeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTeamCreateManyInput = {
    id?: string
    userId: string
    teamId: string
    role: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type UserTeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    type?: $Enums.SessionType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
    team: TeamCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    type?: $Enums.SessionType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    teamId: string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
    team?: TeamUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    type?: $Enums.SessionType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    teamId: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type RivalCreateInput = {
    id?: string
    name: string
    logoUrl?: string | null
    coach?: string | null
    baseSystem?: string | null
    nextMatchDate?: Date | string | null
    nextMatchCompetition?: string | null
    planCharlaUrl?: string | null
    planReport?: NullableJsonNullValueInput | InputJsonValue
    planVideos?: NullableJsonNullValueInput | InputJsonValue
    planStats?: NullableJsonNullValueInput | InputJsonValue
    planNotes?: NullableJsonNullValueInput | InputJsonValue
    planVisibility?: NullableJsonNullValueInput | InputJsonValue
    planSquad?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutRivalsInput
  }

  export type RivalUncheckedCreateInput = {
    id?: string
    teamId: string
    name: string
    logoUrl?: string | null
    coach?: string | null
    baseSystem?: string | null
    nextMatchDate?: Date | string | null
    nextMatchCompetition?: string | null
    planCharlaUrl?: string | null
    planReport?: NullableJsonNullValueInput | InputJsonValue
    planVideos?: NullableJsonNullValueInput | InputJsonValue
    planStats?: NullableJsonNullValueInput | InputJsonValue
    planNotes?: NullableJsonNullValueInput | InputJsonValue
    planVisibility?: NullableJsonNullValueInput | InputJsonValue
    planSquad?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RivalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: NullableStringFieldUpdateOperationsInput | string | null
    baseSystem?: NullableStringFieldUpdateOperationsInput | string | null
    nextMatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMatchCompetition?: NullableStringFieldUpdateOperationsInput | string | null
    planCharlaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    planReport?: NullableJsonNullValueInput | InputJsonValue
    planVideos?: NullableJsonNullValueInput | InputJsonValue
    planStats?: NullableJsonNullValueInput | InputJsonValue
    planNotes?: NullableJsonNullValueInput | InputJsonValue
    planVisibility?: NullableJsonNullValueInput | InputJsonValue
    planSquad?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutRivalsNestedInput
  }

  export type RivalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: NullableStringFieldUpdateOperationsInput | string | null
    baseSystem?: NullableStringFieldUpdateOperationsInput | string | null
    nextMatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMatchCompetition?: NullableStringFieldUpdateOperationsInput | string | null
    planCharlaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    planReport?: NullableJsonNullValueInput | InputJsonValue
    planVideos?: NullableJsonNullValueInput | InputJsonValue
    planStats?: NullableJsonNullValueInput | InputJsonValue
    planNotes?: NullableJsonNullValueInput | InputJsonValue
    planVisibility?: NullableJsonNullValueInput | InputJsonValue
    planSquad?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RivalCreateManyInput = {
    id?: string
    teamId: string
    name: string
    logoUrl?: string | null
    coach?: string | null
    baseSystem?: string | null
    nextMatchDate?: Date | string | null
    nextMatchCompetition?: string | null
    planCharlaUrl?: string | null
    planReport?: NullableJsonNullValueInput | InputJsonValue
    planVideos?: NullableJsonNullValueInput | InputJsonValue
    planStats?: NullableJsonNullValueInput | InputJsonValue
    planNotes?: NullableJsonNullValueInput | InputJsonValue
    planVisibility?: NullableJsonNullValueInput | InputJsonValue
    planSquad?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RivalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: NullableStringFieldUpdateOperationsInput | string | null
    baseSystem?: NullableStringFieldUpdateOperationsInput | string | null
    nextMatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMatchCompetition?: NullableStringFieldUpdateOperationsInput | string | null
    planCharlaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    planReport?: NullableJsonNullValueInput | InputJsonValue
    planVideos?: NullableJsonNullValueInput | InputJsonValue
    planStats?: NullableJsonNullValueInput | InputJsonValue
    planNotes?: NullableJsonNullValueInput | InputJsonValue
    planVisibility?: NullableJsonNullValueInput | InputJsonValue
    planSquad?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RivalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: NullableStringFieldUpdateOperationsInput | string | null
    baseSystem?: NullableStringFieldUpdateOperationsInput | string | null
    nextMatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMatchCompetition?: NullableStringFieldUpdateOperationsInput | string | null
    planCharlaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    planReport?: NullableJsonNullValueInput | InputJsonValue
    planVideos?: NullableJsonNullValueInput | InputJsonValue
    planStats?: NullableJsonNullValueInput | InputJsonValue
    planNotes?: NullableJsonNullValueInput | InputJsonValue
    planVisibility?: NullableJsonNullValueInput | InputJsonValue
    planSquad?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerFeedbackCreateInput = {
    id?: string
    playerId: string
    subject?: string | null
    text: string
    rating?: number | null
    createdBy: string
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutFeedbackInput
  }

  export type PlayerFeedbackUncheckedCreateInput = {
    id?: string
    teamId: string
    playerId: string
    subject?: string | null
    text: string
    rating?: number | null
    createdBy: string
    createdAt?: Date | string
  }

  export type PlayerFeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type PlayerFeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerFeedbackCreateManyInput = {
    id?: string
    teamId: string
    playerId: string
    subject?: string | null
    text: string
    rating?: number | null
    createdBy: string
    createdAt?: Date | string
  }

  export type PlayerFeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerFeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutPlacesInput
  }

  export type PlaceUncheckedCreateInput = {
    id?: string
    name: string
    teamId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutPlacesNestedInput
  }

  export type PlaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceCreateManyInput = {
    id?: string
    name: string
    teamId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseKindCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    exercises?: ExerciseCreateNestedManyWithoutKindInput
  }

  export type ExerciseKindUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    exercises?: ExerciseUncheckedCreateNestedManyWithoutKindInput
  }

  export type ExerciseKindUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: ExerciseUpdateManyWithoutKindNestedInput
  }

  export type ExerciseKindUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: ExerciseUncheckedUpdateManyWithoutKindNestedInput
  }

  export type ExerciseKindCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseKindUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseKindUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseCreateInput = {
    id?: string
    title: string
    space?: string | null
    players?: string | null
    duration?: string | null
    description?: string | null
    imageUrl?: string | null
    tags?: ExerciseCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExercisesInput
    kind?: ExerciseKindCreateNestedOneWithoutExercisesInput
  }

  export type ExerciseUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    kindId?: string | null
    space?: string | null
    players?: string | null
    duration?: string | null
    description?: string | null
    imageUrl?: string | null
    tags?: ExerciseCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    space?: NullableStringFieldUpdateOperationsInput | string | null
    players?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ExerciseUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExercisesNestedInput
    kind?: ExerciseKindUpdateOneWithoutExercisesNestedInput
  }

  export type ExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    kindId?: NullableStringFieldUpdateOperationsInput | string | null
    space?: NullableStringFieldUpdateOperationsInput | string | null
    players?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ExerciseUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseCreateManyInput = {
    id?: string
    userId: string
    title: string
    kindId?: string | null
    space?: string | null
    players?: string | null
    duration?: string | null
    description?: string | null
    imageUrl?: string | null
    tags?: ExerciseCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    space?: NullableStringFieldUpdateOperationsInput | string | null
    players?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ExerciseUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    kindId?: NullableStringFieldUpdateOperationsInput | string | null
    space?: NullableStringFieldUpdateOperationsInput | string | null
    players?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ExerciseUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RPEEntryCreateInput = {
    id?: string
    date: Date | string
    session?: number
    sessionLabel?: string | null
    sessionUid?: string | null
    rpe: number
    duration?: number | null
    load?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRpeEntriesInput
  }

  export type RPEEntryUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    session?: number
    sessionLabel?: string | null
    sessionUid?: string | null
    rpe: number
    duration?: number | null
    load?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RPEEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: IntFieldUpdateOperationsInput | number
    sessionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sessionUid?: NullableStringFieldUpdateOperationsInput | string | null
    rpe?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    load?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRpeEntriesNestedInput
  }

  export type RPEEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: IntFieldUpdateOperationsInput | number
    sessionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sessionUid?: NullableStringFieldUpdateOperationsInput | string | null
    rpe?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    load?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RPEEntryCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    session?: number
    sessionLabel?: string | null
    sessionUid?: string | null
    rpe: number
    duration?: number | null
    load?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RPEEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: IntFieldUpdateOperationsInput | number
    sessionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sessionUid?: NullableStringFieldUpdateOperationsInput | string | null
    rpe?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    load?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RPEEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: IntFieldUpdateOperationsInput | number
    sessionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sessionUid?: NullableStringFieldUpdateOperationsInput | string | null
    rpe?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    load?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellnessEntryCreateInput = {
    id?: string
    date: Date | string
    sleepQuality: number
    sleepHours?: number | null
    fatigue: number
    muscleSoreness: number
    stress: number
    mood: number
    comment?: string | null
    total?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWellnessEntriesInput
  }

  export type WellnessEntryUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    sleepQuality: number
    sleepHours?: number | null
    fatigue: number
    muscleSoreness: number
    stress: number
    mood: number
    comment?: string | null
    total?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WellnessEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepQuality?: IntFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    fatigue?: IntFieldUpdateOperationsInput | number
    muscleSoreness?: IntFieldUpdateOperationsInput | number
    stress?: IntFieldUpdateOperationsInput | number
    mood?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWellnessEntriesNestedInput
  }

  export type WellnessEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepQuality?: IntFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    fatigue?: IntFieldUpdateOperationsInput | number
    muscleSoreness?: IntFieldUpdateOperationsInput | number
    stress?: IntFieldUpdateOperationsInput | number
    mood?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellnessEntryCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    sleepQuality: number
    sleepHours?: number | null
    fatigue: number
    muscleSoreness: number
    stress: number
    mood: number
    comment?: string | null
    total?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WellnessEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepQuality?: IntFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    fatigue?: IntFieldUpdateOperationsInput | number
    muscleSoreness?: IntFieldUpdateOperationsInput | number
    stress?: IntFieldUpdateOperationsInput | number
    mood?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellnessEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepQuality?: IntFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    fatigue?: IntFieldUpdateOperationsInput | number
    muscleSoreness?: IntFieldUpdateOperationsInput | number
    stress?: IntFieldUpdateOperationsInput | number
    mood?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlannerPrefsCreateInput = {
    id?: string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlannerPrefsInput
    team: TeamCreateNestedOneWithoutPlannerPrefsInput
  }

  export type PlannerPrefsUncheckedCreateInput = {
    id?: string
    userId: string
    teamId: string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlannerPrefsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlannerPrefsNestedInput
    team?: TeamUpdateOneRequiredWithoutPlannerPrefsNestedInput
  }

  export type PlannerPrefsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlannerPrefsCreateManyInput = {
    id?: string
    userId: string
    teamId: string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlannerPrefsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlannerPrefsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalEntryCreateInput = {
    id?: string
    date: Date | string
    status: $Enums.ClinicalStatus
    leaveStage?: $Enums.LeaveStage | null
    leaveKind?: $Enums.LeaveKind | null
    diagnosis?: string | null
    bodyPart?: string | null
    laterality?: $Enums.Laterality | null
    mechanism?: $Enums.Mechanism | null
    severity?: $Enums.Severity | null
    illSystem?: $Enums.SystemAffected | null
    illSymptoms?: string | null
    illContagious?: boolean | null
    illIsolationDays?: number | null
    illAptitude?: $Enums.IllAptitude | null
    feverMax?: number | null
    startDate?: Date | string | null
    daysPlanned?: number | null
    expectedReturn?: Date | string | null
    expectedReturnManual?: boolean | null
    capMinutes?: number | null
    noSprint?: boolean
    noChangeOfDirection?: boolean
    gymOnly?: boolean
    noContact?: boolean
    notes?: string | null
    medSignature?: string | null
    protocolObjectives?: string | null
    protocolTasks?: string | null
    protocolControls?: string | null
    protocolCriteria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClinicalEntriesInput
  }

  export type ClinicalEntryUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    status: $Enums.ClinicalStatus
    leaveStage?: $Enums.LeaveStage | null
    leaveKind?: $Enums.LeaveKind | null
    diagnosis?: string | null
    bodyPart?: string | null
    laterality?: $Enums.Laterality | null
    mechanism?: $Enums.Mechanism | null
    severity?: $Enums.Severity | null
    illSystem?: $Enums.SystemAffected | null
    illSymptoms?: string | null
    illContagious?: boolean | null
    illIsolationDays?: number | null
    illAptitude?: $Enums.IllAptitude | null
    feverMax?: number | null
    startDate?: Date | string | null
    daysPlanned?: number | null
    expectedReturn?: Date | string | null
    expectedReturnManual?: boolean | null
    capMinutes?: number | null
    noSprint?: boolean
    noChangeOfDirection?: boolean
    gymOnly?: boolean
    noContact?: boolean
    notes?: string | null
    medSignature?: string | null
    protocolObjectives?: string | null
    protocolTasks?: string | null
    protocolControls?: string | null
    protocolCriteria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicalEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClinicalStatusFieldUpdateOperationsInput | $Enums.ClinicalStatus
    leaveStage?: NullableEnumLeaveStageFieldUpdateOperationsInput | $Enums.LeaveStage | null
    leaveKind?: NullableEnumLeaveKindFieldUpdateOperationsInput | $Enums.LeaveKind | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    laterality?: NullableEnumLateralityFieldUpdateOperationsInput | $Enums.Laterality | null
    mechanism?: NullableEnumMechanismFieldUpdateOperationsInput | $Enums.Mechanism | null
    severity?: NullableEnumSeverityFieldUpdateOperationsInput | $Enums.Severity | null
    illSystem?: NullableEnumSystemAffectedFieldUpdateOperationsInput | $Enums.SystemAffected | null
    illSymptoms?: NullableStringFieldUpdateOperationsInput | string | null
    illContagious?: NullableBoolFieldUpdateOperationsInput | boolean | null
    illIsolationDays?: NullableIntFieldUpdateOperationsInput | number | null
    illAptitude?: NullableEnumIllAptitudeFieldUpdateOperationsInput | $Enums.IllAptitude | null
    feverMax?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysPlanned?: NullableIntFieldUpdateOperationsInput | number | null
    expectedReturn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnManual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    capMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    noSprint?: BoolFieldUpdateOperationsInput | boolean
    noChangeOfDirection?: BoolFieldUpdateOperationsInput | boolean
    gymOnly?: BoolFieldUpdateOperationsInput | boolean
    noContact?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    medSignature?: NullableStringFieldUpdateOperationsInput | string | null
    protocolObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    protocolTasks?: NullableStringFieldUpdateOperationsInput | string | null
    protocolControls?: NullableStringFieldUpdateOperationsInput | string | null
    protocolCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClinicalEntriesNestedInput
  }

  export type ClinicalEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClinicalStatusFieldUpdateOperationsInput | $Enums.ClinicalStatus
    leaveStage?: NullableEnumLeaveStageFieldUpdateOperationsInput | $Enums.LeaveStage | null
    leaveKind?: NullableEnumLeaveKindFieldUpdateOperationsInput | $Enums.LeaveKind | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    laterality?: NullableEnumLateralityFieldUpdateOperationsInput | $Enums.Laterality | null
    mechanism?: NullableEnumMechanismFieldUpdateOperationsInput | $Enums.Mechanism | null
    severity?: NullableEnumSeverityFieldUpdateOperationsInput | $Enums.Severity | null
    illSystem?: NullableEnumSystemAffectedFieldUpdateOperationsInput | $Enums.SystemAffected | null
    illSymptoms?: NullableStringFieldUpdateOperationsInput | string | null
    illContagious?: NullableBoolFieldUpdateOperationsInput | boolean | null
    illIsolationDays?: NullableIntFieldUpdateOperationsInput | number | null
    illAptitude?: NullableEnumIllAptitudeFieldUpdateOperationsInput | $Enums.IllAptitude | null
    feverMax?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysPlanned?: NullableIntFieldUpdateOperationsInput | number | null
    expectedReturn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnManual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    capMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    noSprint?: BoolFieldUpdateOperationsInput | boolean
    noChangeOfDirection?: BoolFieldUpdateOperationsInput | boolean
    gymOnly?: BoolFieldUpdateOperationsInput | boolean
    noContact?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    medSignature?: NullableStringFieldUpdateOperationsInput | string | null
    protocolObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    protocolTasks?: NullableStringFieldUpdateOperationsInput | string | null
    protocolControls?: NullableStringFieldUpdateOperationsInput | string | null
    protocolCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalEntryCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    status: $Enums.ClinicalStatus
    leaveStage?: $Enums.LeaveStage | null
    leaveKind?: $Enums.LeaveKind | null
    diagnosis?: string | null
    bodyPart?: string | null
    laterality?: $Enums.Laterality | null
    mechanism?: $Enums.Mechanism | null
    severity?: $Enums.Severity | null
    illSystem?: $Enums.SystemAffected | null
    illSymptoms?: string | null
    illContagious?: boolean | null
    illIsolationDays?: number | null
    illAptitude?: $Enums.IllAptitude | null
    feverMax?: number | null
    startDate?: Date | string | null
    daysPlanned?: number | null
    expectedReturn?: Date | string | null
    expectedReturnManual?: boolean | null
    capMinutes?: number | null
    noSprint?: boolean
    noChangeOfDirection?: boolean
    gymOnly?: boolean
    noContact?: boolean
    notes?: string | null
    medSignature?: string | null
    protocolObjectives?: string | null
    protocolTasks?: string | null
    protocolControls?: string | null
    protocolCriteria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicalEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClinicalStatusFieldUpdateOperationsInput | $Enums.ClinicalStatus
    leaveStage?: NullableEnumLeaveStageFieldUpdateOperationsInput | $Enums.LeaveStage | null
    leaveKind?: NullableEnumLeaveKindFieldUpdateOperationsInput | $Enums.LeaveKind | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    laterality?: NullableEnumLateralityFieldUpdateOperationsInput | $Enums.Laterality | null
    mechanism?: NullableEnumMechanismFieldUpdateOperationsInput | $Enums.Mechanism | null
    severity?: NullableEnumSeverityFieldUpdateOperationsInput | $Enums.Severity | null
    illSystem?: NullableEnumSystemAffectedFieldUpdateOperationsInput | $Enums.SystemAffected | null
    illSymptoms?: NullableStringFieldUpdateOperationsInput | string | null
    illContagious?: NullableBoolFieldUpdateOperationsInput | boolean | null
    illIsolationDays?: NullableIntFieldUpdateOperationsInput | number | null
    illAptitude?: NullableEnumIllAptitudeFieldUpdateOperationsInput | $Enums.IllAptitude | null
    feverMax?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysPlanned?: NullableIntFieldUpdateOperationsInput | number | null
    expectedReturn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnManual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    capMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    noSprint?: BoolFieldUpdateOperationsInput | boolean
    noChangeOfDirection?: BoolFieldUpdateOperationsInput | boolean
    gymOnly?: BoolFieldUpdateOperationsInput | boolean
    noContact?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    medSignature?: NullableStringFieldUpdateOperationsInput | string | null
    protocolObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    protocolTasks?: NullableStringFieldUpdateOperationsInput | string | null
    protocolControls?: NullableStringFieldUpdateOperationsInput | string | null
    protocolCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClinicalStatusFieldUpdateOperationsInput | $Enums.ClinicalStatus
    leaveStage?: NullableEnumLeaveStageFieldUpdateOperationsInput | $Enums.LeaveStage | null
    leaveKind?: NullableEnumLeaveKindFieldUpdateOperationsInput | $Enums.LeaveKind | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    laterality?: NullableEnumLateralityFieldUpdateOperationsInput | $Enums.Laterality | null
    mechanism?: NullableEnumMechanismFieldUpdateOperationsInput | $Enums.Mechanism | null
    severity?: NullableEnumSeverityFieldUpdateOperationsInput | $Enums.Severity | null
    illSystem?: NullableEnumSystemAffectedFieldUpdateOperationsInput | $Enums.SystemAffected | null
    illSymptoms?: NullableStringFieldUpdateOperationsInput | string | null
    illContagious?: NullableBoolFieldUpdateOperationsInput | boolean | null
    illIsolationDays?: NullableIntFieldUpdateOperationsInput | number | null
    illAptitude?: NullableEnumIllAptitudeFieldUpdateOperationsInput | $Enums.IllAptitude | null
    feverMax?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysPlanned?: NullableIntFieldUpdateOperationsInput | number | null
    expectedReturn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnManual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    capMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    noSprint?: BoolFieldUpdateOperationsInput | boolean
    noChangeOfDirection?: BoolFieldUpdateOperationsInput | boolean
    gymOnly?: BoolFieldUpdateOperationsInput | boolean
    noContact?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    medSignature?: NullableStringFieldUpdateOperationsInput | string | null
    protocolObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    protocolTasks?: NullableStringFieldUpdateOperationsInput | string | null
    protocolControls?: NullableStringFieldUpdateOperationsInput | string | null
    protocolCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScoutingCategoryCreateInput = {
    id?: string
    nombre: string
    slug: string
    orden?: number
    color?: string | null
    activa?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutScoutingCategoriesInput
    players?: ScoutingPlayerCreateNestedManyWithoutCategoriaInput
  }

  export type ScoutingCategoryUncheckedCreateInput = {
    id?: string
    teamId?: string | null
    nombre: string
    slug: string
    orden?: number
    color?: string | null
    activa?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: ScoutingPlayerUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type ScoutingCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    activa?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutScoutingCategoriesNestedInput
    players?: ScoutingPlayerUpdateManyWithoutCategoriaNestedInput
  }

  export type ScoutingCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    activa?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: ScoutingPlayerUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type ScoutingCategoryCreateManyInput = {
    id?: string
    teamId?: string | null
    nombre: string
    slug: string
    orden?: number
    color?: string | null
    activa?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScoutingCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    activa?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScoutingCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    activa?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCreateInput = {
    id?: string
    name: string
    shirtNumber?: number | null
    position?: string | null
    photoUrl?: string | null
    birthDate?: Date | string | null
    status?: $Enums.PlayerStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutPlayersInput
    user?: UserCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateInput = {
    id?: string
    teamId: string
    userId?: string | null
    name: string
    shirtNumber?: number | null
    position?: string | null
    photoUrl?: string | null
    birthDate?: Date | string | null
    status?: $Enums.PlayerStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shirtNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutPlayersNestedInput
    user?: UserUpdateOneWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shirtNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCreateManyInput = {
    id?: string
    teamId: string
    userId?: string | null
    name: string
    shirtNumber?: number | null
    position?: string | null
    photoUrl?: string | null
    birthDate?: Date | string | null
    status?: $Enums.PlayerStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shirtNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shirtNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScoutingPlayerCreateInput = {
    id?: string
    fullName: string
    positions?: ScoutingPlayerCreatepositionsInput | string[]
    club?: string | null
    estado?: $Enums.ScoutingStatus
    agentName?: string | null
    agentPhone?: string | null
    agentEmail?: string | null
    playerPhone?: string | null
    playerEmail?: string | null
    instagram?: string | null
    videos?: ScoutingPlayerCreatevideosInput | string[]
    notes?: string | null
    rating?: number | null
    tags?: ScoutingPlayerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutScoutingPlayersInput
    categoria?: ScoutingCategoryCreateNestedOneWithoutPlayersInput
  }

  export type ScoutingPlayerUncheckedCreateInput = {
    id?: string
    teamId?: string | null
    fullName: string
    positions?: ScoutingPlayerCreatepositionsInput | string[]
    club?: string | null
    estado?: $Enums.ScoutingStatus
    categoriaId?: string | null
    agentName?: string | null
    agentPhone?: string | null
    agentEmail?: string | null
    playerPhone?: string | null
    playerEmail?: string | null
    instagram?: string | null
    videos?: ScoutingPlayerCreatevideosInput | string[]
    notes?: string | null
    rating?: number | null
    tags?: ScoutingPlayerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScoutingPlayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    positions?: ScoutingPlayerUpdatepositionsInput | string[]
    club?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumScoutingStatusFieldUpdateOperationsInput | $Enums.ScoutingStatus
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    agentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    agentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    playerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    playerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ScoutingPlayerUpdatevideosInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: ScoutingPlayerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutScoutingPlayersNestedInput
    categoria?: ScoutingCategoryUpdateOneWithoutPlayersNestedInput
  }

  export type ScoutingPlayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    positions?: ScoutingPlayerUpdatepositionsInput | string[]
    club?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumScoutingStatusFieldUpdateOperationsInput | $Enums.ScoutingStatus
    categoriaId?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    agentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    agentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    playerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    playerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ScoutingPlayerUpdatevideosInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: ScoutingPlayerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScoutingPlayerCreateManyInput = {
    id?: string
    teamId?: string | null
    fullName: string
    positions?: ScoutingPlayerCreatepositionsInput | string[]
    club?: string | null
    estado?: $Enums.ScoutingStatus
    categoriaId?: string | null
    agentName?: string | null
    agentPhone?: string | null
    agentEmail?: string | null
    playerPhone?: string | null
    playerEmail?: string | null
    instagram?: string | null
    videos?: ScoutingPlayerCreatevideosInput | string[]
    notes?: string | null
    rating?: number | null
    tags?: ScoutingPlayerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScoutingPlayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    positions?: ScoutingPlayerUpdatepositionsInput | string[]
    club?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumScoutingStatusFieldUpdateOperationsInput | $Enums.ScoutingStatus
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    agentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    agentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    playerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    playerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ScoutingPlayerUpdatevideosInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: ScoutingPlayerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScoutingPlayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    positions?: ScoutingPlayerUpdatepositionsInput | string[]
    club?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumScoutingStatusFieldUpdateOperationsInput | $Enums.ScoutingStatus
    categoriaId?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    agentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    agentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    playerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    playerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ScoutingPlayerUpdatevideosInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: ScoutingPlayerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    title: string
    summary?: string | null
    content: string
    type: string
    visibleToDirectivo?: boolean
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutReportsInput
    author: UserCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    teamId: string
    title: string
    summary?: string | null
    content: string
    type: string
    authorId: string
    visibleToDirectivo?: boolean
    createdAt?: Date | string
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visibleToDirectivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutReportsNestedInput
    author?: UserUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    visibleToDirectivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: string
    teamId: string
    title: string
    summary?: string | null
    content: string
    type: string
    authorId: string
    visibleToDirectivo?: boolean
    createdAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visibleToDirectivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    visibleToDirectivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamVideoCreateInput = {
    id?: string
    url: string
    title: string
    notes?: string | null
    type: string
    visibleToDirectivo?: boolean
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutVideosInput
  }

  export type TeamVideoUncheckedCreateInput = {
    id?: string
    teamId: string
    url: string
    title: string
    notes?: string | null
    type: string
    visibleToDirectivo?: boolean
    createdAt?: Date | string
  }

  export type TeamVideoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    visibleToDirectivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutVideosNestedInput
  }

  export type TeamVideoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    visibleToDirectivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamVideoCreateManyInput = {
    id?: string
    teamId: string
    url: string
    title: string
    notes?: string | null
    type: string
    visibleToDirectivo?: boolean
    createdAt?: Date | string
  }

  export type TeamVideoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    visibleToDirectivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamVideoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    visibleToDirectivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserTeamListRelationFilter = {
    every?: UserTeamWhereInput
    some?: UserTeamWhereInput
    none?: UserTeamWhereInput
  }

  export type RivalListRelationFilter = {
    every?: RivalWhereInput
    some?: RivalWhereInput
    none?: RivalWhereInput
  }

  export type PlayerFeedbackListRelationFilter = {
    every?: PlayerFeedbackWhereInput
    some?: PlayerFeedbackWhereInput
    none?: PlayerFeedbackWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type PlaceListRelationFilter = {
    every?: PlaceWhereInput
    some?: PlaceWhereInput
    none?: PlaceWhereInput
  }

  export type PlannerPrefsListRelationFilter = {
    every?: PlannerPrefsWhereInput
    some?: PlannerPrefsWhereInput
    none?: PlannerPrefsWhereInput
  }

  export type ScoutingCategoryListRelationFilter = {
    every?: ScoutingCategoryWhereInput
    some?: ScoutingCategoryWhereInput
    none?: ScoutingCategoryWhereInput
  }

  export type ScoutingPlayerListRelationFilter = {
    every?: ScoutingPlayerWhereInput
    some?: ScoutingPlayerWhereInput
    none?: ScoutingPlayerWhereInput
  }

  export type TeamVideoListRelationFilter = {
    every?: TeamVideoWhereInput
    some?: TeamVideoWhereInput
    none?: TeamVideoWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type PlayerListRelationFilter = {
    every?: PlayerWhereInput
    some?: PlayerWhereInput
    none?: PlayerWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserTeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RivalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlannerPrefsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScoutingCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScoutingPlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamVideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isActive?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isActive?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isActive?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type GlobalConfigCountOrderByAggregateInput = {
    id?: SortOrder
    systemName?: SortOrder
    logoUrl?: SortOrder
    mainColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    systemName?: SortOrder
    logoUrl?: SortOrder
    mainColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalConfigMinOrderByAggregateInput = {
    id?: SortOrder
    systemName?: SortOrder
    logoUrl?: SortOrder
    mainColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type RPEEntryListRelationFilter = {
    every?: RPEEntryWhereInput
    some?: RPEEntryWhereInput
    none?: RPEEntryWhereInput
  }

  export type WellnessEntryListRelationFilter = {
    every?: WellnessEntryWhereInput
    some?: WellnessEntryWhereInput
    none?: WellnessEntryWhereInput
  }

  export type ExerciseListRelationFilter = {
    every?: ExerciseWhereInput
    some?: ExerciseWhereInput
    none?: ExerciseWhereInput
  }

  export type ClinicalEntryListRelationFilter = {
    every?: ClinicalEntryWhereInput
    some?: ClinicalEntryWhereInput
    none?: ClinicalEntryWhereInput
  }

  export type RPEEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WellnessEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClinicalEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumTeamRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleFilter<$PrismaModel> | $Enums.TeamRole
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TeamRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type UserTeamUserIdTeamIdCompoundUniqueInput = {
    userId: string
    teamId: string
  }

  export type UserTeamCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type UserTeamMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type UserTeamMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumTeamRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamRoleFilter<$PrismaModel>
    _max?: NestedEnumTeamRoleFilter<$PrismaModel>
  }

  export type EnumSessionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionType | EnumSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionTypeFilter<$PrismaModel> | $Enums.SessionType
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    teamId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    teamId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    teamId?: SortOrder
  }

  export type EnumSessionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionType | EnumSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SessionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionTypeFilter<$PrismaModel>
    _max?: NestedEnumSessionTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RivalTeamIdNameCompoundUniqueInput = {
    teamId: string
    name: string
  }

  export type RivalCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    coach?: SortOrder
    baseSystem?: SortOrder
    nextMatchDate?: SortOrder
    nextMatchCompetition?: SortOrder
    planCharlaUrl?: SortOrder
    planReport?: SortOrder
    planVideos?: SortOrder
    planStats?: SortOrder
    planNotes?: SortOrder
    planVisibility?: SortOrder
    planSquad?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RivalMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    coach?: SortOrder
    baseSystem?: SortOrder
    nextMatchDate?: SortOrder
    nextMatchCompetition?: SortOrder
    planCharlaUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RivalMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    logoUrl?: SortOrder
    coach?: SortOrder
    baseSystem?: SortOrder
    nextMatchDate?: SortOrder
    nextMatchCompetition?: SortOrder
    planCharlaUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PlayerFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    subject?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PlayerFeedbackAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type PlayerFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    subject?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PlayerFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    playerId?: SortOrder
    subject?: SortOrder
    text?: SortOrder
    rating?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PlayerFeedbackSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PlaceTeamIdNameCompoundUniqueInput = {
    teamId: string
    name: string
  }

  export type PlaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseKindCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseKindMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseKindMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ExerciseKindNullableRelationFilter = {
    is?: ExerciseKindWhereInput | null
    isNot?: ExerciseKindWhereInput | null
  }

  export type ExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    kindId?: SortOrder
    space?: SortOrder
    players?: SortOrder
    duration?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    kindId?: SortOrder
    space?: SortOrder
    players?: SortOrder
    duration?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    kindId?: SortOrder
    space?: SortOrder
    players?: SortOrder
    duration?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type RPEEntryUserId_date_sessionCompoundUniqueInput = {
    userId: string
    date: Date | string
    session: number
  }

  export type RPEEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    session?: SortOrder
    sessionLabel?: SortOrder
    sessionUid?: SortOrder
    rpe?: SortOrder
    duration?: SortOrder
    load?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RPEEntryAvgOrderByAggregateInput = {
    session?: SortOrder
    rpe?: SortOrder
    duration?: SortOrder
    load?: SortOrder
  }

  export type RPEEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    session?: SortOrder
    sessionLabel?: SortOrder
    sessionUid?: SortOrder
    rpe?: SortOrder
    duration?: SortOrder
    load?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RPEEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    session?: SortOrder
    sessionLabel?: SortOrder
    sessionUid?: SortOrder
    rpe?: SortOrder
    duration?: SortOrder
    load?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RPEEntrySumOrderByAggregateInput = {
    session?: SortOrder
    rpe?: SortOrder
    duration?: SortOrder
    load?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type WellnessEntryUserId_dateCompoundUniqueInput = {
    userId: string
    date: Date | string
  }

  export type WellnessEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    sleepQuality?: SortOrder
    sleepHours?: SortOrder
    fatigue?: SortOrder
    muscleSoreness?: SortOrder
    stress?: SortOrder
    mood?: SortOrder
    comment?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WellnessEntryAvgOrderByAggregateInput = {
    sleepQuality?: SortOrder
    sleepHours?: SortOrder
    fatigue?: SortOrder
    muscleSoreness?: SortOrder
    stress?: SortOrder
    mood?: SortOrder
    total?: SortOrder
  }

  export type WellnessEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    sleepQuality?: SortOrder
    sleepHours?: SortOrder
    fatigue?: SortOrder
    muscleSoreness?: SortOrder
    stress?: SortOrder
    mood?: SortOrder
    comment?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WellnessEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    sleepQuality?: SortOrder
    sleepHours?: SortOrder
    fatigue?: SortOrder
    muscleSoreness?: SortOrder
    stress?: SortOrder
    mood?: SortOrder
    comment?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WellnessEntrySumOrderByAggregateInput = {
    sleepQuality?: SortOrder
    sleepHours?: SortOrder
    fatigue?: SortOrder
    muscleSoreness?: SortOrder
    stress?: SortOrder
    mood?: SortOrder
    total?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PlannerPrefsUserIdTeamIdCompoundUniqueInput = {
    userId: string
    teamId: string
  }

  export type PlannerPrefsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    rowLabels?: SortOrder
    places?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlannerPrefsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlannerPrefsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumClinicalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClinicalStatus | EnumClinicalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClinicalStatus[] | ListEnumClinicalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClinicalStatus[] | ListEnumClinicalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClinicalStatusFilter<$PrismaModel> | $Enums.ClinicalStatus
  }

  export type EnumLeaveStageNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStage | EnumLeaveStageFieldRefInput<$PrismaModel> | null
    in?: $Enums.LeaveStage[] | ListEnumLeaveStageFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LeaveStage[] | ListEnumLeaveStageFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLeaveStageNullableFilter<$PrismaModel> | $Enums.LeaveStage | null
  }

  export type EnumLeaveKindNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveKind | EnumLeaveKindFieldRefInput<$PrismaModel> | null
    in?: $Enums.LeaveKind[] | ListEnumLeaveKindFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LeaveKind[] | ListEnumLeaveKindFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLeaveKindNullableFilter<$PrismaModel> | $Enums.LeaveKind | null
  }

  export type EnumLateralityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Laterality | EnumLateralityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Laterality[] | ListEnumLateralityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Laterality[] | ListEnumLateralityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLateralityNullableFilter<$PrismaModel> | $Enums.Laterality | null
  }

  export type EnumMechanismNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Mechanism | EnumMechanismFieldRefInput<$PrismaModel> | null
    in?: $Enums.Mechanism[] | ListEnumMechanismFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Mechanism[] | ListEnumMechanismFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMechanismNullableFilter<$PrismaModel> | $Enums.Mechanism | null
  }

  export type EnumSeverityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSeverityNullableFilter<$PrismaModel> | $Enums.Severity | null
  }

  export type EnumSystemAffectedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SystemAffected | EnumSystemAffectedFieldRefInput<$PrismaModel> | null
    in?: $Enums.SystemAffected[] | ListEnumSystemAffectedFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SystemAffected[] | ListEnumSystemAffectedFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSystemAffectedNullableFilter<$PrismaModel> | $Enums.SystemAffected | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EnumIllAptitudeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IllAptitude | EnumIllAptitudeFieldRefInput<$PrismaModel> | null
    in?: $Enums.IllAptitude[] | ListEnumIllAptitudeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IllAptitude[] | ListEnumIllAptitudeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIllAptitudeNullableFilter<$PrismaModel> | $Enums.IllAptitude | null
  }

  export type ClinicalEntryUserId_dateCompoundUniqueInput = {
    userId: string
    date: Date | string
  }

  export type ClinicalEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    leaveStage?: SortOrder
    leaveKind?: SortOrder
    diagnosis?: SortOrder
    bodyPart?: SortOrder
    laterality?: SortOrder
    mechanism?: SortOrder
    severity?: SortOrder
    illSystem?: SortOrder
    illSymptoms?: SortOrder
    illContagious?: SortOrder
    illIsolationDays?: SortOrder
    illAptitude?: SortOrder
    feverMax?: SortOrder
    startDate?: SortOrder
    daysPlanned?: SortOrder
    expectedReturn?: SortOrder
    expectedReturnManual?: SortOrder
    capMinutes?: SortOrder
    noSprint?: SortOrder
    noChangeOfDirection?: SortOrder
    gymOnly?: SortOrder
    noContact?: SortOrder
    notes?: SortOrder
    medSignature?: SortOrder
    protocolObjectives?: SortOrder
    protocolTasks?: SortOrder
    protocolControls?: SortOrder
    protocolCriteria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicalEntryAvgOrderByAggregateInput = {
    illIsolationDays?: SortOrder
    feverMax?: SortOrder
    daysPlanned?: SortOrder
    capMinutes?: SortOrder
  }

  export type ClinicalEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    leaveStage?: SortOrder
    leaveKind?: SortOrder
    diagnosis?: SortOrder
    bodyPart?: SortOrder
    laterality?: SortOrder
    mechanism?: SortOrder
    severity?: SortOrder
    illSystem?: SortOrder
    illSymptoms?: SortOrder
    illContagious?: SortOrder
    illIsolationDays?: SortOrder
    illAptitude?: SortOrder
    feverMax?: SortOrder
    startDate?: SortOrder
    daysPlanned?: SortOrder
    expectedReturn?: SortOrder
    expectedReturnManual?: SortOrder
    capMinutes?: SortOrder
    noSprint?: SortOrder
    noChangeOfDirection?: SortOrder
    gymOnly?: SortOrder
    noContact?: SortOrder
    notes?: SortOrder
    medSignature?: SortOrder
    protocolObjectives?: SortOrder
    protocolTasks?: SortOrder
    protocolControls?: SortOrder
    protocolCriteria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicalEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    leaveStage?: SortOrder
    leaveKind?: SortOrder
    diagnosis?: SortOrder
    bodyPart?: SortOrder
    laterality?: SortOrder
    mechanism?: SortOrder
    severity?: SortOrder
    illSystem?: SortOrder
    illSymptoms?: SortOrder
    illContagious?: SortOrder
    illIsolationDays?: SortOrder
    illAptitude?: SortOrder
    feverMax?: SortOrder
    startDate?: SortOrder
    daysPlanned?: SortOrder
    expectedReturn?: SortOrder
    expectedReturnManual?: SortOrder
    capMinutes?: SortOrder
    noSprint?: SortOrder
    noChangeOfDirection?: SortOrder
    gymOnly?: SortOrder
    noContact?: SortOrder
    notes?: SortOrder
    medSignature?: SortOrder
    protocolObjectives?: SortOrder
    protocolTasks?: SortOrder
    protocolControls?: SortOrder
    protocolCriteria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicalEntrySumOrderByAggregateInput = {
    illIsolationDays?: SortOrder
    feverMax?: SortOrder
    daysPlanned?: SortOrder
    capMinutes?: SortOrder
  }

  export type EnumClinicalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClinicalStatus | EnumClinicalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClinicalStatus[] | ListEnumClinicalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClinicalStatus[] | ListEnumClinicalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClinicalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClinicalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClinicalStatusFilter<$PrismaModel>
    _max?: NestedEnumClinicalStatusFilter<$PrismaModel>
  }

  export type EnumLeaveStageNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStage | EnumLeaveStageFieldRefInput<$PrismaModel> | null
    in?: $Enums.LeaveStage[] | ListEnumLeaveStageFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LeaveStage[] | ListEnumLeaveStageFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLeaveStageNullableWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStage | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLeaveStageNullableFilter<$PrismaModel>
    _max?: NestedEnumLeaveStageNullableFilter<$PrismaModel>
  }

  export type EnumLeaveKindNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveKind | EnumLeaveKindFieldRefInput<$PrismaModel> | null
    in?: $Enums.LeaveKind[] | ListEnumLeaveKindFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LeaveKind[] | ListEnumLeaveKindFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLeaveKindNullableWithAggregatesFilter<$PrismaModel> | $Enums.LeaveKind | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLeaveKindNullableFilter<$PrismaModel>
    _max?: NestedEnumLeaveKindNullableFilter<$PrismaModel>
  }

  export type EnumLateralityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Laterality | EnumLateralityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Laterality[] | ListEnumLateralityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Laterality[] | ListEnumLateralityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLateralityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Laterality | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLateralityNullableFilter<$PrismaModel>
    _max?: NestedEnumLateralityNullableFilter<$PrismaModel>
  }

  export type EnumMechanismNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Mechanism | EnumMechanismFieldRefInput<$PrismaModel> | null
    in?: $Enums.Mechanism[] | ListEnumMechanismFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Mechanism[] | ListEnumMechanismFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMechanismNullableWithAggregatesFilter<$PrismaModel> | $Enums.Mechanism | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMechanismNullableFilter<$PrismaModel>
    _max?: NestedEnumMechanismNullableFilter<$PrismaModel>
  }

  export type EnumSeverityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSeverityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Severity | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSeverityNullableFilter<$PrismaModel>
    _max?: NestedEnumSeverityNullableFilter<$PrismaModel>
  }

  export type EnumSystemAffectedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SystemAffected | EnumSystemAffectedFieldRefInput<$PrismaModel> | null
    in?: $Enums.SystemAffected[] | ListEnumSystemAffectedFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SystemAffected[] | ListEnumSystemAffectedFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSystemAffectedNullableWithAggregatesFilter<$PrismaModel> | $Enums.SystemAffected | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSystemAffectedNullableFilter<$PrismaModel>
    _max?: NestedEnumSystemAffectedNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumIllAptitudeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IllAptitude | EnumIllAptitudeFieldRefInput<$PrismaModel> | null
    in?: $Enums.IllAptitude[] | ListEnumIllAptitudeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IllAptitude[] | ListEnumIllAptitudeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIllAptitudeNullableWithAggregatesFilter<$PrismaModel> | $Enums.IllAptitude | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIllAptitudeNullableFilter<$PrismaModel>
    _max?: NestedEnumIllAptitudeNullableFilter<$PrismaModel>
  }

  export type TeamNullableRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type ScoutingCategoryTeamIdSlugCompoundUniqueInput = {
    teamId: string
    slug: string
  }

  export type ScoutingCategoryTeamIdNombreCompoundUniqueInput = {
    teamId: string
    nombre: string
  }

  export type ScoutingCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    nombre?: SortOrder
    slug?: SortOrder
    orden?: SortOrder
    color?: SortOrder
    activa?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScoutingCategoryAvgOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type ScoutingCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    nombre?: SortOrder
    slug?: SortOrder
    orden?: SortOrder
    color?: SortOrder
    activa?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScoutingCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    nombre?: SortOrder
    slug?: SortOrder
    orden?: SortOrder
    color?: SortOrder
    activa?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScoutingCategorySumOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type EnumPlayerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerStatus | EnumPlayerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlayerStatus[] | ListEnumPlayerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlayerStatus[] | ListEnumPlayerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerStatusFilter<$PrismaModel> | $Enums.PlayerStatus
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PlayerCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    shirtNumber?: SortOrder
    position?: SortOrder
    photoUrl?: SortOrder
    birthDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerAvgOrderByAggregateInput = {
    shirtNumber?: SortOrder
  }

  export type PlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    shirtNumber?: SortOrder
    position?: SortOrder
    photoUrl?: SortOrder
    birthDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    shirtNumber?: SortOrder
    position?: SortOrder
    photoUrl?: SortOrder
    birthDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerSumOrderByAggregateInput = {
    shirtNumber?: SortOrder
  }

  export type EnumPlayerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerStatus | EnumPlayerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlayerStatus[] | ListEnumPlayerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlayerStatus[] | ListEnumPlayerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerStatusWithAggregatesFilter<$PrismaModel> | $Enums.PlayerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlayerStatusFilter<$PrismaModel>
    _max?: NestedEnumPlayerStatusFilter<$PrismaModel>
  }

  export type EnumScoutingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoutingStatus | EnumScoutingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScoutingStatus[] | ListEnumScoutingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoutingStatus[] | ListEnumScoutingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScoutingStatusFilter<$PrismaModel> | $Enums.ScoutingStatus
  }

  export type ScoutingCategoryNullableRelationFilter = {
    is?: ScoutingCategoryWhereInput | null
    isNot?: ScoutingCategoryWhereInput | null
  }

  export type ScoutingPlayerCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    fullName?: SortOrder
    positions?: SortOrder
    club?: SortOrder
    estado?: SortOrder
    categoriaId?: SortOrder
    agentName?: SortOrder
    agentPhone?: SortOrder
    agentEmail?: SortOrder
    playerPhone?: SortOrder
    playerEmail?: SortOrder
    instagram?: SortOrder
    videos?: SortOrder
    notes?: SortOrder
    rating?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScoutingPlayerAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ScoutingPlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    fullName?: SortOrder
    club?: SortOrder
    estado?: SortOrder
    categoriaId?: SortOrder
    agentName?: SortOrder
    agentPhone?: SortOrder
    agentEmail?: SortOrder
    playerPhone?: SortOrder
    playerEmail?: SortOrder
    instagram?: SortOrder
    notes?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScoutingPlayerMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    fullName?: SortOrder
    club?: SortOrder
    estado?: SortOrder
    categoriaId?: SortOrder
    agentName?: SortOrder
    agentPhone?: SortOrder
    agentEmail?: SortOrder
    playerPhone?: SortOrder
    playerEmail?: SortOrder
    instagram?: SortOrder
    notes?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScoutingPlayerSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumScoutingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoutingStatus | EnumScoutingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScoutingStatus[] | ListEnumScoutingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoutingStatus[] | ListEnumScoutingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScoutingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ScoutingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScoutingStatusFilter<$PrismaModel>
    _max?: NestedEnumScoutingStatusFilter<$PrismaModel>
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    content?: SortOrder
    type?: SortOrder
    authorId?: SortOrder
    visibleToDirectivo?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    content?: SortOrder
    type?: SortOrder
    authorId?: SortOrder
    visibleToDirectivo?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    content?: SortOrder
    type?: SortOrder
    authorId?: SortOrder
    visibleToDirectivo?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamVideoCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    url?: SortOrder
    title?: SortOrder
    notes?: SortOrder
    type?: SortOrder
    visibleToDirectivo?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamVideoMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    url?: SortOrder
    title?: SortOrder
    notes?: SortOrder
    type?: SortOrder
    visibleToDirectivo?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamVideoMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    url?: SortOrder
    title?: SortOrder
    notes?: SortOrder
    type?: SortOrder
    visibleToDirectivo?: SortOrder
    createdAt?: SortOrder
  }

  export type UserTeamCreateNestedManyWithoutTeamInput = {
    create?: XOR<UserTeamCreateWithoutTeamInput, UserTeamUncheckedCreateWithoutTeamInput> | UserTeamCreateWithoutTeamInput[] | UserTeamUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserTeamCreateOrConnectWithoutTeamInput | UserTeamCreateOrConnectWithoutTeamInput[]
    createMany?: UserTeamCreateManyTeamInputEnvelope
    connect?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
  }

  export type RivalCreateNestedManyWithoutTeamInput = {
    create?: XOR<RivalCreateWithoutTeamInput, RivalUncheckedCreateWithoutTeamInput> | RivalCreateWithoutTeamInput[] | RivalUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: RivalCreateOrConnectWithoutTeamInput | RivalCreateOrConnectWithoutTeamInput[]
    createMany?: RivalCreateManyTeamInputEnvelope
    connect?: RivalWhereUniqueInput | RivalWhereUniqueInput[]
  }

  export type PlayerFeedbackCreateNestedManyWithoutTeamInput = {
    create?: XOR<PlayerFeedbackCreateWithoutTeamInput, PlayerFeedbackUncheckedCreateWithoutTeamInput> | PlayerFeedbackCreateWithoutTeamInput[] | PlayerFeedbackUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerFeedbackCreateOrConnectWithoutTeamInput | PlayerFeedbackCreateOrConnectWithoutTeamInput[]
    createMany?: PlayerFeedbackCreateManyTeamInputEnvelope
    connect?: PlayerFeedbackWhereUniqueInput | PlayerFeedbackWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutTeamInput = {
    create?: XOR<SessionCreateWithoutTeamInput, SessionUncheckedCreateWithoutTeamInput> | SessionCreateWithoutTeamInput[] | SessionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutTeamInput | SessionCreateOrConnectWithoutTeamInput[]
    createMany?: SessionCreateManyTeamInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PlaceCreateNestedManyWithoutTeamInput = {
    create?: XOR<PlaceCreateWithoutTeamInput, PlaceUncheckedCreateWithoutTeamInput> | PlaceCreateWithoutTeamInput[] | PlaceUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutTeamInput | PlaceCreateOrConnectWithoutTeamInput[]
    createMany?: PlaceCreateManyTeamInputEnvelope
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
  }

  export type PlannerPrefsCreateNestedManyWithoutTeamInput = {
    create?: XOR<PlannerPrefsCreateWithoutTeamInput, PlannerPrefsUncheckedCreateWithoutTeamInput> | PlannerPrefsCreateWithoutTeamInput[] | PlannerPrefsUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlannerPrefsCreateOrConnectWithoutTeamInput | PlannerPrefsCreateOrConnectWithoutTeamInput[]
    createMany?: PlannerPrefsCreateManyTeamInputEnvelope
    connect?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
  }

  export type ScoutingCategoryCreateNestedManyWithoutTeamInput = {
    create?: XOR<ScoutingCategoryCreateWithoutTeamInput, ScoutingCategoryUncheckedCreateWithoutTeamInput> | ScoutingCategoryCreateWithoutTeamInput[] | ScoutingCategoryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ScoutingCategoryCreateOrConnectWithoutTeamInput | ScoutingCategoryCreateOrConnectWithoutTeamInput[]
    createMany?: ScoutingCategoryCreateManyTeamInputEnvelope
    connect?: ScoutingCategoryWhereUniqueInput | ScoutingCategoryWhereUniqueInput[]
  }

  export type ScoutingPlayerCreateNestedManyWithoutTeamInput = {
    create?: XOR<ScoutingPlayerCreateWithoutTeamInput, ScoutingPlayerUncheckedCreateWithoutTeamInput> | ScoutingPlayerCreateWithoutTeamInput[] | ScoutingPlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ScoutingPlayerCreateOrConnectWithoutTeamInput | ScoutingPlayerCreateOrConnectWithoutTeamInput[]
    createMany?: ScoutingPlayerCreateManyTeamInputEnvelope
    connect?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
  }

  export type TeamVideoCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamVideoCreateWithoutTeamInput, TeamVideoUncheckedCreateWithoutTeamInput> | TeamVideoCreateWithoutTeamInput[] | TeamVideoUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamVideoCreateOrConnectWithoutTeamInput | TeamVideoCreateOrConnectWithoutTeamInput[]
    createMany?: TeamVideoCreateManyTeamInputEnvelope
    connect?: TeamVideoWhereUniqueInput | TeamVideoWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutTeamInput = {
    create?: XOR<ReportCreateWithoutTeamInput, ReportUncheckedCreateWithoutTeamInput> | ReportCreateWithoutTeamInput[] | ReportUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTeamInput | ReportCreateOrConnectWithoutTeamInput[]
    createMany?: ReportCreateManyTeamInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type PlayerCreateNestedManyWithoutTeamInput = {
    create?: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput> | PlayerCreateWithoutTeamInput[] | PlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutTeamInput | PlayerCreateOrConnectWithoutTeamInput[]
    createMany?: PlayerCreateManyTeamInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type UserTeamUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<UserTeamCreateWithoutTeamInput, UserTeamUncheckedCreateWithoutTeamInput> | UserTeamCreateWithoutTeamInput[] | UserTeamUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserTeamCreateOrConnectWithoutTeamInput | UserTeamCreateOrConnectWithoutTeamInput[]
    createMany?: UserTeamCreateManyTeamInputEnvelope
    connect?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
  }

  export type RivalUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<RivalCreateWithoutTeamInput, RivalUncheckedCreateWithoutTeamInput> | RivalCreateWithoutTeamInput[] | RivalUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: RivalCreateOrConnectWithoutTeamInput | RivalCreateOrConnectWithoutTeamInput[]
    createMany?: RivalCreateManyTeamInputEnvelope
    connect?: RivalWhereUniqueInput | RivalWhereUniqueInput[]
  }

  export type PlayerFeedbackUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<PlayerFeedbackCreateWithoutTeamInput, PlayerFeedbackUncheckedCreateWithoutTeamInput> | PlayerFeedbackCreateWithoutTeamInput[] | PlayerFeedbackUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerFeedbackCreateOrConnectWithoutTeamInput | PlayerFeedbackCreateOrConnectWithoutTeamInput[]
    createMany?: PlayerFeedbackCreateManyTeamInputEnvelope
    connect?: PlayerFeedbackWhereUniqueInput | PlayerFeedbackWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<SessionCreateWithoutTeamInput, SessionUncheckedCreateWithoutTeamInput> | SessionCreateWithoutTeamInput[] | SessionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutTeamInput | SessionCreateOrConnectWithoutTeamInput[]
    createMany?: SessionCreateManyTeamInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PlaceUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<PlaceCreateWithoutTeamInput, PlaceUncheckedCreateWithoutTeamInput> | PlaceCreateWithoutTeamInput[] | PlaceUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutTeamInput | PlaceCreateOrConnectWithoutTeamInput[]
    createMany?: PlaceCreateManyTeamInputEnvelope
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
  }

  export type PlannerPrefsUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<PlannerPrefsCreateWithoutTeamInput, PlannerPrefsUncheckedCreateWithoutTeamInput> | PlannerPrefsCreateWithoutTeamInput[] | PlannerPrefsUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlannerPrefsCreateOrConnectWithoutTeamInput | PlannerPrefsCreateOrConnectWithoutTeamInput[]
    createMany?: PlannerPrefsCreateManyTeamInputEnvelope
    connect?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
  }

  export type ScoutingCategoryUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<ScoutingCategoryCreateWithoutTeamInput, ScoutingCategoryUncheckedCreateWithoutTeamInput> | ScoutingCategoryCreateWithoutTeamInput[] | ScoutingCategoryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ScoutingCategoryCreateOrConnectWithoutTeamInput | ScoutingCategoryCreateOrConnectWithoutTeamInput[]
    createMany?: ScoutingCategoryCreateManyTeamInputEnvelope
    connect?: ScoutingCategoryWhereUniqueInput | ScoutingCategoryWhereUniqueInput[]
  }

  export type ScoutingPlayerUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<ScoutingPlayerCreateWithoutTeamInput, ScoutingPlayerUncheckedCreateWithoutTeamInput> | ScoutingPlayerCreateWithoutTeamInput[] | ScoutingPlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ScoutingPlayerCreateOrConnectWithoutTeamInput | ScoutingPlayerCreateOrConnectWithoutTeamInput[]
    createMany?: ScoutingPlayerCreateManyTeamInputEnvelope
    connect?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
  }

  export type TeamVideoUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamVideoCreateWithoutTeamInput, TeamVideoUncheckedCreateWithoutTeamInput> | TeamVideoCreateWithoutTeamInput[] | TeamVideoUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamVideoCreateOrConnectWithoutTeamInput | TeamVideoCreateOrConnectWithoutTeamInput[]
    createMany?: TeamVideoCreateManyTeamInputEnvelope
    connect?: TeamVideoWhereUniqueInput | TeamVideoWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<ReportCreateWithoutTeamInput, ReportUncheckedCreateWithoutTeamInput> | ReportCreateWithoutTeamInput[] | ReportUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTeamInput | ReportCreateOrConnectWithoutTeamInput[]
    createMany?: ReportCreateManyTeamInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type PlayerUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput> | PlayerCreateWithoutTeamInput[] | PlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutTeamInput | PlayerCreateOrConnectWithoutTeamInput[]
    createMany?: PlayerCreateManyTeamInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserTeamUpdateManyWithoutTeamNestedInput = {
    create?: XOR<UserTeamCreateWithoutTeamInput, UserTeamUncheckedCreateWithoutTeamInput> | UserTeamCreateWithoutTeamInput[] | UserTeamUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserTeamCreateOrConnectWithoutTeamInput | UserTeamCreateOrConnectWithoutTeamInput[]
    upsert?: UserTeamUpsertWithWhereUniqueWithoutTeamInput | UserTeamUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: UserTeamCreateManyTeamInputEnvelope
    set?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
    disconnect?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
    delete?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
    connect?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
    update?: UserTeamUpdateWithWhereUniqueWithoutTeamInput | UserTeamUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: UserTeamUpdateManyWithWhereWithoutTeamInput | UserTeamUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: UserTeamScalarWhereInput | UserTeamScalarWhereInput[]
  }

  export type RivalUpdateManyWithoutTeamNestedInput = {
    create?: XOR<RivalCreateWithoutTeamInput, RivalUncheckedCreateWithoutTeamInput> | RivalCreateWithoutTeamInput[] | RivalUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: RivalCreateOrConnectWithoutTeamInput | RivalCreateOrConnectWithoutTeamInput[]
    upsert?: RivalUpsertWithWhereUniqueWithoutTeamInput | RivalUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: RivalCreateManyTeamInputEnvelope
    set?: RivalWhereUniqueInput | RivalWhereUniqueInput[]
    disconnect?: RivalWhereUniqueInput | RivalWhereUniqueInput[]
    delete?: RivalWhereUniqueInput | RivalWhereUniqueInput[]
    connect?: RivalWhereUniqueInput | RivalWhereUniqueInput[]
    update?: RivalUpdateWithWhereUniqueWithoutTeamInput | RivalUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: RivalUpdateManyWithWhereWithoutTeamInput | RivalUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: RivalScalarWhereInput | RivalScalarWhereInput[]
  }

  export type PlayerFeedbackUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PlayerFeedbackCreateWithoutTeamInput, PlayerFeedbackUncheckedCreateWithoutTeamInput> | PlayerFeedbackCreateWithoutTeamInput[] | PlayerFeedbackUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerFeedbackCreateOrConnectWithoutTeamInput | PlayerFeedbackCreateOrConnectWithoutTeamInput[]
    upsert?: PlayerFeedbackUpsertWithWhereUniqueWithoutTeamInput | PlayerFeedbackUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PlayerFeedbackCreateManyTeamInputEnvelope
    set?: PlayerFeedbackWhereUniqueInput | PlayerFeedbackWhereUniqueInput[]
    disconnect?: PlayerFeedbackWhereUniqueInput | PlayerFeedbackWhereUniqueInput[]
    delete?: PlayerFeedbackWhereUniqueInput | PlayerFeedbackWhereUniqueInput[]
    connect?: PlayerFeedbackWhereUniqueInput | PlayerFeedbackWhereUniqueInput[]
    update?: PlayerFeedbackUpdateWithWhereUniqueWithoutTeamInput | PlayerFeedbackUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PlayerFeedbackUpdateManyWithWhereWithoutTeamInput | PlayerFeedbackUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PlayerFeedbackScalarWhereInput | PlayerFeedbackScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutTeamNestedInput = {
    create?: XOR<SessionCreateWithoutTeamInput, SessionUncheckedCreateWithoutTeamInput> | SessionCreateWithoutTeamInput[] | SessionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutTeamInput | SessionCreateOrConnectWithoutTeamInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutTeamInput | SessionUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: SessionCreateManyTeamInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutTeamInput | SessionUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutTeamInput | SessionUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PlaceUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PlaceCreateWithoutTeamInput, PlaceUncheckedCreateWithoutTeamInput> | PlaceCreateWithoutTeamInput[] | PlaceUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutTeamInput | PlaceCreateOrConnectWithoutTeamInput[]
    upsert?: PlaceUpsertWithWhereUniqueWithoutTeamInput | PlaceUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PlaceCreateManyTeamInputEnvelope
    set?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    disconnect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    delete?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    update?: PlaceUpdateWithWhereUniqueWithoutTeamInput | PlaceUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PlaceUpdateManyWithWhereWithoutTeamInput | PlaceUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
  }

  export type PlannerPrefsUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PlannerPrefsCreateWithoutTeamInput, PlannerPrefsUncheckedCreateWithoutTeamInput> | PlannerPrefsCreateWithoutTeamInput[] | PlannerPrefsUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlannerPrefsCreateOrConnectWithoutTeamInput | PlannerPrefsCreateOrConnectWithoutTeamInput[]
    upsert?: PlannerPrefsUpsertWithWhereUniqueWithoutTeamInput | PlannerPrefsUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PlannerPrefsCreateManyTeamInputEnvelope
    set?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
    disconnect?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
    delete?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
    connect?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
    update?: PlannerPrefsUpdateWithWhereUniqueWithoutTeamInput | PlannerPrefsUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PlannerPrefsUpdateManyWithWhereWithoutTeamInput | PlannerPrefsUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PlannerPrefsScalarWhereInput | PlannerPrefsScalarWhereInput[]
  }

  export type ScoutingCategoryUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ScoutingCategoryCreateWithoutTeamInput, ScoutingCategoryUncheckedCreateWithoutTeamInput> | ScoutingCategoryCreateWithoutTeamInput[] | ScoutingCategoryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ScoutingCategoryCreateOrConnectWithoutTeamInput | ScoutingCategoryCreateOrConnectWithoutTeamInput[]
    upsert?: ScoutingCategoryUpsertWithWhereUniqueWithoutTeamInput | ScoutingCategoryUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ScoutingCategoryCreateManyTeamInputEnvelope
    set?: ScoutingCategoryWhereUniqueInput | ScoutingCategoryWhereUniqueInput[]
    disconnect?: ScoutingCategoryWhereUniqueInput | ScoutingCategoryWhereUniqueInput[]
    delete?: ScoutingCategoryWhereUniqueInput | ScoutingCategoryWhereUniqueInput[]
    connect?: ScoutingCategoryWhereUniqueInput | ScoutingCategoryWhereUniqueInput[]
    update?: ScoutingCategoryUpdateWithWhereUniqueWithoutTeamInput | ScoutingCategoryUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ScoutingCategoryUpdateManyWithWhereWithoutTeamInput | ScoutingCategoryUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ScoutingCategoryScalarWhereInput | ScoutingCategoryScalarWhereInput[]
  }

  export type ScoutingPlayerUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ScoutingPlayerCreateWithoutTeamInput, ScoutingPlayerUncheckedCreateWithoutTeamInput> | ScoutingPlayerCreateWithoutTeamInput[] | ScoutingPlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ScoutingPlayerCreateOrConnectWithoutTeamInput | ScoutingPlayerCreateOrConnectWithoutTeamInput[]
    upsert?: ScoutingPlayerUpsertWithWhereUniqueWithoutTeamInput | ScoutingPlayerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ScoutingPlayerCreateManyTeamInputEnvelope
    set?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
    disconnect?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
    delete?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
    connect?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
    update?: ScoutingPlayerUpdateWithWhereUniqueWithoutTeamInput | ScoutingPlayerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ScoutingPlayerUpdateManyWithWhereWithoutTeamInput | ScoutingPlayerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ScoutingPlayerScalarWhereInput | ScoutingPlayerScalarWhereInput[]
  }

  export type TeamVideoUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamVideoCreateWithoutTeamInput, TeamVideoUncheckedCreateWithoutTeamInput> | TeamVideoCreateWithoutTeamInput[] | TeamVideoUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamVideoCreateOrConnectWithoutTeamInput | TeamVideoCreateOrConnectWithoutTeamInput[]
    upsert?: TeamVideoUpsertWithWhereUniqueWithoutTeamInput | TeamVideoUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamVideoCreateManyTeamInputEnvelope
    set?: TeamVideoWhereUniqueInput | TeamVideoWhereUniqueInput[]
    disconnect?: TeamVideoWhereUniqueInput | TeamVideoWhereUniqueInput[]
    delete?: TeamVideoWhereUniqueInput | TeamVideoWhereUniqueInput[]
    connect?: TeamVideoWhereUniqueInput | TeamVideoWhereUniqueInput[]
    update?: TeamVideoUpdateWithWhereUniqueWithoutTeamInput | TeamVideoUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamVideoUpdateManyWithWhereWithoutTeamInput | TeamVideoUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamVideoScalarWhereInput | TeamVideoScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ReportCreateWithoutTeamInput, ReportUncheckedCreateWithoutTeamInput> | ReportCreateWithoutTeamInput[] | ReportUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTeamInput | ReportCreateOrConnectWithoutTeamInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutTeamInput | ReportUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ReportCreateManyTeamInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutTeamInput | ReportUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutTeamInput | ReportUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type PlayerUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput> | PlayerCreateWithoutTeamInput[] | PlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutTeamInput | PlayerCreateOrConnectWithoutTeamInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutTeamInput | PlayerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PlayerCreateManyTeamInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutTeamInput | PlayerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutTeamInput | PlayerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type UserTeamUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<UserTeamCreateWithoutTeamInput, UserTeamUncheckedCreateWithoutTeamInput> | UserTeamCreateWithoutTeamInput[] | UserTeamUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserTeamCreateOrConnectWithoutTeamInput | UserTeamCreateOrConnectWithoutTeamInput[]
    upsert?: UserTeamUpsertWithWhereUniqueWithoutTeamInput | UserTeamUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: UserTeamCreateManyTeamInputEnvelope
    set?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
    disconnect?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
    delete?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
    connect?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
    update?: UserTeamUpdateWithWhereUniqueWithoutTeamInput | UserTeamUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: UserTeamUpdateManyWithWhereWithoutTeamInput | UserTeamUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: UserTeamScalarWhereInput | UserTeamScalarWhereInput[]
  }

  export type RivalUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<RivalCreateWithoutTeamInput, RivalUncheckedCreateWithoutTeamInput> | RivalCreateWithoutTeamInput[] | RivalUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: RivalCreateOrConnectWithoutTeamInput | RivalCreateOrConnectWithoutTeamInput[]
    upsert?: RivalUpsertWithWhereUniqueWithoutTeamInput | RivalUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: RivalCreateManyTeamInputEnvelope
    set?: RivalWhereUniqueInput | RivalWhereUniqueInput[]
    disconnect?: RivalWhereUniqueInput | RivalWhereUniqueInput[]
    delete?: RivalWhereUniqueInput | RivalWhereUniqueInput[]
    connect?: RivalWhereUniqueInput | RivalWhereUniqueInput[]
    update?: RivalUpdateWithWhereUniqueWithoutTeamInput | RivalUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: RivalUpdateManyWithWhereWithoutTeamInput | RivalUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: RivalScalarWhereInput | RivalScalarWhereInput[]
  }

  export type PlayerFeedbackUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PlayerFeedbackCreateWithoutTeamInput, PlayerFeedbackUncheckedCreateWithoutTeamInput> | PlayerFeedbackCreateWithoutTeamInput[] | PlayerFeedbackUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerFeedbackCreateOrConnectWithoutTeamInput | PlayerFeedbackCreateOrConnectWithoutTeamInput[]
    upsert?: PlayerFeedbackUpsertWithWhereUniqueWithoutTeamInput | PlayerFeedbackUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PlayerFeedbackCreateManyTeamInputEnvelope
    set?: PlayerFeedbackWhereUniqueInput | PlayerFeedbackWhereUniqueInput[]
    disconnect?: PlayerFeedbackWhereUniqueInput | PlayerFeedbackWhereUniqueInput[]
    delete?: PlayerFeedbackWhereUniqueInput | PlayerFeedbackWhereUniqueInput[]
    connect?: PlayerFeedbackWhereUniqueInput | PlayerFeedbackWhereUniqueInput[]
    update?: PlayerFeedbackUpdateWithWhereUniqueWithoutTeamInput | PlayerFeedbackUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PlayerFeedbackUpdateManyWithWhereWithoutTeamInput | PlayerFeedbackUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PlayerFeedbackScalarWhereInput | PlayerFeedbackScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<SessionCreateWithoutTeamInput, SessionUncheckedCreateWithoutTeamInput> | SessionCreateWithoutTeamInput[] | SessionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutTeamInput | SessionCreateOrConnectWithoutTeamInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutTeamInput | SessionUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: SessionCreateManyTeamInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutTeamInput | SessionUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutTeamInput | SessionUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PlaceUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PlaceCreateWithoutTeamInput, PlaceUncheckedCreateWithoutTeamInput> | PlaceCreateWithoutTeamInput[] | PlaceUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutTeamInput | PlaceCreateOrConnectWithoutTeamInput[]
    upsert?: PlaceUpsertWithWhereUniqueWithoutTeamInput | PlaceUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PlaceCreateManyTeamInputEnvelope
    set?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    disconnect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    delete?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    update?: PlaceUpdateWithWhereUniqueWithoutTeamInput | PlaceUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PlaceUpdateManyWithWhereWithoutTeamInput | PlaceUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
  }

  export type PlannerPrefsUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PlannerPrefsCreateWithoutTeamInput, PlannerPrefsUncheckedCreateWithoutTeamInput> | PlannerPrefsCreateWithoutTeamInput[] | PlannerPrefsUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlannerPrefsCreateOrConnectWithoutTeamInput | PlannerPrefsCreateOrConnectWithoutTeamInput[]
    upsert?: PlannerPrefsUpsertWithWhereUniqueWithoutTeamInput | PlannerPrefsUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PlannerPrefsCreateManyTeamInputEnvelope
    set?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
    disconnect?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
    delete?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
    connect?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
    update?: PlannerPrefsUpdateWithWhereUniqueWithoutTeamInput | PlannerPrefsUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PlannerPrefsUpdateManyWithWhereWithoutTeamInput | PlannerPrefsUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PlannerPrefsScalarWhereInput | PlannerPrefsScalarWhereInput[]
  }

  export type ScoutingCategoryUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ScoutingCategoryCreateWithoutTeamInput, ScoutingCategoryUncheckedCreateWithoutTeamInput> | ScoutingCategoryCreateWithoutTeamInput[] | ScoutingCategoryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ScoutingCategoryCreateOrConnectWithoutTeamInput | ScoutingCategoryCreateOrConnectWithoutTeamInput[]
    upsert?: ScoutingCategoryUpsertWithWhereUniqueWithoutTeamInput | ScoutingCategoryUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ScoutingCategoryCreateManyTeamInputEnvelope
    set?: ScoutingCategoryWhereUniqueInput | ScoutingCategoryWhereUniqueInput[]
    disconnect?: ScoutingCategoryWhereUniqueInput | ScoutingCategoryWhereUniqueInput[]
    delete?: ScoutingCategoryWhereUniqueInput | ScoutingCategoryWhereUniqueInput[]
    connect?: ScoutingCategoryWhereUniqueInput | ScoutingCategoryWhereUniqueInput[]
    update?: ScoutingCategoryUpdateWithWhereUniqueWithoutTeamInput | ScoutingCategoryUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ScoutingCategoryUpdateManyWithWhereWithoutTeamInput | ScoutingCategoryUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ScoutingCategoryScalarWhereInput | ScoutingCategoryScalarWhereInput[]
  }

  export type ScoutingPlayerUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ScoutingPlayerCreateWithoutTeamInput, ScoutingPlayerUncheckedCreateWithoutTeamInput> | ScoutingPlayerCreateWithoutTeamInput[] | ScoutingPlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ScoutingPlayerCreateOrConnectWithoutTeamInput | ScoutingPlayerCreateOrConnectWithoutTeamInput[]
    upsert?: ScoutingPlayerUpsertWithWhereUniqueWithoutTeamInput | ScoutingPlayerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ScoutingPlayerCreateManyTeamInputEnvelope
    set?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
    disconnect?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
    delete?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
    connect?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
    update?: ScoutingPlayerUpdateWithWhereUniqueWithoutTeamInput | ScoutingPlayerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ScoutingPlayerUpdateManyWithWhereWithoutTeamInput | ScoutingPlayerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ScoutingPlayerScalarWhereInput | ScoutingPlayerScalarWhereInput[]
  }

  export type TeamVideoUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamVideoCreateWithoutTeamInput, TeamVideoUncheckedCreateWithoutTeamInput> | TeamVideoCreateWithoutTeamInput[] | TeamVideoUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamVideoCreateOrConnectWithoutTeamInput | TeamVideoCreateOrConnectWithoutTeamInput[]
    upsert?: TeamVideoUpsertWithWhereUniqueWithoutTeamInput | TeamVideoUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamVideoCreateManyTeamInputEnvelope
    set?: TeamVideoWhereUniqueInput | TeamVideoWhereUniqueInput[]
    disconnect?: TeamVideoWhereUniqueInput | TeamVideoWhereUniqueInput[]
    delete?: TeamVideoWhereUniqueInput | TeamVideoWhereUniqueInput[]
    connect?: TeamVideoWhereUniqueInput | TeamVideoWhereUniqueInput[]
    update?: TeamVideoUpdateWithWhereUniqueWithoutTeamInput | TeamVideoUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamVideoUpdateManyWithWhereWithoutTeamInput | TeamVideoUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamVideoScalarWhereInput | TeamVideoScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ReportCreateWithoutTeamInput, ReportUncheckedCreateWithoutTeamInput> | ReportCreateWithoutTeamInput[] | ReportUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTeamInput | ReportCreateOrConnectWithoutTeamInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutTeamInput | ReportUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ReportCreateManyTeamInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutTeamInput | ReportUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutTeamInput | ReportUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type PlayerUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput> | PlayerCreateWithoutTeamInput[] | PlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutTeamInput | PlayerCreateOrConnectWithoutTeamInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutTeamInput | PlayerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PlayerCreateManyTeamInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutTeamInput | PlayerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutTeamInput | PlayerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type RPEEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<RPEEntryCreateWithoutUserInput, RPEEntryUncheckedCreateWithoutUserInput> | RPEEntryCreateWithoutUserInput[] | RPEEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RPEEntryCreateOrConnectWithoutUserInput | RPEEntryCreateOrConnectWithoutUserInput[]
    createMany?: RPEEntryCreateManyUserInputEnvelope
    connect?: RPEEntryWhereUniqueInput | RPEEntryWhereUniqueInput[]
  }

  export type WellnessEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<WellnessEntryCreateWithoutUserInput, WellnessEntryUncheckedCreateWithoutUserInput> | WellnessEntryCreateWithoutUserInput[] | WellnessEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WellnessEntryCreateOrConnectWithoutUserInput | WellnessEntryCreateOrConnectWithoutUserInput[]
    createMany?: WellnessEntryCreateManyUserInputEnvelope
    connect?: WellnessEntryWhereUniqueInput | WellnessEntryWhereUniqueInput[]
  }

  export type PlannerPrefsCreateNestedManyWithoutUserInput = {
    create?: XOR<PlannerPrefsCreateWithoutUserInput, PlannerPrefsUncheckedCreateWithoutUserInput> | PlannerPrefsCreateWithoutUserInput[] | PlannerPrefsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlannerPrefsCreateOrConnectWithoutUserInput | PlannerPrefsCreateOrConnectWithoutUserInput[]
    createMany?: PlannerPrefsCreateManyUserInputEnvelope
    connect?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
  }

  export type ExerciseCreateNestedManyWithoutUserInput = {
    create?: XOR<ExerciseCreateWithoutUserInput, ExerciseUncheckedCreateWithoutUserInput> | ExerciseCreateWithoutUserInput[] | ExerciseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutUserInput | ExerciseCreateOrConnectWithoutUserInput[]
    createMany?: ExerciseCreateManyUserInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ClinicalEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<ClinicalEntryCreateWithoutUserInput, ClinicalEntryUncheckedCreateWithoutUserInput> | ClinicalEntryCreateWithoutUserInput[] | ClinicalEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClinicalEntryCreateOrConnectWithoutUserInput | ClinicalEntryCreateOrConnectWithoutUserInput[]
    createMany?: ClinicalEntryCreateManyUserInputEnvelope
    connect?: ClinicalEntryWhereUniqueInput | ClinicalEntryWhereUniqueInput[]
  }

  export type UserTeamCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTeamCreateWithoutUserInput, UserTeamUncheckedCreateWithoutUserInput> | UserTeamCreateWithoutUserInput[] | UserTeamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTeamCreateOrConnectWithoutUserInput | UserTeamCreateOrConnectWithoutUserInput[]
    createMany?: UserTeamCreateManyUserInputEnvelope
    connect?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ReportCreateWithoutAuthorInput, ReportUncheckedCreateWithoutAuthorInput> | ReportCreateWithoutAuthorInput[] | ReportUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAuthorInput | ReportCreateOrConnectWithoutAuthorInput[]
    createMany?: ReportCreateManyAuthorInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type PlayerCreateNestedManyWithoutUserInput = {
    create?: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput> | PlayerCreateWithoutUserInput[] | PlayerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutUserInput | PlayerCreateOrConnectWithoutUserInput[]
    createMany?: PlayerCreateManyUserInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type RPEEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RPEEntryCreateWithoutUserInput, RPEEntryUncheckedCreateWithoutUserInput> | RPEEntryCreateWithoutUserInput[] | RPEEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RPEEntryCreateOrConnectWithoutUserInput | RPEEntryCreateOrConnectWithoutUserInput[]
    createMany?: RPEEntryCreateManyUserInputEnvelope
    connect?: RPEEntryWhereUniqueInput | RPEEntryWhereUniqueInput[]
  }

  export type WellnessEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WellnessEntryCreateWithoutUserInput, WellnessEntryUncheckedCreateWithoutUserInput> | WellnessEntryCreateWithoutUserInput[] | WellnessEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WellnessEntryCreateOrConnectWithoutUserInput | WellnessEntryCreateOrConnectWithoutUserInput[]
    createMany?: WellnessEntryCreateManyUserInputEnvelope
    connect?: WellnessEntryWhereUniqueInput | WellnessEntryWhereUniqueInput[]
  }

  export type PlannerPrefsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlannerPrefsCreateWithoutUserInput, PlannerPrefsUncheckedCreateWithoutUserInput> | PlannerPrefsCreateWithoutUserInput[] | PlannerPrefsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlannerPrefsCreateOrConnectWithoutUserInput | PlannerPrefsCreateOrConnectWithoutUserInput[]
    createMany?: PlannerPrefsCreateManyUserInputEnvelope
    connect?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
  }

  export type ExerciseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExerciseCreateWithoutUserInput, ExerciseUncheckedCreateWithoutUserInput> | ExerciseCreateWithoutUserInput[] | ExerciseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutUserInput | ExerciseCreateOrConnectWithoutUserInput[]
    createMany?: ExerciseCreateManyUserInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ClinicalEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClinicalEntryCreateWithoutUserInput, ClinicalEntryUncheckedCreateWithoutUserInput> | ClinicalEntryCreateWithoutUserInput[] | ClinicalEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClinicalEntryCreateOrConnectWithoutUserInput | ClinicalEntryCreateOrConnectWithoutUserInput[]
    createMany?: ClinicalEntryCreateManyUserInputEnvelope
    connect?: ClinicalEntryWhereUniqueInput | ClinicalEntryWhereUniqueInput[]
  }

  export type UserTeamUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTeamCreateWithoutUserInput, UserTeamUncheckedCreateWithoutUserInput> | UserTeamCreateWithoutUserInput[] | UserTeamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTeamCreateOrConnectWithoutUserInput | UserTeamCreateOrConnectWithoutUserInput[]
    createMany?: UserTeamCreateManyUserInputEnvelope
    connect?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ReportCreateWithoutAuthorInput, ReportUncheckedCreateWithoutAuthorInput> | ReportCreateWithoutAuthorInput[] | ReportUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAuthorInput | ReportCreateOrConnectWithoutAuthorInput[]
    createMany?: ReportCreateManyAuthorInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type PlayerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput> | PlayerCreateWithoutUserInput[] | PlayerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutUserInput | PlayerCreateOrConnectWithoutUserInput[]
    createMany?: PlayerCreateManyUserInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type RPEEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<RPEEntryCreateWithoutUserInput, RPEEntryUncheckedCreateWithoutUserInput> | RPEEntryCreateWithoutUserInput[] | RPEEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RPEEntryCreateOrConnectWithoutUserInput | RPEEntryCreateOrConnectWithoutUserInput[]
    upsert?: RPEEntryUpsertWithWhereUniqueWithoutUserInput | RPEEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RPEEntryCreateManyUserInputEnvelope
    set?: RPEEntryWhereUniqueInput | RPEEntryWhereUniqueInput[]
    disconnect?: RPEEntryWhereUniqueInput | RPEEntryWhereUniqueInput[]
    delete?: RPEEntryWhereUniqueInput | RPEEntryWhereUniqueInput[]
    connect?: RPEEntryWhereUniqueInput | RPEEntryWhereUniqueInput[]
    update?: RPEEntryUpdateWithWhereUniqueWithoutUserInput | RPEEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RPEEntryUpdateManyWithWhereWithoutUserInput | RPEEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RPEEntryScalarWhereInput | RPEEntryScalarWhereInput[]
  }

  export type WellnessEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<WellnessEntryCreateWithoutUserInput, WellnessEntryUncheckedCreateWithoutUserInput> | WellnessEntryCreateWithoutUserInput[] | WellnessEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WellnessEntryCreateOrConnectWithoutUserInput | WellnessEntryCreateOrConnectWithoutUserInput[]
    upsert?: WellnessEntryUpsertWithWhereUniqueWithoutUserInput | WellnessEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WellnessEntryCreateManyUserInputEnvelope
    set?: WellnessEntryWhereUniqueInput | WellnessEntryWhereUniqueInput[]
    disconnect?: WellnessEntryWhereUniqueInput | WellnessEntryWhereUniqueInput[]
    delete?: WellnessEntryWhereUniqueInput | WellnessEntryWhereUniqueInput[]
    connect?: WellnessEntryWhereUniqueInput | WellnessEntryWhereUniqueInput[]
    update?: WellnessEntryUpdateWithWhereUniqueWithoutUserInput | WellnessEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WellnessEntryUpdateManyWithWhereWithoutUserInput | WellnessEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WellnessEntryScalarWhereInput | WellnessEntryScalarWhereInput[]
  }

  export type PlannerPrefsUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlannerPrefsCreateWithoutUserInput, PlannerPrefsUncheckedCreateWithoutUserInput> | PlannerPrefsCreateWithoutUserInput[] | PlannerPrefsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlannerPrefsCreateOrConnectWithoutUserInput | PlannerPrefsCreateOrConnectWithoutUserInput[]
    upsert?: PlannerPrefsUpsertWithWhereUniqueWithoutUserInput | PlannerPrefsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlannerPrefsCreateManyUserInputEnvelope
    set?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
    disconnect?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
    delete?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
    connect?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
    update?: PlannerPrefsUpdateWithWhereUniqueWithoutUserInput | PlannerPrefsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlannerPrefsUpdateManyWithWhereWithoutUserInput | PlannerPrefsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlannerPrefsScalarWhereInput | PlannerPrefsScalarWhereInput[]
  }

  export type ExerciseUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExerciseCreateWithoutUserInput, ExerciseUncheckedCreateWithoutUserInput> | ExerciseCreateWithoutUserInput[] | ExerciseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutUserInput | ExerciseCreateOrConnectWithoutUserInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutUserInput | ExerciseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExerciseCreateManyUserInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutUserInput | ExerciseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutUserInput | ExerciseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ClinicalEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClinicalEntryCreateWithoutUserInput, ClinicalEntryUncheckedCreateWithoutUserInput> | ClinicalEntryCreateWithoutUserInput[] | ClinicalEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClinicalEntryCreateOrConnectWithoutUserInput | ClinicalEntryCreateOrConnectWithoutUserInput[]
    upsert?: ClinicalEntryUpsertWithWhereUniqueWithoutUserInput | ClinicalEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClinicalEntryCreateManyUserInputEnvelope
    set?: ClinicalEntryWhereUniqueInput | ClinicalEntryWhereUniqueInput[]
    disconnect?: ClinicalEntryWhereUniqueInput | ClinicalEntryWhereUniqueInput[]
    delete?: ClinicalEntryWhereUniqueInput | ClinicalEntryWhereUniqueInput[]
    connect?: ClinicalEntryWhereUniqueInput | ClinicalEntryWhereUniqueInput[]
    update?: ClinicalEntryUpdateWithWhereUniqueWithoutUserInput | ClinicalEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClinicalEntryUpdateManyWithWhereWithoutUserInput | ClinicalEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClinicalEntryScalarWhereInput | ClinicalEntryScalarWhereInput[]
  }

  export type UserTeamUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTeamCreateWithoutUserInput, UserTeamUncheckedCreateWithoutUserInput> | UserTeamCreateWithoutUserInput[] | UserTeamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTeamCreateOrConnectWithoutUserInput | UserTeamCreateOrConnectWithoutUserInput[]
    upsert?: UserTeamUpsertWithWhereUniqueWithoutUserInput | UserTeamUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTeamCreateManyUserInputEnvelope
    set?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
    disconnect?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
    delete?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
    connect?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
    update?: UserTeamUpdateWithWhereUniqueWithoutUserInput | UserTeamUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTeamUpdateManyWithWhereWithoutUserInput | UserTeamUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTeamScalarWhereInput | UserTeamScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ReportCreateWithoutAuthorInput, ReportUncheckedCreateWithoutAuthorInput> | ReportCreateWithoutAuthorInput[] | ReportUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAuthorInput | ReportCreateOrConnectWithoutAuthorInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutAuthorInput | ReportUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ReportCreateManyAuthorInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutAuthorInput | ReportUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutAuthorInput | ReportUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type PlayerUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput> | PlayerCreateWithoutUserInput[] | PlayerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutUserInput | PlayerCreateOrConnectWithoutUserInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutUserInput | PlayerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlayerCreateManyUserInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutUserInput | PlayerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutUserInput | PlayerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type RPEEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RPEEntryCreateWithoutUserInput, RPEEntryUncheckedCreateWithoutUserInput> | RPEEntryCreateWithoutUserInput[] | RPEEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RPEEntryCreateOrConnectWithoutUserInput | RPEEntryCreateOrConnectWithoutUserInput[]
    upsert?: RPEEntryUpsertWithWhereUniqueWithoutUserInput | RPEEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RPEEntryCreateManyUserInputEnvelope
    set?: RPEEntryWhereUniqueInput | RPEEntryWhereUniqueInput[]
    disconnect?: RPEEntryWhereUniqueInput | RPEEntryWhereUniqueInput[]
    delete?: RPEEntryWhereUniqueInput | RPEEntryWhereUniqueInput[]
    connect?: RPEEntryWhereUniqueInput | RPEEntryWhereUniqueInput[]
    update?: RPEEntryUpdateWithWhereUniqueWithoutUserInput | RPEEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RPEEntryUpdateManyWithWhereWithoutUserInput | RPEEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RPEEntryScalarWhereInput | RPEEntryScalarWhereInput[]
  }

  export type WellnessEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WellnessEntryCreateWithoutUserInput, WellnessEntryUncheckedCreateWithoutUserInput> | WellnessEntryCreateWithoutUserInput[] | WellnessEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WellnessEntryCreateOrConnectWithoutUserInput | WellnessEntryCreateOrConnectWithoutUserInput[]
    upsert?: WellnessEntryUpsertWithWhereUniqueWithoutUserInput | WellnessEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WellnessEntryCreateManyUserInputEnvelope
    set?: WellnessEntryWhereUniqueInput | WellnessEntryWhereUniqueInput[]
    disconnect?: WellnessEntryWhereUniqueInput | WellnessEntryWhereUniqueInput[]
    delete?: WellnessEntryWhereUniqueInput | WellnessEntryWhereUniqueInput[]
    connect?: WellnessEntryWhereUniqueInput | WellnessEntryWhereUniqueInput[]
    update?: WellnessEntryUpdateWithWhereUniqueWithoutUserInput | WellnessEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WellnessEntryUpdateManyWithWhereWithoutUserInput | WellnessEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WellnessEntryScalarWhereInput | WellnessEntryScalarWhereInput[]
  }

  export type PlannerPrefsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlannerPrefsCreateWithoutUserInput, PlannerPrefsUncheckedCreateWithoutUserInput> | PlannerPrefsCreateWithoutUserInput[] | PlannerPrefsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlannerPrefsCreateOrConnectWithoutUserInput | PlannerPrefsCreateOrConnectWithoutUserInput[]
    upsert?: PlannerPrefsUpsertWithWhereUniqueWithoutUserInput | PlannerPrefsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlannerPrefsCreateManyUserInputEnvelope
    set?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
    disconnect?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
    delete?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
    connect?: PlannerPrefsWhereUniqueInput | PlannerPrefsWhereUniqueInput[]
    update?: PlannerPrefsUpdateWithWhereUniqueWithoutUserInput | PlannerPrefsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlannerPrefsUpdateManyWithWhereWithoutUserInput | PlannerPrefsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlannerPrefsScalarWhereInput | PlannerPrefsScalarWhereInput[]
  }

  export type ExerciseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExerciseCreateWithoutUserInput, ExerciseUncheckedCreateWithoutUserInput> | ExerciseCreateWithoutUserInput[] | ExerciseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutUserInput | ExerciseCreateOrConnectWithoutUserInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutUserInput | ExerciseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExerciseCreateManyUserInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutUserInput | ExerciseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutUserInput | ExerciseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ClinicalEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClinicalEntryCreateWithoutUserInput, ClinicalEntryUncheckedCreateWithoutUserInput> | ClinicalEntryCreateWithoutUserInput[] | ClinicalEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClinicalEntryCreateOrConnectWithoutUserInput | ClinicalEntryCreateOrConnectWithoutUserInput[]
    upsert?: ClinicalEntryUpsertWithWhereUniqueWithoutUserInput | ClinicalEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClinicalEntryCreateManyUserInputEnvelope
    set?: ClinicalEntryWhereUniqueInput | ClinicalEntryWhereUniqueInput[]
    disconnect?: ClinicalEntryWhereUniqueInput | ClinicalEntryWhereUniqueInput[]
    delete?: ClinicalEntryWhereUniqueInput | ClinicalEntryWhereUniqueInput[]
    connect?: ClinicalEntryWhereUniqueInput | ClinicalEntryWhereUniqueInput[]
    update?: ClinicalEntryUpdateWithWhereUniqueWithoutUserInput | ClinicalEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClinicalEntryUpdateManyWithWhereWithoutUserInput | ClinicalEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClinicalEntryScalarWhereInput | ClinicalEntryScalarWhereInput[]
  }

  export type UserTeamUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTeamCreateWithoutUserInput, UserTeamUncheckedCreateWithoutUserInput> | UserTeamCreateWithoutUserInput[] | UserTeamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTeamCreateOrConnectWithoutUserInput | UserTeamCreateOrConnectWithoutUserInput[]
    upsert?: UserTeamUpsertWithWhereUniqueWithoutUserInput | UserTeamUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTeamCreateManyUserInputEnvelope
    set?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
    disconnect?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
    delete?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
    connect?: UserTeamWhereUniqueInput | UserTeamWhereUniqueInput[]
    update?: UserTeamUpdateWithWhereUniqueWithoutUserInput | UserTeamUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTeamUpdateManyWithWhereWithoutUserInput | UserTeamUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTeamScalarWhereInput | UserTeamScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ReportCreateWithoutAuthorInput, ReportUncheckedCreateWithoutAuthorInput> | ReportCreateWithoutAuthorInput[] | ReportUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAuthorInput | ReportCreateOrConnectWithoutAuthorInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutAuthorInput | ReportUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ReportCreateManyAuthorInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutAuthorInput | ReportUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutAuthorInput | ReportUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type PlayerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput> | PlayerCreateWithoutUserInput[] | PlayerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutUserInput | PlayerCreateOrConnectWithoutUserInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutUserInput | PlayerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlayerCreateManyUserInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutUserInput | PlayerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutUserInput | PlayerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTeamsInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type EnumTeamRoleFieldUpdateOperationsInput = {
    set?: $Enums.TeamRole
  }

  export type UserUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput
    upsert?: UserUpsertWithoutTeamsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamsInput, UserUpdateWithoutTeamsInput>, UserUncheckedUpdateWithoutTeamsInput>
  }

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutSessionsInput = {
    create?: XOR<TeamCreateWithoutSessionsInput, TeamUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSessionsInput
    connect?: TeamWhereUniqueInput
  }

  export type EnumSessionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SessionType
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type TeamUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<TeamCreateWithoutSessionsInput, TeamUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSessionsInput
    upsert?: TeamUpsertWithoutSessionsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutSessionsInput, TeamUpdateWithoutSessionsInput>, TeamUncheckedUpdateWithoutSessionsInput>
  }

  export type TeamCreateNestedOneWithoutRivalsInput = {
    create?: XOR<TeamCreateWithoutRivalsInput, TeamUncheckedCreateWithoutRivalsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutRivalsInput
    connect?: TeamWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TeamUpdateOneRequiredWithoutRivalsNestedInput = {
    create?: XOR<TeamCreateWithoutRivalsInput, TeamUncheckedCreateWithoutRivalsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutRivalsInput
    upsert?: TeamUpsertWithoutRivalsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutRivalsInput, TeamUpdateWithoutRivalsInput>, TeamUncheckedUpdateWithoutRivalsInput>
  }

  export type TeamCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<TeamCreateWithoutFeedbackInput, TeamUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: TeamCreateOrConnectWithoutFeedbackInput
    connect?: TeamWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TeamUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<TeamCreateWithoutFeedbackInput, TeamUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: TeamCreateOrConnectWithoutFeedbackInput
    upsert?: TeamUpsertWithoutFeedbackInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutFeedbackInput, TeamUpdateWithoutFeedbackInput>, TeamUncheckedUpdateWithoutFeedbackInput>
  }

  export type TeamCreateNestedOneWithoutPlacesInput = {
    create?: XOR<TeamCreateWithoutPlacesInput, TeamUncheckedCreateWithoutPlacesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPlacesInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutPlacesNestedInput = {
    create?: XOR<TeamCreateWithoutPlacesInput, TeamUncheckedCreateWithoutPlacesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPlacesInput
    upsert?: TeamUpsertWithoutPlacesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutPlacesInput, TeamUpdateWithoutPlacesInput>, TeamUncheckedUpdateWithoutPlacesInput>
  }

  export type ExerciseCreateNestedManyWithoutKindInput = {
    create?: XOR<ExerciseCreateWithoutKindInput, ExerciseUncheckedCreateWithoutKindInput> | ExerciseCreateWithoutKindInput[] | ExerciseUncheckedCreateWithoutKindInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutKindInput | ExerciseCreateOrConnectWithoutKindInput[]
    createMany?: ExerciseCreateManyKindInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ExerciseUncheckedCreateNestedManyWithoutKindInput = {
    create?: XOR<ExerciseCreateWithoutKindInput, ExerciseUncheckedCreateWithoutKindInput> | ExerciseCreateWithoutKindInput[] | ExerciseUncheckedCreateWithoutKindInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutKindInput | ExerciseCreateOrConnectWithoutKindInput[]
    createMany?: ExerciseCreateManyKindInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ExerciseUpdateManyWithoutKindNestedInput = {
    create?: XOR<ExerciseCreateWithoutKindInput, ExerciseUncheckedCreateWithoutKindInput> | ExerciseCreateWithoutKindInput[] | ExerciseUncheckedCreateWithoutKindInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutKindInput | ExerciseCreateOrConnectWithoutKindInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutKindInput | ExerciseUpsertWithWhereUniqueWithoutKindInput[]
    createMany?: ExerciseCreateManyKindInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutKindInput | ExerciseUpdateWithWhereUniqueWithoutKindInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutKindInput | ExerciseUpdateManyWithWhereWithoutKindInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ExerciseUncheckedUpdateManyWithoutKindNestedInput = {
    create?: XOR<ExerciseCreateWithoutKindInput, ExerciseUncheckedCreateWithoutKindInput> | ExerciseCreateWithoutKindInput[] | ExerciseUncheckedCreateWithoutKindInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutKindInput | ExerciseCreateOrConnectWithoutKindInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutKindInput | ExerciseUpsertWithWhereUniqueWithoutKindInput[]
    createMany?: ExerciseCreateManyKindInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutKindInput | ExerciseUpdateWithWhereUniqueWithoutKindInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutKindInput | ExerciseUpdateManyWithWhereWithoutKindInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ExerciseCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutExercisesInput = {
    create?: XOR<UserCreateWithoutExercisesInput, UserUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExercisesInput
    connect?: UserWhereUniqueInput
  }

  export type ExerciseKindCreateNestedOneWithoutExercisesInput = {
    create?: XOR<ExerciseKindCreateWithoutExercisesInput, ExerciseKindUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: ExerciseKindCreateOrConnectWithoutExercisesInput
    connect?: ExerciseKindWhereUniqueInput
  }

  export type ExerciseUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutExercisesNestedInput = {
    create?: XOR<UserCreateWithoutExercisesInput, UserUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExercisesInput
    upsert?: UserUpsertWithoutExercisesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExercisesInput, UserUpdateWithoutExercisesInput>, UserUncheckedUpdateWithoutExercisesInput>
  }

  export type ExerciseKindUpdateOneWithoutExercisesNestedInput = {
    create?: XOR<ExerciseKindCreateWithoutExercisesInput, ExerciseKindUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: ExerciseKindCreateOrConnectWithoutExercisesInput
    upsert?: ExerciseKindUpsertWithoutExercisesInput
    disconnect?: ExerciseKindWhereInput | boolean
    delete?: ExerciseKindWhereInput | boolean
    connect?: ExerciseKindWhereUniqueInput
    update?: XOR<XOR<ExerciseKindUpdateToOneWithWhereWithoutExercisesInput, ExerciseKindUpdateWithoutExercisesInput>, ExerciseKindUncheckedUpdateWithoutExercisesInput>
  }

  export type UserCreateNestedOneWithoutRpeEntriesInput = {
    create?: XOR<UserCreateWithoutRpeEntriesInput, UserUncheckedCreateWithoutRpeEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRpeEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutRpeEntriesNestedInput = {
    create?: XOR<UserCreateWithoutRpeEntriesInput, UserUncheckedCreateWithoutRpeEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRpeEntriesInput
    upsert?: UserUpsertWithoutRpeEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRpeEntriesInput, UserUpdateWithoutRpeEntriesInput>, UserUncheckedUpdateWithoutRpeEntriesInput>
  }

  export type UserCreateNestedOneWithoutWellnessEntriesInput = {
    create?: XOR<UserCreateWithoutWellnessEntriesInput, UserUncheckedCreateWithoutWellnessEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWellnessEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutWellnessEntriesNestedInput = {
    create?: XOR<UserCreateWithoutWellnessEntriesInput, UserUncheckedCreateWithoutWellnessEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWellnessEntriesInput
    upsert?: UserUpsertWithoutWellnessEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWellnessEntriesInput, UserUpdateWithoutWellnessEntriesInput>, UserUncheckedUpdateWithoutWellnessEntriesInput>
  }

  export type UserCreateNestedOneWithoutPlannerPrefsInput = {
    create?: XOR<UserCreateWithoutPlannerPrefsInput, UserUncheckedCreateWithoutPlannerPrefsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlannerPrefsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutPlannerPrefsInput = {
    create?: XOR<TeamCreateWithoutPlannerPrefsInput, TeamUncheckedCreateWithoutPlannerPrefsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPlannerPrefsInput
    connect?: TeamWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPlannerPrefsNestedInput = {
    create?: XOR<UserCreateWithoutPlannerPrefsInput, UserUncheckedCreateWithoutPlannerPrefsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlannerPrefsInput
    upsert?: UserUpsertWithoutPlannerPrefsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlannerPrefsInput, UserUpdateWithoutPlannerPrefsInput>, UserUncheckedUpdateWithoutPlannerPrefsInput>
  }

  export type TeamUpdateOneRequiredWithoutPlannerPrefsNestedInput = {
    create?: XOR<TeamCreateWithoutPlannerPrefsInput, TeamUncheckedCreateWithoutPlannerPrefsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPlannerPrefsInput
    upsert?: TeamUpsertWithoutPlannerPrefsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutPlannerPrefsInput, TeamUpdateWithoutPlannerPrefsInput>, TeamUncheckedUpdateWithoutPlannerPrefsInput>
  }

  export type UserCreateNestedOneWithoutClinicalEntriesInput = {
    create?: XOR<UserCreateWithoutClinicalEntriesInput, UserUncheckedCreateWithoutClinicalEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutClinicalEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumClinicalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ClinicalStatus
  }

  export type NullableEnumLeaveStageFieldUpdateOperationsInput = {
    set?: $Enums.LeaveStage | null
  }

  export type NullableEnumLeaveKindFieldUpdateOperationsInput = {
    set?: $Enums.LeaveKind | null
  }

  export type NullableEnumLateralityFieldUpdateOperationsInput = {
    set?: $Enums.Laterality | null
  }

  export type NullableEnumMechanismFieldUpdateOperationsInput = {
    set?: $Enums.Mechanism | null
  }

  export type NullableEnumSeverityFieldUpdateOperationsInput = {
    set?: $Enums.Severity | null
  }

  export type NullableEnumSystemAffectedFieldUpdateOperationsInput = {
    set?: $Enums.SystemAffected | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableEnumIllAptitudeFieldUpdateOperationsInput = {
    set?: $Enums.IllAptitude | null
  }

  export type UserUpdateOneRequiredWithoutClinicalEntriesNestedInput = {
    create?: XOR<UserCreateWithoutClinicalEntriesInput, UserUncheckedCreateWithoutClinicalEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutClinicalEntriesInput
    upsert?: UserUpsertWithoutClinicalEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClinicalEntriesInput, UserUpdateWithoutClinicalEntriesInput>, UserUncheckedUpdateWithoutClinicalEntriesInput>
  }

  export type TeamCreateNestedOneWithoutScoutingCategoriesInput = {
    create?: XOR<TeamCreateWithoutScoutingCategoriesInput, TeamUncheckedCreateWithoutScoutingCategoriesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutScoutingCategoriesInput
    connect?: TeamWhereUniqueInput
  }

  export type ScoutingPlayerCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<ScoutingPlayerCreateWithoutCategoriaInput, ScoutingPlayerUncheckedCreateWithoutCategoriaInput> | ScoutingPlayerCreateWithoutCategoriaInput[] | ScoutingPlayerUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ScoutingPlayerCreateOrConnectWithoutCategoriaInput | ScoutingPlayerCreateOrConnectWithoutCategoriaInput[]
    createMany?: ScoutingPlayerCreateManyCategoriaInputEnvelope
    connect?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
  }

  export type ScoutingPlayerUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<ScoutingPlayerCreateWithoutCategoriaInput, ScoutingPlayerUncheckedCreateWithoutCategoriaInput> | ScoutingPlayerCreateWithoutCategoriaInput[] | ScoutingPlayerUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ScoutingPlayerCreateOrConnectWithoutCategoriaInput | ScoutingPlayerCreateOrConnectWithoutCategoriaInput[]
    createMany?: ScoutingPlayerCreateManyCategoriaInputEnvelope
    connect?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
  }

  export type TeamUpdateOneWithoutScoutingCategoriesNestedInput = {
    create?: XOR<TeamCreateWithoutScoutingCategoriesInput, TeamUncheckedCreateWithoutScoutingCategoriesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutScoutingCategoriesInput
    upsert?: TeamUpsertWithoutScoutingCategoriesInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutScoutingCategoriesInput, TeamUpdateWithoutScoutingCategoriesInput>, TeamUncheckedUpdateWithoutScoutingCategoriesInput>
  }

  export type ScoutingPlayerUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<ScoutingPlayerCreateWithoutCategoriaInput, ScoutingPlayerUncheckedCreateWithoutCategoriaInput> | ScoutingPlayerCreateWithoutCategoriaInput[] | ScoutingPlayerUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ScoutingPlayerCreateOrConnectWithoutCategoriaInput | ScoutingPlayerCreateOrConnectWithoutCategoriaInput[]
    upsert?: ScoutingPlayerUpsertWithWhereUniqueWithoutCategoriaInput | ScoutingPlayerUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: ScoutingPlayerCreateManyCategoriaInputEnvelope
    set?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
    disconnect?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
    delete?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
    connect?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
    update?: ScoutingPlayerUpdateWithWhereUniqueWithoutCategoriaInput | ScoutingPlayerUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: ScoutingPlayerUpdateManyWithWhereWithoutCategoriaInput | ScoutingPlayerUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: ScoutingPlayerScalarWhereInput | ScoutingPlayerScalarWhereInput[]
  }

  export type ScoutingPlayerUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<ScoutingPlayerCreateWithoutCategoriaInput, ScoutingPlayerUncheckedCreateWithoutCategoriaInput> | ScoutingPlayerCreateWithoutCategoriaInput[] | ScoutingPlayerUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: ScoutingPlayerCreateOrConnectWithoutCategoriaInput | ScoutingPlayerCreateOrConnectWithoutCategoriaInput[]
    upsert?: ScoutingPlayerUpsertWithWhereUniqueWithoutCategoriaInput | ScoutingPlayerUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: ScoutingPlayerCreateManyCategoriaInputEnvelope
    set?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
    disconnect?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
    delete?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
    connect?: ScoutingPlayerWhereUniqueInput | ScoutingPlayerWhereUniqueInput[]
    update?: ScoutingPlayerUpdateWithWhereUniqueWithoutCategoriaInput | ScoutingPlayerUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: ScoutingPlayerUpdateManyWithWhereWithoutCategoriaInput | ScoutingPlayerUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: ScoutingPlayerScalarWhereInput | ScoutingPlayerScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutPlayersInput = {
    create?: XOR<TeamCreateWithoutPlayersInput, TeamUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPlayersInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPlayersInput = {
    create?: XOR<UserCreateWithoutPlayersInput, UserUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPlayerStatusFieldUpdateOperationsInput = {
    set?: $Enums.PlayerStatus
  }

  export type TeamUpdateOneRequiredWithoutPlayersNestedInput = {
    create?: XOR<TeamCreateWithoutPlayersInput, TeamUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPlayersInput
    upsert?: TeamUpsertWithoutPlayersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutPlayersInput, TeamUpdateWithoutPlayersInput>, TeamUncheckedUpdateWithoutPlayersInput>
  }

  export type UserUpdateOneWithoutPlayersNestedInput = {
    create?: XOR<UserCreateWithoutPlayersInput, UserUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayersInput
    upsert?: UserUpsertWithoutPlayersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlayersInput, UserUpdateWithoutPlayersInput>, UserUncheckedUpdateWithoutPlayersInput>
  }

  export type ScoutingPlayerCreatepositionsInput = {
    set: string[]
  }

  export type ScoutingPlayerCreatevideosInput = {
    set: string[]
  }

  export type ScoutingPlayerCreatetagsInput = {
    set: string[]
  }

  export type TeamCreateNestedOneWithoutScoutingPlayersInput = {
    create?: XOR<TeamCreateWithoutScoutingPlayersInput, TeamUncheckedCreateWithoutScoutingPlayersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutScoutingPlayersInput
    connect?: TeamWhereUniqueInput
  }

  export type ScoutingCategoryCreateNestedOneWithoutPlayersInput = {
    create?: XOR<ScoutingCategoryCreateWithoutPlayersInput, ScoutingCategoryUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: ScoutingCategoryCreateOrConnectWithoutPlayersInput
    connect?: ScoutingCategoryWhereUniqueInput
  }

  export type ScoutingPlayerUpdatepositionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumScoutingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ScoutingStatus
  }

  export type ScoutingPlayerUpdatevideosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ScoutingPlayerUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TeamUpdateOneWithoutScoutingPlayersNestedInput = {
    create?: XOR<TeamCreateWithoutScoutingPlayersInput, TeamUncheckedCreateWithoutScoutingPlayersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutScoutingPlayersInput
    upsert?: TeamUpsertWithoutScoutingPlayersInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutScoutingPlayersInput, TeamUpdateWithoutScoutingPlayersInput>, TeamUncheckedUpdateWithoutScoutingPlayersInput>
  }

  export type ScoutingCategoryUpdateOneWithoutPlayersNestedInput = {
    create?: XOR<ScoutingCategoryCreateWithoutPlayersInput, ScoutingCategoryUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: ScoutingCategoryCreateOrConnectWithoutPlayersInput
    upsert?: ScoutingCategoryUpsertWithoutPlayersInput
    disconnect?: ScoutingCategoryWhereInput | boolean
    delete?: ScoutingCategoryWhereInput | boolean
    connect?: ScoutingCategoryWhereUniqueInput
    update?: XOR<XOR<ScoutingCategoryUpdateToOneWithWhereWithoutPlayersInput, ScoutingCategoryUpdateWithoutPlayersInput>, ScoutingCategoryUncheckedUpdateWithoutPlayersInput>
  }

  export type TeamCreateNestedOneWithoutReportsInput = {
    create?: XOR<TeamCreateWithoutReportsInput, TeamUncheckedCreateWithoutReportsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutReportsInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportsInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<TeamCreateWithoutReportsInput, TeamUncheckedCreateWithoutReportsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutReportsInput
    upsert?: TeamUpsertWithoutReportsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutReportsInput, TeamUpdateWithoutReportsInput>, TeamUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    upsert?: UserUpsertWithoutReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsInput, UserUpdateWithoutReportsInput>, UserUncheckedUpdateWithoutReportsInput>
  }

  export type TeamCreateNestedOneWithoutVideosInput = {
    create?: XOR<TeamCreateWithoutVideosInput, TeamUncheckedCreateWithoutVideosInput>
    connectOrCreate?: TeamCreateOrConnectWithoutVideosInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<TeamCreateWithoutVideosInput, TeamUncheckedCreateWithoutVideosInput>
    connectOrCreate?: TeamCreateOrConnectWithoutVideosInput
    upsert?: TeamUpsertWithoutVideosInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutVideosInput, TeamUpdateWithoutVideosInput>, TeamUncheckedUpdateWithoutVideosInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumTeamRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleFilter<$PrismaModel> | $Enums.TeamRole
  }

  export type NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamRoleFilter<$PrismaModel>
    _max?: NestedEnumTeamRoleFilter<$PrismaModel>
  }

  export type NestedEnumSessionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionType | EnumSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionTypeFilter<$PrismaModel> | $Enums.SessionType
  }

  export type NestedEnumSessionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionType | EnumSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SessionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionTypeFilter<$PrismaModel>
    _max?: NestedEnumSessionTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumClinicalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClinicalStatus | EnumClinicalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClinicalStatus[] | ListEnumClinicalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClinicalStatus[] | ListEnumClinicalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClinicalStatusFilter<$PrismaModel> | $Enums.ClinicalStatus
  }

  export type NestedEnumLeaveStageNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStage | EnumLeaveStageFieldRefInput<$PrismaModel> | null
    in?: $Enums.LeaveStage[] | ListEnumLeaveStageFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LeaveStage[] | ListEnumLeaveStageFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLeaveStageNullableFilter<$PrismaModel> | $Enums.LeaveStage | null
  }

  export type NestedEnumLeaveKindNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveKind | EnumLeaveKindFieldRefInput<$PrismaModel> | null
    in?: $Enums.LeaveKind[] | ListEnumLeaveKindFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LeaveKind[] | ListEnumLeaveKindFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLeaveKindNullableFilter<$PrismaModel> | $Enums.LeaveKind | null
  }

  export type NestedEnumLateralityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Laterality | EnumLateralityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Laterality[] | ListEnumLateralityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Laterality[] | ListEnumLateralityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLateralityNullableFilter<$PrismaModel> | $Enums.Laterality | null
  }

  export type NestedEnumMechanismNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Mechanism | EnumMechanismFieldRefInput<$PrismaModel> | null
    in?: $Enums.Mechanism[] | ListEnumMechanismFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Mechanism[] | ListEnumMechanismFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMechanismNullableFilter<$PrismaModel> | $Enums.Mechanism | null
  }

  export type NestedEnumSeverityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSeverityNullableFilter<$PrismaModel> | $Enums.Severity | null
  }

  export type NestedEnumSystemAffectedNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SystemAffected | EnumSystemAffectedFieldRefInput<$PrismaModel> | null
    in?: $Enums.SystemAffected[] | ListEnumSystemAffectedFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SystemAffected[] | ListEnumSystemAffectedFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSystemAffectedNullableFilter<$PrismaModel> | $Enums.SystemAffected | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumIllAptitudeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IllAptitude | EnumIllAptitudeFieldRefInput<$PrismaModel> | null
    in?: $Enums.IllAptitude[] | ListEnumIllAptitudeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IllAptitude[] | ListEnumIllAptitudeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIllAptitudeNullableFilter<$PrismaModel> | $Enums.IllAptitude | null
  }

  export type NestedEnumClinicalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClinicalStatus | EnumClinicalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClinicalStatus[] | ListEnumClinicalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClinicalStatus[] | ListEnumClinicalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClinicalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClinicalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClinicalStatusFilter<$PrismaModel>
    _max?: NestedEnumClinicalStatusFilter<$PrismaModel>
  }

  export type NestedEnumLeaveStageNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStage | EnumLeaveStageFieldRefInput<$PrismaModel> | null
    in?: $Enums.LeaveStage[] | ListEnumLeaveStageFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LeaveStage[] | ListEnumLeaveStageFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLeaveStageNullableWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStage | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLeaveStageNullableFilter<$PrismaModel>
    _max?: NestedEnumLeaveStageNullableFilter<$PrismaModel>
  }

  export type NestedEnumLeaveKindNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveKind | EnumLeaveKindFieldRefInput<$PrismaModel> | null
    in?: $Enums.LeaveKind[] | ListEnumLeaveKindFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LeaveKind[] | ListEnumLeaveKindFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLeaveKindNullableWithAggregatesFilter<$PrismaModel> | $Enums.LeaveKind | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLeaveKindNullableFilter<$PrismaModel>
    _max?: NestedEnumLeaveKindNullableFilter<$PrismaModel>
  }

  export type NestedEnumLateralityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Laterality | EnumLateralityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Laterality[] | ListEnumLateralityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Laterality[] | ListEnumLateralityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLateralityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Laterality | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLateralityNullableFilter<$PrismaModel>
    _max?: NestedEnumLateralityNullableFilter<$PrismaModel>
  }

  export type NestedEnumMechanismNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Mechanism | EnumMechanismFieldRefInput<$PrismaModel> | null
    in?: $Enums.Mechanism[] | ListEnumMechanismFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Mechanism[] | ListEnumMechanismFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMechanismNullableWithAggregatesFilter<$PrismaModel> | $Enums.Mechanism | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMechanismNullableFilter<$PrismaModel>
    _max?: NestedEnumMechanismNullableFilter<$PrismaModel>
  }

  export type NestedEnumSeverityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSeverityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Severity | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSeverityNullableFilter<$PrismaModel>
    _max?: NestedEnumSeverityNullableFilter<$PrismaModel>
  }

  export type NestedEnumSystemAffectedNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SystemAffected | EnumSystemAffectedFieldRefInput<$PrismaModel> | null
    in?: $Enums.SystemAffected[] | ListEnumSystemAffectedFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SystemAffected[] | ListEnumSystemAffectedFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSystemAffectedNullableWithAggregatesFilter<$PrismaModel> | $Enums.SystemAffected | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSystemAffectedNullableFilter<$PrismaModel>
    _max?: NestedEnumSystemAffectedNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumIllAptitudeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IllAptitude | EnumIllAptitudeFieldRefInput<$PrismaModel> | null
    in?: $Enums.IllAptitude[] | ListEnumIllAptitudeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IllAptitude[] | ListEnumIllAptitudeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIllAptitudeNullableWithAggregatesFilter<$PrismaModel> | $Enums.IllAptitude | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIllAptitudeNullableFilter<$PrismaModel>
    _max?: NestedEnumIllAptitudeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPlayerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerStatus | EnumPlayerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlayerStatus[] | ListEnumPlayerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlayerStatus[] | ListEnumPlayerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerStatusFilter<$PrismaModel> | $Enums.PlayerStatus
  }

  export type NestedEnumPlayerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerStatus | EnumPlayerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlayerStatus[] | ListEnumPlayerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlayerStatus[] | ListEnumPlayerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerStatusWithAggregatesFilter<$PrismaModel> | $Enums.PlayerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlayerStatusFilter<$PrismaModel>
    _max?: NestedEnumPlayerStatusFilter<$PrismaModel>
  }

  export type NestedEnumScoutingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoutingStatus | EnumScoutingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScoutingStatus[] | ListEnumScoutingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoutingStatus[] | ListEnumScoutingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScoutingStatusFilter<$PrismaModel> | $Enums.ScoutingStatus
  }

  export type NestedEnumScoutingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoutingStatus | EnumScoutingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScoutingStatus[] | ListEnumScoutingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoutingStatus[] | ListEnumScoutingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScoutingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ScoutingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScoutingStatusFilter<$PrismaModel>
    _max?: NestedEnumScoutingStatusFilter<$PrismaModel>
  }

  export type UserTeamCreateWithoutTeamInput = {
    id?: string
    role: $Enums.TeamRole
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTeamsInput
  }

  export type UserTeamUncheckedCreateWithoutTeamInput = {
    id?: string
    userId: string
    role: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type UserTeamCreateOrConnectWithoutTeamInput = {
    where: UserTeamWhereUniqueInput
    create: XOR<UserTeamCreateWithoutTeamInput, UserTeamUncheckedCreateWithoutTeamInput>
  }

  export type UserTeamCreateManyTeamInputEnvelope = {
    data: UserTeamCreateManyTeamInput | UserTeamCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type RivalCreateWithoutTeamInput = {
    id?: string
    name: string
    logoUrl?: string | null
    coach?: string | null
    baseSystem?: string | null
    nextMatchDate?: Date | string | null
    nextMatchCompetition?: string | null
    planCharlaUrl?: string | null
    planReport?: NullableJsonNullValueInput | InputJsonValue
    planVideos?: NullableJsonNullValueInput | InputJsonValue
    planStats?: NullableJsonNullValueInput | InputJsonValue
    planNotes?: NullableJsonNullValueInput | InputJsonValue
    planVisibility?: NullableJsonNullValueInput | InputJsonValue
    planSquad?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RivalUncheckedCreateWithoutTeamInput = {
    id?: string
    name: string
    logoUrl?: string | null
    coach?: string | null
    baseSystem?: string | null
    nextMatchDate?: Date | string | null
    nextMatchCompetition?: string | null
    planCharlaUrl?: string | null
    planReport?: NullableJsonNullValueInput | InputJsonValue
    planVideos?: NullableJsonNullValueInput | InputJsonValue
    planStats?: NullableJsonNullValueInput | InputJsonValue
    planNotes?: NullableJsonNullValueInput | InputJsonValue
    planVisibility?: NullableJsonNullValueInput | InputJsonValue
    planSquad?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RivalCreateOrConnectWithoutTeamInput = {
    where: RivalWhereUniqueInput
    create: XOR<RivalCreateWithoutTeamInput, RivalUncheckedCreateWithoutTeamInput>
  }

  export type RivalCreateManyTeamInputEnvelope = {
    data: RivalCreateManyTeamInput | RivalCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type PlayerFeedbackCreateWithoutTeamInput = {
    id?: string
    playerId: string
    subject?: string | null
    text: string
    rating?: number | null
    createdBy: string
    createdAt?: Date | string
  }

  export type PlayerFeedbackUncheckedCreateWithoutTeamInput = {
    id?: string
    playerId: string
    subject?: string | null
    text: string
    rating?: number | null
    createdBy: string
    createdAt?: Date | string
  }

  export type PlayerFeedbackCreateOrConnectWithoutTeamInput = {
    where: PlayerFeedbackWhereUniqueInput
    create: XOR<PlayerFeedbackCreateWithoutTeamInput, PlayerFeedbackUncheckedCreateWithoutTeamInput>
  }

  export type PlayerFeedbackCreateManyTeamInputEnvelope = {
    data: PlayerFeedbackCreateManyTeamInput | PlayerFeedbackCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutTeamInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    type?: $Enums.SessionType
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateWithoutTeamInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    type?: $Enums.SessionType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type SessionCreateOrConnectWithoutTeamInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutTeamInput, SessionUncheckedCreateWithoutTeamInput>
  }

  export type SessionCreateManyTeamInputEnvelope = {
    data: SessionCreateManyTeamInput | SessionCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type PlaceCreateWithoutTeamInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlaceUncheckedCreateWithoutTeamInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlaceCreateOrConnectWithoutTeamInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutTeamInput, PlaceUncheckedCreateWithoutTeamInput>
  }

  export type PlaceCreateManyTeamInputEnvelope = {
    data: PlaceCreateManyTeamInput | PlaceCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type PlannerPrefsCreateWithoutTeamInput = {
    id?: string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlannerPrefsInput
  }

  export type PlannerPrefsUncheckedCreateWithoutTeamInput = {
    id?: string
    userId: string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlannerPrefsCreateOrConnectWithoutTeamInput = {
    where: PlannerPrefsWhereUniqueInput
    create: XOR<PlannerPrefsCreateWithoutTeamInput, PlannerPrefsUncheckedCreateWithoutTeamInput>
  }

  export type PlannerPrefsCreateManyTeamInputEnvelope = {
    data: PlannerPrefsCreateManyTeamInput | PlannerPrefsCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type ScoutingCategoryCreateWithoutTeamInput = {
    id?: string
    nombre: string
    slug: string
    orden?: number
    color?: string | null
    activa?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: ScoutingPlayerCreateNestedManyWithoutCategoriaInput
  }

  export type ScoutingCategoryUncheckedCreateWithoutTeamInput = {
    id?: string
    nombre: string
    slug: string
    orden?: number
    color?: string | null
    activa?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: ScoutingPlayerUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type ScoutingCategoryCreateOrConnectWithoutTeamInput = {
    where: ScoutingCategoryWhereUniqueInput
    create: XOR<ScoutingCategoryCreateWithoutTeamInput, ScoutingCategoryUncheckedCreateWithoutTeamInput>
  }

  export type ScoutingCategoryCreateManyTeamInputEnvelope = {
    data: ScoutingCategoryCreateManyTeamInput | ScoutingCategoryCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type ScoutingPlayerCreateWithoutTeamInput = {
    id?: string
    fullName: string
    positions?: ScoutingPlayerCreatepositionsInput | string[]
    club?: string | null
    estado?: $Enums.ScoutingStatus
    agentName?: string | null
    agentPhone?: string | null
    agentEmail?: string | null
    playerPhone?: string | null
    playerEmail?: string | null
    instagram?: string | null
    videos?: ScoutingPlayerCreatevideosInput | string[]
    notes?: string | null
    rating?: number | null
    tags?: ScoutingPlayerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    categoria?: ScoutingCategoryCreateNestedOneWithoutPlayersInput
  }

  export type ScoutingPlayerUncheckedCreateWithoutTeamInput = {
    id?: string
    fullName: string
    positions?: ScoutingPlayerCreatepositionsInput | string[]
    club?: string | null
    estado?: $Enums.ScoutingStatus
    categoriaId?: string | null
    agentName?: string | null
    agentPhone?: string | null
    agentEmail?: string | null
    playerPhone?: string | null
    playerEmail?: string | null
    instagram?: string | null
    videos?: ScoutingPlayerCreatevideosInput | string[]
    notes?: string | null
    rating?: number | null
    tags?: ScoutingPlayerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScoutingPlayerCreateOrConnectWithoutTeamInput = {
    where: ScoutingPlayerWhereUniqueInput
    create: XOR<ScoutingPlayerCreateWithoutTeamInput, ScoutingPlayerUncheckedCreateWithoutTeamInput>
  }

  export type ScoutingPlayerCreateManyTeamInputEnvelope = {
    data: ScoutingPlayerCreateManyTeamInput | ScoutingPlayerCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TeamVideoCreateWithoutTeamInput = {
    id?: string
    url: string
    title: string
    notes?: string | null
    type: string
    visibleToDirectivo?: boolean
    createdAt?: Date | string
  }

  export type TeamVideoUncheckedCreateWithoutTeamInput = {
    id?: string
    url: string
    title: string
    notes?: string | null
    type: string
    visibleToDirectivo?: boolean
    createdAt?: Date | string
  }

  export type TeamVideoCreateOrConnectWithoutTeamInput = {
    where: TeamVideoWhereUniqueInput
    create: XOR<TeamVideoCreateWithoutTeamInput, TeamVideoUncheckedCreateWithoutTeamInput>
  }

  export type TeamVideoCreateManyTeamInputEnvelope = {
    data: TeamVideoCreateManyTeamInput | TeamVideoCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutTeamInput = {
    id?: string
    title: string
    summary?: string | null
    content: string
    type: string
    visibleToDirectivo?: boolean
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutTeamInput = {
    id?: string
    title: string
    summary?: string | null
    content: string
    type: string
    authorId: string
    visibleToDirectivo?: boolean
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutTeamInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutTeamInput, ReportUncheckedCreateWithoutTeamInput>
  }

  export type ReportCreateManyTeamInputEnvelope = {
    data: ReportCreateManyTeamInput | ReportCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type PlayerCreateWithoutTeamInput = {
    id?: string
    name: string
    shirtNumber?: number | null
    position?: string | null
    photoUrl?: string | null
    birthDate?: Date | string | null
    status?: $Enums.PlayerStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutTeamInput = {
    id?: string
    userId?: string | null
    name: string
    shirtNumber?: number | null
    position?: string | null
    photoUrl?: string | null
    birthDate?: Date | string | null
    status?: $Enums.PlayerStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCreateOrConnectWithoutTeamInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput>
  }

  export type PlayerCreateManyTeamInputEnvelope = {
    data: PlayerCreateManyTeamInput | PlayerCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type UserTeamUpsertWithWhereUniqueWithoutTeamInput = {
    where: UserTeamWhereUniqueInput
    update: XOR<UserTeamUpdateWithoutTeamInput, UserTeamUncheckedUpdateWithoutTeamInput>
    create: XOR<UserTeamCreateWithoutTeamInput, UserTeamUncheckedCreateWithoutTeamInput>
  }

  export type UserTeamUpdateWithWhereUniqueWithoutTeamInput = {
    where: UserTeamWhereUniqueInput
    data: XOR<UserTeamUpdateWithoutTeamInput, UserTeamUncheckedUpdateWithoutTeamInput>
  }

  export type UserTeamUpdateManyWithWhereWithoutTeamInput = {
    where: UserTeamScalarWhereInput
    data: XOR<UserTeamUpdateManyMutationInput, UserTeamUncheckedUpdateManyWithoutTeamInput>
  }

  export type UserTeamScalarWhereInput = {
    AND?: UserTeamScalarWhereInput | UserTeamScalarWhereInput[]
    OR?: UserTeamScalarWhereInput[]
    NOT?: UserTeamScalarWhereInput | UserTeamScalarWhereInput[]
    id?: StringFilter<"UserTeam"> | string
    userId?: StringFilter<"UserTeam"> | string
    teamId?: StringFilter<"UserTeam"> | string
    role?: EnumTeamRoleFilter<"UserTeam"> | $Enums.TeamRole
    createdAt?: DateTimeFilter<"UserTeam"> | Date | string
  }

  export type RivalUpsertWithWhereUniqueWithoutTeamInput = {
    where: RivalWhereUniqueInput
    update: XOR<RivalUpdateWithoutTeamInput, RivalUncheckedUpdateWithoutTeamInput>
    create: XOR<RivalCreateWithoutTeamInput, RivalUncheckedCreateWithoutTeamInput>
  }

  export type RivalUpdateWithWhereUniqueWithoutTeamInput = {
    where: RivalWhereUniqueInput
    data: XOR<RivalUpdateWithoutTeamInput, RivalUncheckedUpdateWithoutTeamInput>
  }

  export type RivalUpdateManyWithWhereWithoutTeamInput = {
    where: RivalScalarWhereInput
    data: XOR<RivalUpdateManyMutationInput, RivalUncheckedUpdateManyWithoutTeamInput>
  }

  export type RivalScalarWhereInput = {
    AND?: RivalScalarWhereInput | RivalScalarWhereInput[]
    OR?: RivalScalarWhereInput[]
    NOT?: RivalScalarWhereInput | RivalScalarWhereInput[]
    id?: StringFilter<"Rival"> | string
    teamId?: StringFilter<"Rival"> | string
    name?: StringFilter<"Rival"> | string
    logoUrl?: StringNullableFilter<"Rival"> | string | null
    coach?: StringNullableFilter<"Rival"> | string | null
    baseSystem?: StringNullableFilter<"Rival"> | string | null
    nextMatchDate?: DateTimeNullableFilter<"Rival"> | Date | string | null
    nextMatchCompetition?: StringNullableFilter<"Rival"> | string | null
    planCharlaUrl?: StringNullableFilter<"Rival"> | string | null
    planReport?: JsonNullableFilter<"Rival">
    planVideos?: JsonNullableFilter<"Rival">
    planStats?: JsonNullableFilter<"Rival">
    planNotes?: JsonNullableFilter<"Rival">
    planVisibility?: JsonNullableFilter<"Rival">
    planSquad?: JsonNullableFilter<"Rival">
    createdAt?: DateTimeFilter<"Rival"> | Date | string
    updatedAt?: DateTimeFilter<"Rival"> | Date | string
  }

  export type PlayerFeedbackUpsertWithWhereUniqueWithoutTeamInput = {
    where: PlayerFeedbackWhereUniqueInput
    update: XOR<PlayerFeedbackUpdateWithoutTeamInput, PlayerFeedbackUncheckedUpdateWithoutTeamInput>
    create: XOR<PlayerFeedbackCreateWithoutTeamInput, PlayerFeedbackUncheckedCreateWithoutTeamInput>
  }

  export type PlayerFeedbackUpdateWithWhereUniqueWithoutTeamInput = {
    where: PlayerFeedbackWhereUniqueInput
    data: XOR<PlayerFeedbackUpdateWithoutTeamInput, PlayerFeedbackUncheckedUpdateWithoutTeamInput>
  }

  export type PlayerFeedbackUpdateManyWithWhereWithoutTeamInput = {
    where: PlayerFeedbackScalarWhereInput
    data: XOR<PlayerFeedbackUpdateManyMutationInput, PlayerFeedbackUncheckedUpdateManyWithoutTeamInput>
  }

  export type PlayerFeedbackScalarWhereInput = {
    AND?: PlayerFeedbackScalarWhereInput | PlayerFeedbackScalarWhereInput[]
    OR?: PlayerFeedbackScalarWhereInput[]
    NOT?: PlayerFeedbackScalarWhereInput | PlayerFeedbackScalarWhereInput[]
    id?: StringFilter<"PlayerFeedback"> | string
    teamId?: StringFilter<"PlayerFeedback"> | string
    playerId?: StringFilter<"PlayerFeedback"> | string
    subject?: StringNullableFilter<"PlayerFeedback"> | string | null
    text?: StringFilter<"PlayerFeedback"> | string
    rating?: IntNullableFilter<"PlayerFeedback"> | number | null
    createdBy?: StringFilter<"PlayerFeedback"> | string
    createdAt?: DateTimeFilter<"PlayerFeedback"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutTeamInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutTeamInput, SessionUncheckedUpdateWithoutTeamInput>
    create: XOR<SessionCreateWithoutTeamInput, SessionUncheckedCreateWithoutTeamInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutTeamInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutTeamInput, SessionUncheckedUpdateWithoutTeamInput>
  }

  export type SessionUpdateManyWithWhereWithoutTeamInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutTeamInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    title?: StringFilter<"Session"> | string
    description?: StringNullableFilter<"Session"> | string | null
    date?: DateTimeFilter<"Session"> | Date | string
    type?: EnumSessionTypeFilter<"Session"> | $Enums.SessionType
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    createdBy?: StringFilter<"Session"> | string
    teamId?: StringFilter<"Session"> | string
  }

  export type PlaceUpsertWithWhereUniqueWithoutTeamInput = {
    where: PlaceWhereUniqueInput
    update: XOR<PlaceUpdateWithoutTeamInput, PlaceUncheckedUpdateWithoutTeamInput>
    create: XOR<PlaceCreateWithoutTeamInput, PlaceUncheckedCreateWithoutTeamInput>
  }

  export type PlaceUpdateWithWhereUniqueWithoutTeamInput = {
    where: PlaceWhereUniqueInput
    data: XOR<PlaceUpdateWithoutTeamInput, PlaceUncheckedUpdateWithoutTeamInput>
  }

  export type PlaceUpdateManyWithWhereWithoutTeamInput = {
    where: PlaceScalarWhereInput
    data: XOR<PlaceUpdateManyMutationInput, PlaceUncheckedUpdateManyWithoutTeamInput>
  }

  export type PlaceScalarWhereInput = {
    AND?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
    OR?: PlaceScalarWhereInput[]
    NOT?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
    id?: StringFilter<"Place"> | string
    name?: StringFilter<"Place"> | string
    teamId?: StringFilter<"Place"> | string
    createdAt?: DateTimeFilter<"Place"> | Date | string
    updatedAt?: DateTimeFilter<"Place"> | Date | string
  }

  export type PlannerPrefsUpsertWithWhereUniqueWithoutTeamInput = {
    where: PlannerPrefsWhereUniqueInput
    update: XOR<PlannerPrefsUpdateWithoutTeamInput, PlannerPrefsUncheckedUpdateWithoutTeamInput>
    create: XOR<PlannerPrefsCreateWithoutTeamInput, PlannerPrefsUncheckedCreateWithoutTeamInput>
  }

  export type PlannerPrefsUpdateWithWhereUniqueWithoutTeamInput = {
    where: PlannerPrefsWhereUniqueInput
    data: XOR<PlannerPrefsUpdateWithoutTeamInput, PlannerPrefsUncheckedUpdateWithoutTeamInput>
  }

  export type PlannerPrefsUpdateManyWithWhereWithoutTeamInput = {
    where: PlannerPrefsScalarWhereInput
    data: XOR<PlannerPrefsUpdateManyMutationInput, PlannerPrefsUncheckedUpdateManyWithoutTeamInput>
  }

  export type PlannerPrefsScalarWhereInput = {
    AND?: PlannerPrefsScalarWhereInput | PlannerPrefsScalarWhereInput[]
    OR?: PlannerPrefsScalarWhereInput[]
    NOT?: PlannerPrefsScalarWhereInput | PlannerPrefsScalarWhereInput[]
    id?: StringFilter<"PlannerPrefs"> | string
    userId?: StringFilter<"PlannerPrefs"> | string
    teamId?: StringFilter<"PlannerPrefs"> | string
    rowLabels?: JsonFilter<"PlannerPrefs">
    places?: JsonFilter<"PlannerPrefs">
    createdAt?: DateTimeFilter<"PlannerPrefs"> | Date | string
    updatedAt?: DateTimeFilter<"PlannerPrefs"> | Date | string
  }

  export type ScoutingCategoryUpsertWithWhereUniqueWithoutTeamInput = {
    where: ScoutingCategoryWhereUniqueInput
    update: XOR<ScoutingCategoryUpdateWithoutTeamInput, ScoutingCategoryUncheckedUpdateWithoutTeamInput>
    create: XOR<ScoutingCategoryCreateWithoutTeamInput, ScoutingCategoryUncheckedCreateWithoutTeamInput>
  }

  export type ScoutingCategoryUpdateWithWhereUniqueWithoutTeamInput = {
    where: ScoutingCategoryWhereUniqueInput
    data: XOR<ScoutingCategoryUpdateWithoutTeamInput, ScoutingCategoryUncheckedUpdateWithoutTeamInput>
  }

  export type ScoutingCategoryUpdateManyWithWhereWithoutTeamInput = {
    where: ScoutingCategoryScalarWhereInput
    data: XOR<ScoutingCategoryUpdateManyMutationInput, ScoutingCategoryUncheckedUpdateManyWithoutTeamInput>
  }

  export type ScoutingCategoryScalarWhereInput = {
    AND?: ScoutingCategoryScalarWhereInput | ScoutingCategoryScalarWhereInput[]
    OR?: ScoutingCategoryScalarWhereInput[]
    NOT?: ScoutingCategoryScalarWhereInput | ScoutingCategoryScalarWhereInput[]
    id?: StringFilter<"ScoutingCategory"> | string
    teamId?: StringNullableFilter<"ScoutingCategory"> | string | null
    nombre?: StringFilter<"ScoutingCategory"> | string
    slug?: StringFilter<"ScoutingCategory"> | string
    orden?: IntFilter<"ScoutingCategory"> | number
    color?: StringNullableFilter<"ScoutingCategory"> | string | null
    activa?: BoolFilter<"ScoutingCategory"> | boolean
    createdAt?: DateTimeFilter<"ScoutingCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ScoutingCategory"> | Date | string
  }

  export type ScoutingPlayerUpsertWithWhereUniqueWithoutTeamInput = {
    where: ScoutingPlayerWhereUniqueInput
    update: XOR<ScoutingPlayerUpdateWithoutTeamInput, ScoutingPlayerUncheckedUpdateWithoutTeamInput>
    create: XOR<ScoutingPlayerCreateWithoutTeamInput, ScoutingPlayerUncheckedCreateWithoutTeamInput>
  }

  export type ScoutingPlayerUpdateWithWhereUniqueWithoutTeamInput = {
    where: ScoutingPlayerWhereUniqueInput
    data: XOR<ScoutingPlayerUpdateWithoutTeamInput, ScoutingPlayerUncheckedUpdateWithoutTeamInput>
  }

  export type ScoutingPlayerUpdateManyWithWhereWithoutTeamInput = {
    where: ScoutingPlayerScalarWhereInput
    data: XOR<ScoutingPlayerUpdateManyMutationInput, ScoutingPlayerUncheckedUpdateManyWithoutTeamInput>
  }

  export type ScoutingPlayerScalarWhereInput = {
    AND?: ScoutingPlayerScalarWhereInput | ScoutingPlayerScalarWhereInput[]
    OR?: ScoutingPlayerScalarWhereInput[]
    NOT?: ScoutingPlayerScalarWhereInput | ScoutingPlayerScalarWhereInput[]
    id?: StringFilter<"ScoutingPlayer"> | string
    teamId?: StringNullableFilter<"ScoutingPlayer"> | string | null
    fullName?: StringFilter<"ScoutingPlayer"> | string
    positions?: StringNullableListFilter<"ScoutingPlayer">
    club?: StringNullableFilter<"ScoutingPlayer"> | string | null
    estado?: EnumScoutingStatusFilter<"ScoutingPlayer"> | $Enums.ScoutingStatus
    categoriaId?: StringNullableFilter<"ScoutingPlayer"> | string | null
    agentName?: StringNullableFilter<"ScoutingPlayer"> | string | null
    agentPhone?: StringNullableFilter<"ScoutingPlayer"> | string | null
    agentEmail?: StringNullableFilter<"ScoutingPlayer"> | string | null
    playerPhone?: StringNullableFilter<"ScoutingPlayer"> | string | null
    playerEmail?: StringNullableFilter<"ScoutingPlayer"> | string | null
    instagram?: StringNullableFilter<"ScoutingPlayer"> | string | null
    videos?: StringNullableListFilter<"ScoutingPlayer">
    notes?: StringNullableFilter<"ScoutingPlayer"> | string | null
    rating?: IntNullableFilter<"ScoutingPlayer"> | number | null
    tags?: StringNullableListFilter<"ScoutingPlayer">
    createdAt?: DateTimeFilter<"ScoutingPlayer"> | Date | string
    updatedAt?: DateTimeFilter<"ScoutingPlayer"> | Date | string
  }

  export type TeamVideoUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamVideoWhereUniqueInput
    update: XOR<TeamVideoUpdateWithoutTeamInput, TeamVideoUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamVideoCreateWithoutTeamInput, TeamVideoUncheckedCreateWithoutTeamInput>
  }

  export type TeamVideoUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamVideoWhereUniqueInput
    data: XOR<TeamVideoUpdateWithoutTeamInput, TeamVideoUncheckedUpdateWithoutTeamInput>
  }

  export type TeamVideoUpdateManyWithWhereWithoutTeamInput = {
    where: TeamVideoScalarWhereInput
    data: XOR<TeamVideoUpdateManyMutationInput, TeamVideoUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamVideoScalarWhereInput = {
    AND?: TeamVideoScalarWhereInput | TeamVideoScalarWhereInput[]
    OR?: TeamVideoScalarWhereInput[]
    NOT?: TeamVideoScalarWhereInput | TeamVideoScalarWhereInput[]
    id?: StringFilter<"TeamVideo"> | string
    teamId?: StringFilter<"TeamVideo"> | string
    url?: StringFilter<"TeamVideo"> | string
    title?: StringFilter<"TeamVideo"> | string
    notes?: StringNullableFilter<"TeamVideo"> | string | null
    type?: StringFilter<"TeamVideo"> | string
    visibleToDirectivo?: BoolFilter<"TeamVideo"> | boolean
    createdAt?: DateTimeFilter<"TeamVideo"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutTeamInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutTeamInput, ReportUncheckedUpdateWithoutTeamInput>
    create: XOR<ReportCreateWithoutTeamInput, ReportUncheckedCreateWithoutTeamInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutTeamInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutTeamInput, ReportUncheckedUpdateWithoutTeamInput>
  }

  export type ReportUpdateManyWithWhereWithoutTeamInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutTeamInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    teamId?: StringFilter<"Report"> | string
    title?: StringFilter<"Report"> | string
    summary?: StringNullableFilter<"Report"> | string | null
    content?: StringFilter<"Report"> | string
    type?: StringFilter<"Report"> | string
    authorId?: StringFilter<"Report"> | string
    visibleToDirectivo?: BoolFilter<"Report"> | boolean
    createdAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type PlayerUpsertWithWhereUniqueWithoutTeamInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutTeamInput, PlayerUncheckedUpdateWithoutTeamInput>
    create: XOR<PlayerCreateWithoutTeamInput, PlayerUncheckedCreateWithoutTeamInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutTeamInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutTeamInput, PlayerUncheckedUpdateWithoutTeamInput>
  }

  export type PlayerUpdateManyWithWhereWithoutTeamInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutTeamInput>
  }

  export type PlayerScalarWhereInput = {
    AND?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
    OR?: PlayerScalarWhereInput[]
    NOT?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
    id?: StringFilter<"Player"> | string
    teamId?: StringFilter<"Player"> | string
    userId?: StringNullableFilter<"Player"> | string | null
    name?: StringFilter<"Player"> | string
    shirtNumber?: IntNullableFilter<"Player"> | number | null
    position?: StringNullableFilter<"Player"> | string | null
    photoUrl?: StringNullableFilter<"Player"> | string | null
    birthDate?: DateTimeNullableFilter<"Player"> | Date | string | null
    status?: EnumPlayerStatusFilter<"Player"> | $Enums.PlayerStatus
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    type?: $Enums.SessionType
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    type?: $Enums.SessionType
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RPEEntryCreateWithoutUserInput = {
    id?: string
    date: Date | string
    session?: number
    sessionLabel?: string | null
    sessionUid?: string | null
    rpe: number
    duration?: number | null
    load?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RPEEntryUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    session?: number
    sessionLabel?: string | null
    sessionUid?: string | null
    rpe: number
    duration?: number | null
    load?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RPEEntryCreateOrConnectWithoutUserInput = {
    where: RPEEntryWhereUniqueInput
    create: XOR<RPEEntryCreateWithoutUserInput, RPEEntryUncheckedCreateWithoutUserInput>
  }

  export type RPEEntryCreateManyUserInputEnvelope = {
    data: RPEEntryCreateManyUserInput | RPEEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WellnessEntryCreateWithoutUserInput = {
    id?: string
    date: Date | string
    sleepQuality: number
    sleepHours?: number | null
    fatigue: number
    muscleSoreness: number
    stress: number
    mood: number
    comment?: string | null
    total?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WellnessEntryUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    sleepQuality: number
    sleepHours?: number | null
    fatigue: number
    muscleSoreness: number
    stress: number
    mood: number
    comment?: string | null
    total?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WellnessEntryCreateOrConnectWithoutUserInput = {
    where: WellnessEntryWhereUniqueInput
    create: XOR<WellnessEntryCreateWithoutUserInput, WellnessEntryUncheckedCreateWithoutUserInput>
  }

  export type WellnessEntryCreateManyUserInputEnvelope = {
    data: WellnessEntryCreateManyUserInput | WellnessEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PlannerPrefsCreateWithoutUserInput = {
    id?: string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutPlannerPrefsInput
  }

  export type PlannerPrefsUncheckedCreateWithoutUserInput = {
    id?: string
    teamId: string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlannerPrefsCreateOrConnectWithoutUserInput = {
    where: PlannerPrefsWhereUniqueInput
    create: XOR<PlannerPrefsCreateWithoutUserInput, PlannerPrefsUncheckedCreateWithoutUserInput>
  }

  export type PlannerPrefsCreateManyUserInputEnvelope = {
    data: PlannerPrefsCreateManyUserInput | PlannerPrefsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseCreateWithoutUserInput = {
    id?: string
    title: string
    space?: string | null
    players?: string | null
    duration?: string | null
    description?: string | null
    imageUrl?: string | null
    tags?: ExerciseCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    kind?: ExerciseKindCreateNestedOneWithoutExercisesInput
  }

  export type ExerciseUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    kindId?: string | null
    space?: string | null
    players?: string | null
    duration?: string | null
    description?: string | null
    imageUrl?: string | null
    tags?: ExerciseCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseCreateOrConnectWithoutUserInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutUserInput, ExerciseUncheckedCreateWithoutUserInput>
  }

  export type ExerciseCreateManyUserInputEnvelope = {
    data: ExerciseCreateManyUserInput | ExerciseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClinicalEntryCreateWithoutUserInput = {
    id?: string
    date: Date | string
    status: $Enums.ClinicalStatus
    leaveStage?: $Enums.LeaveStage | null
    leaveKind?: $Enums.LeaveKind | null
    diagnosis?: string | null
    bodyPart?: string | null
    laterality?: $Enums.Laterality | null
    mechanism?: $Enums.Mechanism | null
    severity?: $Enums.Severity | null
    illSystem?: $Enums.SystemAffected | null
    illSymptoms?: string | null
    illContagious?: boolean | null
    illIsolationDays?: number | null
    illAptitude?: $Enums.IllAptitude | null
    feverMax?: number | null
    startDate?: Date | string | null
    daysPlanned?: number | null
    expectedReturn?: Date | string | null
    expectedReturnManual?: boolean | null
    capMinutes?: number | null
    noSprint?: boolean
    noChangeOfDirection?: boolean
    gymOnly?: boolean
    noContact?: boolean
    notes?: string | null
    medSignature?: string | null
    protocolObjectives?: string | null
    protocolTasks?: string | null
    protocolControls?: string | null
    protocolCriteria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicalEntryUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    status: $Enums.ClinicalStatus
    leaveStage?: $Enums.LeaveStage | null
    leaveKind?: $Enums.LeaveKind | null
    diagnosis?: string | null
    bodyPart?: string | null
    laterality?: $Enums.Laterality | null
    mechanism?: $Enums.Mechanism | null
    severity?: $Enums.Severity | null
    illSystem?: $Enums.SystemAffected | null
    illSymptoms?: string | null
    illContagious?: boolean | null
    illIsolationDays?: number | null
    illAptitude?: $Enums.IllAptitude | null
    feverMax?: number | null
    startDate?: Date | string | null
    daysPlanned?: number | null
    expectedReturn?: Date | string | null
    expectedReturnManual?: boolean | null
    capMinutes?: number | null
    noSprint?: boolean
    noChangeOfDirection?: boolean
    gymOnly?: boolean
    noContact?: boolean
    notes?: string | null
    medSignature?: string | null
    protocolObjectives?: string | null
    protocolTasks?: string | null
    protocolControls?: string | null
    protocolCriteria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicalEntryCreateOrConnectWithoutUserInput = {
    where: ClinicalEntryWhereUniqueInput
    create: XOR<ClinicalEntryCreateWithoutUserInput, ClinicalEntryUncheckedCreateWithoutUserInput>
  }

  export type ClinicalEntryCreateManyUserInputEnvelope = {
    data: ClinicalEntryCreateManyUserInput | ClinicalEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserTeamCreateWithoutUserInput = {
    id?: string
    role: $Enums.TeamRole
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type UserTeamUncheckedCreateWithoutUserInput = {
    id?: string
    teamId: string
    role: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type UserTeamCreateOrConnectWithoutUserInput = {
    where: UserTeamWhereUniqueInput
    create: XOR<UserTeamCreateWithoutUserInput, UserTeamUncheckedCreateWithoutUserInput>
  }

  export type UserTeamCreateManyUserInputEnvelope = {
    data: UserTeamCreateManyUserInput | UserTeamCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutAuthorInput = {
    id?: string
    title: string
    summary?: string | null
    content: string
    type: string
    visibleToDirectivo?: boolean
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutAuthorInput = {
    id?: string
    teamId: string
    title: string
    summary?: string | null
    content: string
    type: string
    visibleToDirectivo?: boolean
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutAuthorInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutAuthorInput, ReportUncheckedCreateWithoutAuthorInput>
  }

  export type ReportCreateManyAuthorInputEnvelope = {
    data: ReportCreateManyAuthorInput | ReportCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type PlayerCreateWithoutUserInput = {
    id?: string
    name: string
    shirtNumber?: number | null
    position?: string | null
    photoUrl?: string | null
    birthDate?: Date | string | null
    status?: $Enums.PlayerStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutUserInput = {
    id?: string
    teamId: string
    name: string
    shirtNumber?: number | null
    position?: string | null
    photoUrl?: string | null
    birthDate?: Date | string | null
    status?: $Enums.PlayerStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCreateOrConnectWithoutUserInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput>
  }

  export type PlayerCreateManyUserInputEnvelope = {
    data: PlayerCreateManyUserInput | PlayerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type RPEEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: RPEEntryWhereUniqueInput
    update: XOR<RPEEntryUpdateWithoutUserInput, RPEEntryUncheckedUpdateWithoutUserInput>
    create: XOR<RPEEntryCreateWithoutUserInput, RPEEntryUncheckedCreateWithoutUserInput>
  }

  export type RPEEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: RPEEntryWhereUniqueInput
    data: XOR<RPEEntryUpdateWithoutUserInput, RPEEntryUncheckedUpdateWithoutUserInput>
  }

  export type RPEEntryUpdateManyWithWhereWithoutUserInput = {
    where: RPEEntryScalarWhereInput
    data: XOR<RPEEntryUpdateManyMutationInput, RPEEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type RPEEntryScalarWhereInput = {
    AND?: RPEEntryScalarWhereInput | RPEEntryScalarWhereInput[]
    OR?: RPEEntryScalarWhereInput[]
    NOT?: RPEEntryScalarWhereInput | RPEEntryScalarWhereInput[]
    id?: StringFilter<"RPEEntry"> | string
    userId?: StringFilter<"RPEEntry"> | string
    date?: DateTimeFilter<"RPEEntry"> | Date | string
    session?: IntFilter<"RPEEntry"> | number
    sessionLabel?: StringNullableFilter<"RPEEntry"> | string | null
    sessionUid?: StringNullableFilter<"RPEEntry"> | string | null
    rpe?: IntFilter<"RPEEntry"> | number
    duration?: IntNullableFilter<"RPEEntry"> | number | null
    load?: IntNullableFilter<"RPEEntry"> | number | null
    createdAt?: DateTimeFilter<"RPEEntry"> | Date | string
    updatedAt?: DateTimeFilter<"RPEEntry"> | Date | string
  }

  export type WellnessEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: WellnessEntryWhereUniqueInput
    update: XOR<WellnessEntryUpdateWithoutUserInput, WellnessEntryUncheckedUpdateWithoutUserInput>
    create: XOR<WellnessEntryCreateWithoutUserInput, WellnessEntryUncheckedCreateWithoutUserInput>
  }

  export type WellnessEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: WellnessEntryWhereUniqueInput
    data: XOR<WellnessEntryUpdateWithoutUserInput, WellnessEntryUncheckedUpdateWithoutUserInput>
  }

  export type WellnessEntryUpdateManyWithWhereWithoutUserInput = {
    where: WellnessEntryScalarWhereInput
    data: XOR<WellnessEntryUpdateManyMutationInput, WellnessEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type WellnessEntryScalarWhereInput = {
    AND?: WellnessEntryScalarWhereInput | WellnessEntryScalarWhereInput[]
    OR?: WellnessEntryScalarWhereInput[]
    NOT?: WellnessEntryScalarWhereInput | WellnessEntryScalarWhereInput[]
    id?: StringFilter<"WellnessEntry"> | string
    userId?: StringFilter<"WellnessEntry"> | string
    date?: DateTimeFilter<"WellnessEntry"> | Date | string
    sleepQuality?: IntFilter<"WellnessEntry"> | number
    sleepHours?: FloatNullableFilter<"WellnessEntry"> | number | null
    fatigue?: IntFilter<"WellnessEntry"> | number
    muscleSoreness?: IntFilter<"WellnessEntry"> | number
    stress?: IntFilter<"WellnessEntry"> | number
    mood?: IntFilter<"WellnessEntry"> | number
    comment?: StringNullableFilter<"WellnessEntry"> | string | null
    total?: IntNullableFilter<"WellnessEntry"> | number | null
    createdAt?: DateTimeFilter<"WellnessEntry"> | Date | string
    updatedAt?: DateTimeFilter<"WellnessEntry"> | Date | string
  }

  export type PlannerPrefsUpsertWithWhereUniqueWithoutUserInput = {
    where: PlannerPrefsWhereUniqueInput
    update: XOR<PlannerPrefsUpdateWithoutUserInput, PlannerPrefsUncheckedUpdateWithoutUserInput>
    create: XOR<PlannerPrefsCreateWithoutUserInput, PlannerPrefsUncheckedCreateWithoutUserInput>
  }

  export type PlannerPrefsUpdateWithWhereUniqueWithoutUserInput = {
    where: PlannerPrefsWhereUniqueInput
    data: XOR<PlannerPrefsUpdateWithoutUserInput, PlannerPrefsUncheckedUpdateWithoutUserInput>
  }

  export type PlannerPrefsUpdateManyWithWhereWithoutUserInput = {
    where: PlannerPrefsScalarWhereInput
    data: XOR<PlannerPrefsUpdateManyMutationInput, PlannerPrefsUncheckedUpdateManyWithoutUserInput>
  }

  export type ExerciseUpsertWithWhereUniqueWithoutUserInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutUserInput, ExerciseUncheckedUpdateWithoutUserInput>
    create: XOR<ExerciseCreateWithoutUserInput, ExerciseUncheckedCreateWithoutUserInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutUserInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutUserInput, ExerciseUncheckedUpdateWithoutUserInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutUserInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutUserInput>
  }

  export type ExerciseScalarWhereInput = {
    AND?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
    OR?: ExerciseScalarWhereInput[]
    NOT?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
    id?: StringFilter<"Exercise"> | string
    userId?: StringFilter<"Exercise"> | string
    title?: StringFilter<"Exercise"> | string
    kindId?: StringNullableFilter<"Exercise"> | string | null
    space?: StringNullableFilter<"Exercise"> | string | null
    players?: StringNullableFilter<"Exercise"> | string | null
    duration?: StringNullableFilter<"Exercise"> | string | null
    description?: StringNullableFilter<"Exercise"> | string | null
    imageUrl?: StringNullableFilter<"Exercise"> | string | null
    tags?: StringNullableListFilter<"Exercise">
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
  }

  export type ClinicalEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: ClinicalEntryWhereUniqueInput
    update: XOR<ClinicalEntryUpdateWithoutUserInput, ClinicalEntryUncheckedUpdateWithoutUserInput>
    create: XOR<ClinicalEntryCreateWithoutUserInput, ClinicalEntryUncheckedCreateWithoutUserInput>
  }

  export type ClinicalEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: ClinicalEntryWhereUniqueInput
    data: XOR<ClinicalEntryUpdateWithoutUserInput, ClinicalEntryUncheckedUpdateWithoutUserInput>
  }

  export type ClinicalEntryUpdateManyWithWhereWithoutUserInput = {
    where: ClinicalEntryScalarWhereInput
    data: XOR<ClinicalEntryUpdateManyMutationInput, ClinicalEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type ClinicalEntryScalarWhereInput = {
    AND?: ClinicalEntryScalarWhereInput | ClinicalEntryScalarWhereInput[]
    OR?: ClinicalEntryScalarWhereInput[]
    NOT?: ClinicalEntryScalarWhereInput | ClinicalEntryScalarWhereInput[]
    id?: StringFilter<"ClinicalEntry"> | string
    userId?: StringFilter<"ClinicalEntry"> | string
    date?: DateTimeFilter<"ClinicalEntry"> | Date | string
    status?: EnumClinicalStatusFilter<"ClinicalEntry"> | $Enums.ClinicalStatus
    leaveStage?: EnumLeaveStageNullableFilter<"ClinicalEntry"> | $Enums.LeaveStage | null
    leaveKind?: EnumLeaveKindNullableFilter<"ClinicalEntry"> | $Enums.LeaveKind | null
    diagnosis?: StringNullableFilter<"ClinicalEntry"> | string | null
    bodyPart?: StringNullableFilter<"ClinicalEntry"> | string | null
    laterality?: EnumLateralityNullableFilter<"ClinicalEntry"> | $Enums.Laterality | null
    mechanism?: EnumMechanismNullableFilter<"ClinicalEntry"> | $Enums.Mechanism | null
    severity?: EnumSeverityNullableFilter<"ClinicalEntry"> | $Enums.Severity | null
    illSystem?: EnumSystemAffectedNullableFilter<"ClinicalEntry"> | $Enums.SystemAffected | null
    illSymptoms?: StringNullableFilter<"ClinicalEntry"> | string | null
    illContagious?: BoolNullableFilter<"ClinicalEntry"> | boolean | null
    illIsolationDays?: IntNullableFilter<"ClinicalEntry"> | number | null
    illAptitude?: EnumIllAptitudeNullableFilter<"ClinicalEntry"> | $Enums.IllAptitude | null
    feverMax?: FloatNullableFilter<"ClinicalEntry"> | number | null
    startDate?: DateTimeNullableFilter<"ClinicalEntry"> | Date | string | null
    daysPlanned?: IntNullableFilter<"ClinicalEntry"> | number | null
    expectedReturn?: DateTimeNullableFilter<"ClinicalEntry"> | Date | string | null
    expectedReturnManual?: BoolNullableFilter<"ClinicalEntry"> | boolean | null
    capMinutes?: IntNullableFilter<"ClinicalEntry"> | number | null
    noSprint?: BoolFilter<"ClinicalEntry"> | boolean
    noChangeOfDirection?: BoolFilter<"ClinicalEntry"> | boolean
    gymOnly?: BoolFilter<"ClinicalEntry"> | boolean
    noContact?: BoolFilter<"ClinicalEntry"> | boolean
    notes?: StringNullableFilter<"ClinicalEntry"> | string | null
    medSignature?: StringNullableFilter<"ClinicalEntry"> | string | null
    protocolObjectives?: StringNullableFilter<"ClinicalEntry"> | string | null
    protocolTasks?: StringNullableFilter<"ClinicalEntry"> | string | null
    protocolControls?: StringNullableFilter<"ClinicalEntry"> | string | null
    protocolCriteria?: StringNullableFilter<"ClinicalEntry"> | string | null
    createdAt?: DateTimeFilter<"ClinicalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicalEntry"> | Date | string
  }

  export type UserTeamUpsertWithWhereUniqueWithoutUserInput = {
    where: UserTeamWhereUniqueInput
    update: XOR<UserTeamUpdateWithoutUserInput, UserTeamUncheckedUpdateWithoutUserInput>
    create: XOR<UserTeamCreateWithoutUserInput, UserTeamUncheckedCreateWithoutUserInput>
  }

  export type UserTeamUpdateWithWhereUniqueWithoutUserInput = {
    where: UserTeamWhereUniqueInput
    data: XOR<UserTeamUpdateWithoutUserInput, UserTeamUncheckedUpdateWithoutUserInput>
  }

  export type UserTeamUpdateManyWithWhereWithoutUserInput = {
    where: UserTeamScalarWhereInput
    data: XOR<UserTeamUpdateManyMutationInput, UserTeamUncheckedUpdateManyWithoutUserInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutAuthorInput, ReportUncheckedUpdateWithoutAuthorInput>
    create: XOR<ReportCreateWithoutAuthorInput, ReportUncheckedCreateWithoutAuthorInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutAuthorInput, ReportUncheckedUpdateWithoutAuthorInput>
  }

  export type ReportUpdateManyWithWhereWithoutAuthorInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PlayerUpsertWithWhereUniqueWithoutUserInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutUserInput, PlayerUncheckedUpdateWithoutUserInput>
    create: XOR<PlayerCreateWithoutUserInput, PlayerUncheckedCreateWithoutUserInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutUserInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutUserInput, PlayerUncheckedUpdateWithoutUserInput>
  }

  export type PlayerUpdateManyWithWhereWithoutUserInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutTeamsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    rpeEntries?: RPEEntryCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    players?: PlayerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rpeEntries?: RPEEntryUncheckedCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryUncheckedCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    players?: PlayerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
  }

  export type TeamCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rivals?: RivalCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackCreateNestedManyWithoutTeamInput
    sessions?: SessionCreateNestedManyWithoutTeamInput
    places?: PlaceCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerCreateNestedManyWithoutTeamInput
    videos?: TeamVideoCreateNestedManyWithoutTeamInput
    reports?: ReportCreateNestedManyWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rivals?: RivalUncheckedCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackUncheckedCreateNestedManyWithoutTeamInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTeamInput
    places?: PlaceUncheckedCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryUncheckedCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerUncheckedCreateNestedManyWithoutTeamInput
    videos?: TeamVideoUncheckedCreateNestedManyWithoutTeamInput
    reports?: ReportUncheckedCreateNestedManyWithoutTeamInput
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type UserUpsertWithoutTeamsInput = {
    update: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>
  }

  export type UserUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rpeEntries?: RPEEntryUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    players?: PlayerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rpeEntries?: RPEEntryUncheckedUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUncheckedUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    players?: PlayerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rivals?: RivalUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUpdateManyWithoutTeamNestedInput
    sessions?: SessionUpdateManyWithoutTeamNestedInput
    places?: PlaceUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUpdateManyWithoutTeamNestedInput
    reports?: ReportUpdateManyWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rivals?: RivalUncheckedUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUncheckedUpdateManyWithoutTeamNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTeamNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUncheckedUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUncheckedUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUncheckedUpdateManyWithoutTeamNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTeamNestedInput
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rpeEntries?: RPEEntryCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryCreateNestedManyWithoutUserInput
    teams?: UserTeamCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    players?: PlayerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rpeEntries?: RPEEntryUncheckedCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryUncheckedCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryUncheckedCreateNestedManyWithoutUserInput
    teams?: UserTeamUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    players?: PlayerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type TeamCreateWithoutSessionsInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamCreateNestedManyWithoutTeamInput
    rivals?: RivalCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackCreateNestedManyWithoutTeamInput
    places?: PlaceCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerCreateNestedManyWithoutTeamInput
    videos?: TeamVideoCreateNestedManyWithoutTeamInput
    reports?: ReportCreateNestedManyWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamUncheckedCreateNestedManyWithoutTeamInput
    rivals?: RivalUncheckedCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackUncheckedCreateNestedManyWithoutTeamInput
    places?: PlaceUncheckedCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryUncheckedCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerUncheckedCreateNestedManyWithoutTeamInput
    videos?: TeamVideoUncheckedCreateNestedManyWithoutTeamInput
    reports?: ReportUncheckedCreateNestedManyWithoutTeamInput
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutSessionsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutSessionsInput, TeamUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rpeEntries?: RPEEntryUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUpdateManyWithoutUserNestedInput
    teams?: UserTeamUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    players?: PlayerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rpeEntries?: RPEEntryUncheckedUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUncheckedUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUncheckedUpdateManyWithoutUserNestedInput
    teams?: UserTeamUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    players?: PlayerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamUpsertWithoutSessionsInput = {
    update: XOR<TeamUpdateWithoutSessionsInput, TeamUncheckedUpdateWithoutSessionsInput>
    create: XOR<TeamCreateWithoutSessionsInput, TeamUncheckedCreateWithoutSessionsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutSessionsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutSessionsInput, TeamUncheckedUpdateWithoutSessionsInput>
  }

  export type TeamUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUpdateManyWithoutTeamNestedInput
    rivals?: RivalUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUpdateManyWithoutTeamNestedInput
    places?: PlaceUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUpdateManyWithoutTeamNestedInput
    reports?: ReportUpdateManyWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUncheckedUpdateManyWithoutTeamNestedInput
    rivals?: RivalUncheckedUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUncheckedUpdateManyWithoutTeamNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUncheckedUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUncheckedUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUncheckedUpdateManyWithoutTeamNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTeamNestedInput
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateWithoutRivalsInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackCreateNestedManyWithoutTeamInput
    sessions?: SessionCreateNestedManyWithoutTeamInput
    places?: PlaceCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerCreateNestedManyWithoutTeamInput
    videos?: TeamVideoCreateNestedManyWithoutTeamInput
    reports?: ReportCreateNestedManyWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutRivalsInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamUncheckedCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackUncheckedCreateNestedManyWithoutTeamInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTeamInput
    places?: PlaceUncheckedCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryUncheckedCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerUncheckedCreateNestedManyWithoutTeamInput
    videos?: TeamVideoUncheckedCreateNestedManyWithoutTeamInput
    reports?: ReportUncheckedCreateNestedManyWithoutTeamInput
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutRivalsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutRivalsInput, TeamUncheckedCreateWithoutRivalsInput>
  }

  export type TeamUpsertWithoutRivalsInput = {
    update: XOR<TeamUpdateWithoutRivalsInput, TeamUncheckedUpdateWithoutRivalsInput>
    create: XOR<TeamCreateWithoutRivalsInput, TeamUncheckedCreateWithoutRivalsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutRivalsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutRivalsInput, TeamUncheckedUpdateWithoutRivalsInput>
  }

  export type TeamUpdateWithoutRivalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUpdateManyWithoutTeamNestedInput
    sessions?: SessionUpdateManyWithoutTeamNestedInput
    places?: PlaceUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUpdateManyWithoutTeamNestedInput
    reports?: ReportUpdateManyWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutRivalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUncheckedUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUncheckedUpdateManyWithoutTeamNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTeamNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUncheckedUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUncheckedUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUncheckedUpdateManyWithoutTeamNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTeamNestedInput
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateWithoutFeedbackInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamCreateNestedManyWithoutTeamInput
    rivals?: RivalCreateNestedManyWithoutTeamInput
    sessions?: SessionCreateNestedManyWithoutTeamInput
    places?: PlaceCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerCreateNestedManyWithoutTeamInput
    videos?: TeamVideoCreateNestedManyWithoutTeamInput
    reports?: ReportCreateNestedManyWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutFeedbackInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamUncheckedCreateNestedManyWithoutTeamInput
    rivals?: RivalUncheckedCreateNestedManyWithoutTeamInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTeamInput
    places?: PlaceUncheckedCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryUncheckedCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerUncheckedCreateNestedManyWithoutTeamInput
    videos?: TeamVideoUncheckedCreateNestedManyWithoutTeamInput
    reports?: ReportUncheckedCreateNestedManyWithoutTeamInput
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutFeedbackInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutFeedbackInput, TeamUncheckedCreateWithoutFeedbackInput>
  }

  export type TeamUpsertWithoutFeedbackInput = {
    update: XOR<TeamUpdateWithoutFeedbackInput, TeamUncheckedUpdateWithoutFeedbackInput>
    create: XOR<TeamCreateWithoutFeedbackInput, TeamUncheckedCreateWithoutFeedbackInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutFeedbackInput, TeamUncheckedUpdateWithoutFeedbackInput>
  }

  export type TeamUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUpdateManyWithoutTeamNestedInput
    rivals?: RivalUpdateManyWithoutTeamNestedInput
    sessions?: SessionUpdateManyWithoutTeamNestedInput
    places?: PlaceUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUpdateManyWithoutTeamNestedInput
    reports?: ReportUpdateManyWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUncheckedUpdateManyWithoutTeamNestedInput
    rivals?: RivalUncheckedUpdateManyWithoutTeamNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTeamNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUncheckedUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUncheckedUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUncheckedUpdateManyWithoutTeamNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTeamNestedInput
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateWithoutPlacesInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamCreateNestedManyWithoutTeamInput
    rivals?: RivalCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackCreateNestedManyWithoutTeamInput
    sessions?: SessionCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerCreateNestedManyWithoutTeamInput
    videos?: TeamVideoCreateNestedManyWithoutTeamInput
    reports?: ReportCreateNestedManyWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutPlacesInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamUncheckedCreateNestedManyWithoutTeamInput
    rivals?: RivalUncheckedCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackUncheckedCreateNestedManyWithoutTeamInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryUncheckedCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerUncheckedCreateNestedManyWithoutTeamInput
    videos?: TeamVideoUncheckedCreateNestedManyWithoutTeamInput
    reports?: ReportUncheckedCreateNestedManyWithoutTeamInput
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutPlacesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutPlacesInput, TeamUncheckedCreateWithoutPlacesInput>
  }

  export type TeamUpsertWithoutPlacesInput = {
    update: XOR<TeamUpdateWithoutPlacesInput, TeamUncheckedUpdateWithoutPlacesInput>
    create: XOR<TeamCreateWithoutPlacesInput, TeamUncheckedCreateWithoutPlacesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutPlacesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutPlacesInput, TeamUncheckedUpdateWithoutPlacesInput>
  }

  export type TeamUpdateWithoutPlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUpdateManyWithoutTeamNestedInput
    rivals?: RivalUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUpdateManyWithoutTeamNestedInput
    sessions?: SessionUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUpdateManyWithoutTeamNestedInput
    reports?: ReportUpdateManyWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutPlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUncheckedUpdateManyWithoutTeamNestedInput
    rivals?: RivalUncheckedUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUncheckedUpdateManyWithoutTeamNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUncheckedUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUncheckedUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUncheckedUpdateManyWithoutTeamNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTeamNestedInput
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type ExerciseCreateWithoutKindInput = {
    id?: string
    title: string
    space?: string | null
    players?: string | null
    duration?: string | null
    description?: string | null
    imageUrl?: string | null
    tags?: ExerciseCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExercisesInput
  }

  export type ExerciseUncheckedCreateWithoutKindInput = {
    id?: string
    userId: string
    title: string
    space?: string | null
    players?: string | null
    duration?: string | null
    description?: string | null
    imageUrl?: string | null
    tags?: ExerciseCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseCreateOrConnectWithoutKindInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutKindInput, ExerciseUncheckedCreateWithoutKindInput>
  }

  export type ExerciseCreateManyKindInputEnvelope = {
    data: ExerciseCreateManyKindInput | ExerciseCreateManyKindInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseUpsertWithWhereUniqueWithoutKindInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutKindInput, ExerciseUncheckedUpdateWithoutKindInput>
    create: XOR<ExerciseCreateWithoutKindInput, ExerciseUncheckedCreateWithoutKindInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutKindInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutKindInput, ExerciseUncheckedUpdateWithoutKindInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutKindInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutKindInput>
  }

  export type UserCreateWithoutExercisesInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    rpeEntries?: RPEEntryCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryCreateNestedManyWithoutUserInput
    teams?: UserTeamCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    players?: PlayerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExercisesInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rpeEntries?: RPEEntryUncheckedCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryUncheckedCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryUncheckedCreateNestedManyWithoutUserInput
    teams?: UserTeamUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    players?: PlayerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExercisesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExercisesInput, UserUncheckedCreateWithoutExercisesInput>
  }

  export type ExerciseKindCreateWithoutExercisesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseKindUncheckedCreateWithoutExercisesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseKindCreateOrConnectWithoutExercisesInput = {
    where: ExerciseKindWhereUniqueInput
    create: XOR<ExerciseKindCreateWithoutExercisesInput, ExerciseKindUncheckedCreateWithoutExercisesInput>
  }

  export type UserUpsertWithoutExercisesInput = {
    update: XOR<UserUpdateWithoutExercisesInput, UserUncheckedUpdateWithoutExercisesInput>
    create: XOR<UserCreateWithoutExercisesInput, UserUncheckedCreateWithoutExercisesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExercisesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExercisesInput, UserUncheckedUpdateWithoutExercisesInput>
  }

  export type UserUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rpeEntries?: RPEEntryUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUpdateManyWithoutUserNestedInput
    teams?: UserTeamUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    players?: PlayerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rpeEntries?: RPEEntryUncheckedUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUncheckedUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUncheckedUpdateManyWithoutUserNestedInput
    teams?: UserTeamUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    players?: PlayerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExerciseKindUpsertWithoutExercisesInput = {
    update: XOR<ExerciseKindUpdateWithoutExercisesInput, ExerciseKindUncheckedUpdateWithoutExercisesInput>
    create: XOR<ExerciseKindCreateWithoutExercisesInput, ExerciseKindUncheckedCreateWithoutExercisesInput>
    where?: ExerciseKindWhereInput
  }

  export type ExerciseKindUpdateToOneWithWhereWithoutExercisesInput = {
    where?: ExerciseKindWhereInput
    data: XOR<ExerciseKindUpdateWithoutExercisesInput, ExerciseKindUncheckedUpdateWithoutExercisesInput>
  }

  export type ExerciseKindUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseKindUncheckedUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutRpeEntriesInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryCreateNestedManyWithoutUserInput
    teams?: UserTeamCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    players?: PlayerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRpeEntriesInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryUncheckedCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryUncheckedCreateNestedManyWithoutUserInput
    teams?: UserTeamUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    players?: PlayerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRpeEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRpeEntriesInput, UserUncheckedCreateWithoutRpeEntriesInput>
  }

  export type UserUpsertWithoutRpeEntriesInput = {
    update: XOR<UserUpdateWithoutRpeEntriesInput, UserUncheckedUpdateWithoutRpeEntriesInput>
    create: XOR<UserCreateWithoutRpeEntriesInput, UserUncheckedCreateWithoutRpeEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRpeEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRpeEntriesInput, UserUncheckedUpdateWithoutRpeEntriesInput>
  }

  export type UserUpdateWithoutRpeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUpdateManyWithoutUserNestedInput
    teams?: UserTeamUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    players?: PlayerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRpeEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUncheckedUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUncheckedUpdateManyWithoutUserNestedInput
    teams?: UserTeamUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    players?: PlayerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutWellnessEntriesInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    rpeEntries?: RPEEntryCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryCreateNestedManyWithoutUserInput
    teams?: UserTeamCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    players?: PlayerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWellnessEntriesInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rpeEntries?: RPEEntryUncheckedCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryUncheckedCreateNestedManyWithoutUserInput
    teams?: UserTeamUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    players?: PlayerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWellnessEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWellnessEntriesInput, UserUncheckedCreateWithoutWellnessEntriesInput>
  }

  export type UserUpsertWithoutWellnessEntriesInput = {
    update: XOR<UserUpdateWithoutWellnessEntriesInput, UserUncheckedUpdateWithoutWellnessEntriesInput>
    create: XOR<UserCreateWithoutWellnessEntriesInput, UserUncheckedCreateWithoutWellnessEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWellnessEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWellnessEntriesInput, UserUncheckedUpdateWithoutWellnessEntriesInput>
  }

  export type UserUpdateWithoutWellnessEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rpeEntries?: RPEEntryUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUpdateManyWithoutUserNestedInput
    teams?: UserTeamUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    players?: PlayerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWellnessEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rpeEntries?: RPEEntryUncheckedUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUncheckedUpdateManyWithoutUserNestedInput
    teams?: UserTeamUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    players?: PlayerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPlannerPrefsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    rpeEntries?: RPEEntryCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryCreateNestedManyWithoutUserInput
    teams?: UserTeamCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    players?: PlayerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlannerPrefsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rpeEntries?: RPEEntryUncheckedCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryUncheckedCreateNestedManyWithoutUserInput
    teams?: UserTeamUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    players?: PlayerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlannerPrefsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlannerPrefsInput, UserUncheckedCreateWithoutPlannerPrefsInput>
  }

  export type TeamCreateWithoutPlannerPrefsInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamCreateNestedManyWithoutTeamInput
    rivals?: RivalCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackCreateNestedManyWithoutTeamInput
    sessions?: SessionCreateNestedManyWithoutTeamInput
    places?: PlaceCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerCreateNestedManyWithoutTeamInput
    videos?: TeamVideoCreateNestedManyWithoutTeamInput
    reports?: ReportCreateNestedManyWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutPlannerPrefsInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamUncheckedCreateNestedManyWithoutTeamInput
    rivals?: RivalUncheckedCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackUncheckedCreateNestedManyWithoutTeamInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTeamInput
    places?: PlaceUncheckedCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryUncheckedCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerUncheckedCreateNestedManyWithoutTeamInput
    videos?: TeamVideoUncheckedCreateNestedManyWithoutTeamInput
    reports?: ReportUncheckedCreateNestedManyWithoutTeamInput
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutPlannerPrefsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutPlannerPrefsInput, TeamUncheckedCreateWithoutPlannerPrefsInput>
  }

  export type UserUpsertWithoutPlannerPrefsInput = {
    update: XOR<UserUpdateWithoutPlannerPrefsInput, UserUncheckedUpdateWithoutPlannerPrefsInput>
    create: XOR<UserCreateWithoutPlannerPrefsInput, UserUncheckedCreateWithoutPlannerPrefsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlannerPrefsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlannerPrefsInput, UserUncheckedUpdateWithoutPlannerPrefsInput>
  }

  export type UserUpdateWithoutPlannerPrefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rpeEntries?: RPEEntryUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUpdateManyWithoutUserNestedInput
    teams?: UserTeamUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    players?: PlayerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlannerPrefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rpeEntries?: RPEEntryUncheckedUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUncheckedUpdateManyWithoutUserNestedInput
    teams?: UserTeamUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    players?: PlayerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamUpsertWithoutPlannerPrefsInput = {
    update: XOR<TeamUpdateWithoutPlannerPrefsInput, TeamUncheckedUpdateWithoutPlannerPrefsInput>
    create: XOR<TeamCreateWithoutPlannerPrefsInput, TeamUncheckedCreateWithoutPlannerPrefsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutPlannerPrefsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutPlannerPrefsInput, TeamUncheckedUpdateWithoutPlannerPrefsInput>
  }

  export type TeamUpdateWithoutPlannerPrefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUpdateManyWithoutTeamNestedInput
    rivals?: RivalUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUpdateManyWithoutTeamNestedInput
    sessions?: SessionUpdateManyWithoutTeamNestedInput
    places?: PlaceUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUpdateManyWithoutTeamNestedInput
    reports?: ReportUpdateManyWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutPlannerPrefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUncheckedUpdateManyWithoutTeamNestedInput
    rivals?: RivalUncheckedUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUncheckedUpdateManyWithoutTeamNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTeamNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUncheckedUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUncheckedUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUncheckedUpdateManyWithoutTeamNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTeamNestedInput
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserCreateWithoutClinicalEntriesInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    rpeEntries?: RPEEntryCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    teams?: UserTeamCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    players?: PlayerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClinicalEntriesInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rpeEntries?: RPEEntryUncheckedCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryUncheckedCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    teams?: UserTeamUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    players?: PlayerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClinicalEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClinicalEntriesInput, UserUncheckedCreateWithoutClinicalEntriesInput>
  }

  export type UserUpsertWithoutClinicalEntriesInput = {
    update: XOR<UserUpdateWithoutClinicalEntriesInput, UserUncheckedUpdateWithoutClinicalEntriesInput>
    create: XOR<UserCreateWithoutClinicalEntriesInput, UserUncheckedCreateWithoutClinicalEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClinicalEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClinicalEntriesInput, UserUncheckedUpdateWithoutClinicalEntriesInput>
  }

  export type UserUpdateWithoutClinicalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rpeEntries?: RPEEntryUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    teams?: UserTeamUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    players?: PlayerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClinicalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rpeEntries?: RPEEntryUncheckedUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUncheckedUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    teams?: UserTeamUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    players?: PlayerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamCreateWithoutScoutingCategoriesInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamCreateNestedManyWithoutTeamInput
    rivals?: RivalCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackCreateNestedManyWithoutTeamInput
    sessions?: SessionCreateNestedManyWithoutTeamInput
    places?: PlaceCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerCreateNestedManyWithoutTeamInput
    videos?: TeamVideoCreateNestedManyWithoutTeamInput
    reports?: ReportCreateNestedManyWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutScoutingCategoriesInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamUncheckedCreateNestedManyWithoutTeamInput
    rivals?: RivalUncheckedCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackUncheckedCreateNestedManyWithoutTeamInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTeamInput
    places?: PlaceUncheckedCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerUncheckedCreateNestedManyWithoutTeamInput
    videos?: TeamVideoUncheckedCreateNestedManyWithoutTeamInput
    reports?: ReportUncheckedCreateNestedManyWithoutTeamInput
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutScoutingCategoriesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutScoutingCategoriesInput, TeamUncheckedCreateWithoutScoutingCategoriesInput>
  }

  export type ScoutingPlayerCreateWithoutCategoriaInput = {
    id?: string
    fullName: string
    positions?: ScoutingPlayerCreatepositionsInput | string[]
    club?: string | null
    estado?: $Enums.ScoutingStatus
    agentName?: string | null
    agentPhone?: string | null
    agentEmail?: string | null
    playerPhone?: string | null
    playerEmail?: string | null
    instagram?: string | null
    videos?: ScoutingPlayerCreatevideosInput | string[]
    notes?: string | null
    rating?: number | null
    tags?: ScoutingPlayerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutScoutingPlayersInput
  }

  export type ScoutingPlayerUncheckedCreateWithoutCategoriaInput = {
    id?: string
    teamId?: string | null
    fullName: string
    positions?: ScoutingPlayerCreatepositionsInput | string[]
    club?: string | null
    estado?: $Enums.ScoutingStatus
    agentName?: string | null
    agentPhone?: string | null
    agentEmail?: string | null
    playerPhone?: string | null
    playerEmail?: string | null
    instagram?: string | null
    videos?: ScoutingPlayerCreatevideosInput | string[]
    notes?: string | null
    rating?: number | null
    tags?: ScoutingPlayerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScoutingPlayerCreateOrConnectWithoutCategoriaInput = {
    where: ScoutingPlayerWhereUniqueInput
    create: XOR<ScoutingPlayerCreateWithoutCategoriaInput, ScoutingPlayerUncheckedCreateWithoutCategoriaInput>
  }

  export type ScoutingPlayerCreateManyCategoriaInputEnvelope = {
    data: ScoutingPlayerCreateManyCategoriaInput | ScoutingPlayerCreateManyCategoriaInput[]
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithoutScoutingCategoriesInput = {
    update: XOR<TeamUpdateWithoutScoutingCategoriesInput, TeamUncheckedUpdateWithoutScoutingCategoriesInput>
    create: XOR<TeamCreateWithoutScoutingCategoriesInput, TeamUncheckedCreateWithoutScoutingCategoriesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutScoutingCategoriesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutScoutingCategoriesInput, TeamUncheckedUpdateWithoutScoutingCategoriesInput>
  }

  export type TeamUpdateWithoutScoutingCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUpdateManyWithoutTeamNestedInput
    rivals?: RivalUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUpdateManyWithoutTeamNestedInput
    sessions?: SessionUpdateManyWithoutTeamNestedInput
    places?: PlaceUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUpdateManyWithoutTeamNestedInput
    reports?: ReportUpdateManyWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutScoutingCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUncheckedUpdateManyWithoutTeamNestedInput
    rivals?: RivalUncheckedUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUncheckedUpdateManyWithoutTeamNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTeamNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUncheckedUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUncheckedUpdateManyWithoutTeamNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTeamNestedInput
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type ScoutingPlayerUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: ScoutingPlayerWhereUniqueInput
    update: XOR<ScoutingPlayerUpdateWithoutCategoriaInput, ScoutingPlayerUncheckedUpdateWithoutCategoriaInput>
    create: XOR<ScoutingPlayerCreateWithoutCategoriaInput, ScoutingPlayerUncheckedCreateWithoutCategoriaInput>
  }

  export type ScoutingPlayerUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: ScoutingPlayerWhereUniqueInput
    data: XOR<ScoutingPlayerUpdateWithoutCategoriaInput, ScoutingPlayerUncheckedUpdateWithoutCategoriaInput>
  }

  export type ScoutingPlayerUpdateManyWithWhereWithoutCategoriaInput = {
    where: ScoutingPlayerScalarWhereInput
    data: XOR<ScoutingPlayerUpdateManyMutationInput, ScoutingPlayerUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type TeamCreateWithoutPlayersInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamCreateNestedManyWithoutTeamInput
    rivals?: RivalCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackCreateNestedManyWithoutTeamInput
    sessions?: SessionCreateNestedManyWithoutTeamInput
    places?: PlaceCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerCreateNestedManyWithoutTeamInput
    videos?: TeamVideoCreateNestedManyWithoutTeamInput
    reports?: ReportCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutPlayersInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamUncheckedCreateNestedManyWithoutTeamInput
    rivals?: RivalUncheckedCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackUncheckedCreateNestedManyWithoutTeamInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTeamInput
    places?: PlaceUncheckedCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryUncheckedCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerUncheckedCreateNestedManyWithoutTeamInput
    videos?: TeamVideoUncheckedCreateNestedManyWithoutTeamInput
    reports?: ReportUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutPlayersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutPlayersInput, TeamUncheckedCreateWithoutPlayersInput>
  }

  export type UserCreateWithoutPlayersInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    rpeEntries?: RPEEntryCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryCreateNestedManyWithoutUserInput
    teams?: UserTeamCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutPlayersInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rpeEntries?: RPEEntryUncheckedCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryUncheckedCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryUncheckedCreateNestedManyWithoutUserInput
    teams?: UserTeamUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutPlayersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlayersInput, UserUncheckedCreateWithoutPlayersInput>
  }

  export type TeamUpsertWithoutPlayersInput = {
    update: XOR<TeamUpdateWithoutPlayersInput, TeamUncheckedUpdateWithoutPlayersInput>
    create: XOR<TeamCreateWithoutPlayersInput, TeamUncheckedCreateWithoutPlayersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutPlayersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutPlayersInput, TeamUncheckedUpdateWithoutPlayersInput>
  }

  export type TeamUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUpdateManyWithoutTeamNestedInput
    rivals?: RivalUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUpdateManyWithoutTeamNestedInput
    sessions?: SessionUpdateManyWithoutTeamNestedInput
    places?: PlaceUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUpdateManyWithoutTeamNestedInput
    reports?: ReportUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUncheckedUpdateManyWithoutTeamNestedInput
    rivals?: RivalUncheckedUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUncheckedUpdateManyWithoutTeamNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTeamNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUncheckedUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUncheckedUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUncheckedUpdateManyWithoutTeamNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutPlayersInput = {
    update: XOR<UserUpdateWithoutPlayersInput, UserUncheckedUpdateWithoutPlayersInput>
    create: XOR<UserCreateWithoutPlayersInput, UserUncheckedCreateWithoutPlayersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlayersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlayersInput, UserUncheckedUpdateWithoutPlayersInput>
  }

  export type UserUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rpeEntries?: RPEEntryUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUpdateManyWithoutUserNestedInput
    teams?: UserTeamUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rpeEntries?: RPEEntryUncheckedUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUncheckedUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUncheckedUpdateManyWithoutUserNestedInput
    teams?: UserTeamUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type TeamCreateWithoutScoutingPlayersInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamCreateNestedManyWithoutTeamInput
    rivals?: RivalCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackCreateNestedManyWithoutTeamInput
    sessions?: SessionCreateNestedManyWithoutTeamInput
    places?: PlaceCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryCreateNestedManyWithoutTeamInput
    videos?: TeamVideoCreateNestedManyWithoutTeamInput
    reports?: ReportCreateNestedManyWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutScoutingPlayersInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamUncheckedCreateNestedManyWithoutTeamInput
    rivals?: RivalUncheckedCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackUncheckedCreateNestedManyWithoutTeamInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTeamInput
    places?: PlaceUncheckedCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryUncheckedCreateNestedManyWithoutTeamInput
    videos?: TeamVideoUncheckedCreateNestedManyWithoutTeamInput
    reports?: ReportUncheckedCreateNestedManyWithoutTeamInput
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutScoutingPlayersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutScoutingPlayersInput, TeamUncheckedCreateWithoutScoutingPlayersInput>
  }

  export type ScoutingCategoryCreateWithoutPlayersInput = {
    id?: string
    nombre: string
    slug: string
    orden?: number
    color?: string | null
    activa?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutScoutingCategoriesInput
  }

  export type ScoutingCategoryUncheckedCreateWithoutPlayersInput = {
    id?: string
    teamId?: string | null
    nombre: string
    slug: string
    orden?: number
    color?: string | null
    activa?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScoutingCategoryCreateOrConnectWithoutPlayersInput = {
    where: ScoutingCategoryWhereUniqueInput
    create: XOR<ScoutingCategoryCreateWithoutPlayersInput, ScoutingCategoryUncheckedCreateWithoutPlayersInput>
  }

  export type TeamUpsertWithoutScoutingPlayersInput = {
    update: XOR<TeamUpdateWithoutScoutingPlayersInput, TeamUncheckedUpdateWithoutScoutingPlayersInput>
    create: XOR<TeamCreateWithoutScoutingPlayersInput, TeamUncheckedCreateWithoutScoutingPlayersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutScoutingPlayersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutScoutingPlayersInput, TeamUncheckedUpdateWithoutScoutingPlayersInput>
  }

  export type TeamUpdateWithoutScoutingPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUpdateManyWithoutTeamNestedInput
    rivals?: RivalUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUpdateManyWithoutTeamNestedInput
    sessions?: SessionUpdateManyWithoutTeamNestedInput
    places?: PlaceUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUpdateManyWithoutTeamNestedInput
    reports?: ReportUpdateManyWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutScoutingPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUncheckedUpdateManyWithoutTeamNestedInput
    rivals?: RivalUncheckedUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUncheckedUpdateManyWithoutTeamNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTeamNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUncheckedUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUncheckedUpdateManyWithoutTeamNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTeamNestedInput
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type ScoutingCategoryUpsertWithoutPlayersInput = {
    update: XOR<ScoutingCategoryUpdateWithoutPlayersInput, ScoutingCategoryUncheckedUpdateWithoutPlayersInput>
    create: XOR<ScoutingCategoryCreateWithoutPlayersInput, ScoutingCategoryUncheckedCreateWithoutPlayersInput>
    where?: ScoutingCategoryWhereInput
  }

  export type ScoutingCategoryUpdateToOneWithWhereWithoutPlayersInput = {
    where?: ScoutingCategoryWhereInput
    data: XOR<ScoutingCategoryUpdateWithoutPlayersInput, ScoutingCategoryUncheckedUpdateWithoutPlayersInput>
  }

  export type ScoutingCategoryUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    activa?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutScoutingCategoriesNestedInput
  }

  export type ScoutingCategoryUncheckedUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    activa?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateWithoutReportsInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamCreateNestedManyWithoutTeamInput
    rivals?: RivalCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackCreateNestedManyWithoutTeamInput
    sessions?: SessionCreateNestedManyWithoutTeamInput
    places?: PlaceCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerCreateNestedManyWithoutTeamInput
    videos?: TeamVideoCreateNestedManyWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamUncheckedCreateNestedManyWithoutTeamInput
    rivals?: RivalUncheckedCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackUncheckedCreateNestedManyWithoutTeamInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTeamInput
    places?: PlaceUncheckedCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryUncheckedCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerUncheckedCreateNestedManyWithoutTeamInput
    videos?: TeamVideoUncheckedCreateNestedManyWithoutTeamInput
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutReportsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutReportsInput, TeamUncheckedCreateWithoutReportsInput>
  }

  export type UserCreateWithoutReportsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    rpeEntries?: RPEEntryCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryCreateNestedManyWithoutUserInput
    teams?: UserTeamCreateNestedManyWithoutUserInput
    players?: PlayerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.Role
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    rpeEntries?: RPEEntryUncheckedCreateNestedManyWithoutUserInput
    wellnessEntries?: WellnessEntryUncheckedCreateNestedManyWithoutUserInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutUserInput
    clinicalEntries?: ClinicalEntryUncheckedCreateNestedManyWithoutUserInput
    teams?: UserTeamUncheckedCreateNestedManyWithoutUserInput
    players?: PlayerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
  }

  export type TeamUpsertWithoutReportsInput = {
    update: XOR<TeamUpdateWithoutReportsInput, TeamUncheckedUpdateWithoutReportsInput>
    create: XOR<TeamCreateWithoutReportsInput, TeamUncheckedCreateWithoutReportsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutReportsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutReportsInput, TeamUncheckedUpdateWithoutReportsInput>
  }

  export type TeamUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUpdateManyWithoutTeamNestedInput
    rivals?: RivalUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUpdateManyWithoutTeamNestedInput
    sessions?: SessionUpdateManyWithoutTeamNestedInput
    places?: PlaceUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUpdateManyWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUncheckedUpdateManyWithoutTeamNestedInput
    rivals?: RivalUncheckedUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUncheckedUpdateManyWithoutTeamNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTeamNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUncheckedUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUncheckedUpdateManyWithoutTeamNestedInput
    videos?: TeamVideoUncheckedUpdateManyWithoutTeamNestedInput
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutReportsInput = {
    update: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    rpeEntries?: RPEEntryUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUpdateManyWithoutUserNestedInput
    teams?: UserTeamUpdateManyWithoutUserNestedInput
    players?: PlayerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    rpeEntries?: RPEEntryUncheckedUpdateManyWithoutUserNestedInput
    wellnessEntries?: WellnessEntryUncheckedUpdateManyWithoutUserNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutUserNestedInput
    clinicalEntries?: ClinicalEntryUncheckedUpdateManyWithoutUserNestedInput
    teams?: UserTeamUncheckedUpdateManyWithoutUserNestedInput
    players?: PlayerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamCreateWithoutVideosInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamCreateNestedManyWithoutTeamInput
    rivals?: RivalCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackCreateNestedManyWithoutTeamInput
    sessions?: SessionCreateNestedManyWithoutTeamInput
    places?: PlaceCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerCreateNestedManyWithoutTeamInput
    reports?: ReportCreateNestedManyWithoutTeamInput
    players?: PlayerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutVideosInput = {
    id?: string
    name: string
    slug: string
    isActive?: boolean
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserTeamUncheckedCreateNestedManyWithoutTeamInput
    rivals?: RivalUncheckedCreateNestedManyWithoutTeamInput
    feedback?: PlayerFeedbackUncheckedCreateNestedManyWithoutTeamInput
    sessions?: SessionUncheckedCreateNestedManyWithoutTeamInput
    places?: PlaceUncheckedCreateNestedManyWithoutTeamInput
    plannerPrefs?: PlannerPrefsUncheckedCreateNestedManyWithoutTeamInput
    scoutingCategories?: ScoutingCategoryUncheckedCreateNestedManyWithoutTeamInput
    scoutingPlayers?: ScoutingPlayerUncheckedCreateNestedManyWithoutTeamInput
    reports?: ReportUncheckedCreateNestedManyWithoutTeamInput
    players?: PlayerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutVideosInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutVideosInput, TeamUncheckedCreateWithoutVideosInput>
  }

  export type TeamUpsertWithoutVideosInput = {
    update: XOR<TeamUpdateWithoutVideosInput, TeamUncheckedUpdateWithoutVideosInput>
    create: XOR<TeamCreateWithoutVideosInput, TeamUncheckedCreateWithoutVideosInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutVideosInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutVideosInput, TeamUncheckedUpdateWithoutVideosInput>
  }

  export type TeamUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUpdateManyWithoutTeamNestedInput
    rivals?: RivalUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUpdateManyWithoutTeamNestedInput
    sessions?: SessionUpdateManyWithoutTeamNestedInput
    places?: PlaceUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUpdateManyWithoutTeamNestedInput
    reports?: ReportUpdateManyWithoutTeamNestedInput
    players?: PlayerUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserTeamUncheckedUpdateManyWithoutTeamNestedInput
    rivals?: RivalUncheckedUpdateManyWithoutTeamNestedInput
    feedback?: PlayerFeedbackUncheckedUpdateManyWithoutTeamNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutTeamNestedInput
    places?: PlaceUncheckedUpdateManyWithoutTeamNestedInput
    plannerPrefs?: PlannerPrefsUncheckedUpdateManyWithoutTeamNestedInput
    scoutingCategories?: ScoutingCategoryUncheckedUpdateManyWithoutTeamNestedInput
    scoutingPlayers?: ScoutingPlayerUncheckedUpdateManyWithoutTeamNestedInput
    reports?: ReportUncheckedUpdateManyWithoutTeamNestedInput
    players?: PlayerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserTeamCreateManyTeamInput = {
    id?: string
    userId: string
    role: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type RivalCreateManyTeamInput = {
    id?: string
    name: string
    logoUrl?: string | null
    coach?: string | null
    baseSystem?: string | null
    nextMatchDate?: Date | string | null
    nextMatchCompetition?: string | null
    planCharlaUrl?: string | null
    planReport?: NullableJsonNullValueInput | InputJsonValue
    planVideos?: NullableJsonNullValueInput | InputJsonValue
    planStats?: NullableJsonNullValueInput | InputJsonValue
    planNotes?: NullableJsonNullValueInput | InputJsonValue
    planVisibility?: NullableJsonNullValueInput | InputJsonValue
    planSquad?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerFeedbackCreateManyTeamInput = {
    id?: string
    playerId: string
    subject?: string | null
    text: string
    rating?: number | null
    createdBy: string
    createdAt?: Date | string
  }

  export type SessionCreateManyTeamInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    type?: $Enums.SessionType
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type PlaceCreateManyTeamInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlannerPrefsCreateManyTeamInput = {
    id?: string
    userId: string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScoutingCategoryCreateManyTeamInput = {
    id?: string
    nombre: string
    slug: string
    orden?: number
    color?: string | null
    activa?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScoutingPlayerCreateManyTeamInput = {
    id?: string
    fullName: string
    positions?: ScoutingPlayerCreatepositionsInput | string[]
    club?: string | null
    estado?: $Enums.ScoutingStatus
    categoriaId?: string | null
    agentName?: string | null
    agentPhone?: string | null
    agentEmail?: string | null
    playerPhone?: string | null
    playerEmail?: string | null
    instagram?: string | null
    videos?: ScoutingPlayerCreatevideosInput | string[]
    notes?: string | null
    rating?: number | null
    tags?: ScoutingPlayerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamVideoCreateManyTeamInput = {
    id?: string
    url: string
    title: string
    notes?: string | null
    type: string
    visibleToDirectivo?: boolean
    createdAt?: Date | string
  }

  export type ReportCreateManyTeamInput = {
    id?: string
    title: string
    summary?: string | null
    content: string
    type: string
    authorId: string
    visibleToDirectivo?: boolean
    createdAt?: Date | string
  }

  export type PlayerCreateManyTeamInput = {
    id?: string
    userId?: string | null
    name: string
    shirtNumber?: number | null
    position?: string | null
    photoUrl?: string | null
    birthDate?: Date | string | null
    status?: $Enums.PlayerStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTeamUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamsNestedInput
  }

  export type UserTeamUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTeamUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RivalUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: NullableStringFieldUpdateOperationsInput | string | null
    baseSystem?: NullableStringFieldUpdateOperationsInput | string | null
    nextMatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMatchCompetition?: NullableStringFieldUpdateOperationsInput | string | null
    planCharlaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    planReport?: NullableJsonNullValueInput | InputJsonValue
    planVideos?: NullableJsonNullValueInput | InputJsonValue
    planStats?: NullableJsonNullValueInput | InputJsonValue
    planNotes?: NullableJsonNullValueInput | InputJsonValue
    planVisibility?: NullableJsonNullValueInput | InputJsonValue
    planSquad?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RivalUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: NullableStringFieldUpdateOperationsInput | string | null
    baseSystem?: NullableStringFieldUpdateOperationsInput | string | null
    nextMatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMatchCompetition?: NullableStringFieldUpdateOperationsInput | string | null
    planCharlaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    planReport?: NullableJsonNullValueInput | InputJsonValue
    planVideos?: NullableJsonNullValueInput | InputJsonValue
    planStats?: NullableJsonNullValueInput | InputJsonValue
    planNotes?: NullableJsonNullValueInput | InputJsonValue
    planVisibility?: NullableJsonNullValueInput | InputJsonValue
    planSquad?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RivalUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: NullableStringFieldUpdateOperationsInput | string | null
    baseSystem?: NullableStringFieldUpdateOperationsInput | string | null
    nextMatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMatchCompetition?: NullableStringFieldUpdateOperationsInput | string | null
    planCharlaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    planReport?: NullableJsonNullValueInput | InputJsonValue
    planVideos?: NullableJsonNullValueInput | InputJsonValue
    planStats?: NullableJsonNullValueInput | InputJsonValue
    planNotes?: NullableJsonNullValueInput | InputJsonValue
    planVisibility?: NullableJsonNullValueInput | InputJsonValue
    planSquad?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerFeedbackUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerFeedbackUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerFeedbackUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type SessionUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type PlaceUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlannerPrefsUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlannerPrefsNestedInput
  }

  export type PlannerPrefsUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlannerPrefsUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScoutingCategoryUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    activa?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: ScoutingPlayerUpdateManyWithoutCategoriaNestedInput
  }

  export type ScoutingCategoryUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    activa?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: ScoutingPlayerUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type ScoutingCategoryUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    activa?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScoutingPlayerUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    positions?: ScoutingPlayerUpdatepositionsInput | string[]
    club?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumScoutingStatusFieldUpdateOperationsInput | $Enums.ScoutingStatus
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    agentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    agentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    playerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    playerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ScoutingPlayerUpdatevideosInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: ScoutingPlayerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoria?: ScoutingCategoryUpdateOneWithoutPlayersNestedInput
  }

  export type ScoutingPlayerUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    positions?: ScoutingPlayerUpdatepositionsInput | string[]
    club?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumScoutingStatusFieldUpdateOperationsInput | $Enums.ScoutingStatus
    categoriaId?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    agentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    agentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    playerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    playerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ScoutingPlayerUpdatevideosInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: ScoutingPlayerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScoutingPlayerUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    positions?: ScoutingPlayerUpdatepositionsInput | string[]
    club?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumScoutingStatusFieldUpdateOperationsInput | $Enums.ScoutingStatus
    categoriaId?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    agentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    agentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    playerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    playerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ScoutingPlayerUpdatevideosInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: ScoutingPlayerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamVideoUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    visibleToDirectivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamVideoUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    visibleToDirectivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamVideoUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    visibleToDirectivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visibleToDirectivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    visibleToDirectivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    visibleToDirectivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shirtNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shirtNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    shirtNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    type?: $Enums.SessionType
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId: string
  }

  export type RPEEntryCreateManyUserInput = {
    id?: string
    date: Date | string
    session?: number
    sessionLabel?: string | null
    sessionUid?: string | null
    rpe: number
    duration?: number | null
    load?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WellnessEntryCreateManyUserInput = {
    id?: string
    date: Date | string
    sleepQuality: number
    sleepHours?: number | null
    fatigue: number
    muscleSoreness: number
    stress: number
    mood: number
    comment?: string | null
    total?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlannerPrefsCreateManyUserInput = {
    id?: string
    teamId: string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseCreateManyUserInput = {
    id?: string
    title: string
    kindId?: string | null
    space?: string | null
    players?: string | null
    duration?: string | null
    description?: string | null
    imageUrl?: string | null
    tags?: ExerciseCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicalEntryCreateManyUserInput = {
    id?: string
    date: Date | string
    status: $Enums.ClinicalStatus
    leaveStage?: $Enums.LeaveStage | null
    leaveKind?: $Enums.LeaveKind | null
    diagnosis?: string | null
    bodyPart?: string | null
    laterality?: $Enums.Laterality | null
    mechanism?: $Enums.Mechanism | null
    severity?: $Enums.Severity | null
    illSystem?: $Enums.SystemAffected | null
    illSymptoms?: string | null
    illContagious?: boolean | null
    illIsolationDays?: number | null
    illAptitude?: $Enums.IllAptitude | null
    feverMax?: number | null
    startDate?: Date | string | null
    daysPlanned?: number | null
    expectedReturn?: Date | string | null
    expectedReturnManual?: boolean | null
    capMinutes?: number | null
    noSprint?: boolean
    noChangeOfDirection?: boolean
    gymOnly?: boolean
    noContact?: boolean
    notes?: string | null
    medSignature?: string | null
    protocolObjectives?: string | null
    protocolTasks?: string | null
    protocolControls?: string | null
    protocolCriteria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTeamCreateManyUserInput = {
    id?: string
    teamId: string
    role: $Enums.TeamRole
    createdAt?: Date | string
  }

  export type ReportCreateManyAuthorInput = {
    id?: string
    teamId: string
    title: string
    summary?: string | null
    content: string
    type: string
    visibleToDirectivo?: boolean
    createdAt?: Date | string
  }

  export type PlayerCreateManyUserInput = {
    id?: string
    teamId: string
    name: string
    shirtNumber?: number | null
    position?: string | null
    photoUrl?: string | null
    birthDate?: Date | string | null
    status?: $Enums.PlayerStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type RPEEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: IntFieldUpdateOperationsInput | number
    sessionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sessionUid?: NullableStringFieldUpdateOperationsInput | string | null
    rpe?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    load?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RPEEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: IntFieldUpdateOperationsInput | number
    sessionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sessionUid?: NullableStringFieldUpdateOperationsInput | string | null
    rpe?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    load?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RPEEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: IntFieldUpdateOperationsInput | number
    sessionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    sessionUid?: NullableStringFieldUpdateOperationsInput | string | null
    rpe?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    load?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellnessEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepQuality?: IntFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    fatigue?: IntFieldUpdateOperationsInput | number
    muscleSoreness?: IntFieldUpdateOperationsInput | number
    stress?: IntFieldUpdateOperationsInput | number
    mood?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellnessEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepQuality?: IntFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    fatigue?: IntFieldUpdateOperationsInput | number
    muscleSoreness?: IntFieldUpdateOperationsInput | number
    stress?: IntFieldUpdateOperationsInput | number
    mood?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WellnessEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepQuality?: IntFieldUpdateOperationsInput | number
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    fatigue?: IntFieldUpdateOperationsInput | number
    muscleSoreness?: IntFieldUpdateOperationsInput | number
    stress?: IntFieldUpdateOperationsInput | number
    mood?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlannerPrefsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutPlannerPrefsNestedInput
  }

  export type PlannerPrefsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlannerPrefsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    rowLabels?: JsonNullValueInput | InputJsonValue
    places?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    space?: NullableStringFieldUpdateOperationsInput | string | null
    players?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ExerciseUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kind?: ExerciseKindUpdateOneWithoutExercisesNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    kindId?: NullableStringFieldUpdateOperationsInput | string | null
    space?: NullableStringFieldUpdateOperationsInput | string | null
    players?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ExerciseUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    kindId?: NullableStringFieldUpdateOperationsInput | string | null
    space?: NullableStringFieldUpdateOperationsInput | string | null
    players?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ExerciseUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClinicalStatusFieldUpdateOperationsInput | $Enums.ClinicalStatus
    leaveStage?: NullableEnumLeaveStageFieldUpdateOperationsInput | $Enums.LeaveStage | null
    leaveKind?: NullableEnumLeaveKindFieldUpdateOperationsInput | $Enums.LeaveKind | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    laterality?: NullableEnumLateralityFieldUpdateOperationsInput | $Enums.Laterality | null
    mechanism?: NullableEnumMechanismFieldUpdateOperationsInput | $Enums.Mechanism | null
    severity?: NullableEnumSeverityFieldUpdateOperationsInput | $Enums.Severity | null
    illSystem?: NullableEnumSystemAffectedFieldUpdateOperationsInput | $Enums.SystemAffected | null
    illSymptoms?: NullableStringFieldUpdateOperationsInput | string | null
    illContagious?: NullableBoolFieldUpdateOperationsInput | boolean | null
    illIsolationDays?: NullableIntFieldUpdateOperationsInput | number | null
    illAptitude?: NullableEnumIllAptitudeFieldUpdateOperationsInput | $Enums.IllAptitude | null
    feverMax?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysPlanned?: NullableIntFieldUpdateOperationsInput | number | null
    expectedReturn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnManual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    capMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    noSprint?: BoolFieldUpdateOperationsInput | boolean
    noChangeOfDirection?: BoolFieldUpdateOperationsInput | boolean
    gymOnly?: BoolFieldUpdateOperationsInput | boolean
    noContact?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    medSignature?: NullableStringFieldUpdateOperationsInput | string | null
    protocolObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    protocolTasks?: NullableStringFieldUpdateOperationsInput | string | null
    protocolControls?: NullableStringFieldUpdateOperationsInput | string | null
    protocolCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClinicalStatusFieldUpdateOperationsInput | $Enums.ClinicalStatus
    leaveStage?: NullableEnumLeaveStageFieldUpdateOperationsInput | $Enums.LeaveStage | null
    leaveKind?: NullableEnumLeaveKindFieldUpdateOperationsInput | $Enums.LeaveKind | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    laterality?: NullableEnumLateralityFieldUpdateOperationsInput | $Enums.Laterality | null
    mechanism?: NullableEnumMechanismFieldUpdateOperationsInput | $Enums.Mechanism | null
    severity?: NullableEnumSeverityFieldUpdateOperationsInput | $Enums.Severity | null
    illSystem?: NullableEnumSystemAffectedFieldUpdateOperationsInput | $Enums.SystemAffected | null
    illSymptoms?: NullableStringFieldUpdateOperationsInput | string | null
    illContagious?: NullableBoolFieldUpdateOperationsInput | boolean | null
    illIsolationDays?: NullableIntFieldUpdateOperationsInput | number | null
    illAptitude?: NullableEnumIllAptitudeFieldUpdateOperationsInput | $Enums.IllAptitude | null
    feverMax?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysPlanned?: NullableIntFieldUpdateOperationsInput | number | null
    expectedReturn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnManual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    capMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    noSprint?: BoolFieldUpdateOperationsInput | boolean
    noChangeOfDirection?: BoolFieldUpdateOperationsInput | boolean
    gymOnly?: BoolFieldUpdateOperationsInput | boolean
    noContact?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    medSignature?: NullableStringFieldUpdateOperationsInput | string | null
    protocolObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    protocolTasks?: NullableStringFieldUpdateOperationsInput | string | null
    protocolControls?: NullableStringFieldUpdateOperationsInput | string | null
    protocolCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClinicalStatusFieldUpdateOperationsInput | $Enums.ClinicalStatus
    leaveStage?: NullableEnumLeaveStageFieldUpdateOperationsInput | $Enums.LeaveStage | null
    leaveKind?: NullableEnumLeaveKindFieldUpdateOperationsInput | $Enums.LeaveKind | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    laterality?: NullableEnumLateralityFieldUpdateOperationsInput | $Enums.Laterality | null
    mechanism?: NullableEnumMechanismFieldUpdateOperationsInput | $Enums.Mechanism | null
    severity?: NullableEnumSeverityFieldUpdateOperationsInput | $Enums.Severity | null
    illSystem?: NullableEnumSystemAffectedFieldUpdateOperationsInput | $Enums.SystemAffected | null
    illSymptoms?: NullableStringFieldUpdateOperationsInput | string | null
    illContagious?: NullableBoolFieldUpdateOperationsInput | boolean | null
    illIsolationDays?: NullableIntFieldUpdateOperationsInput | number | null
    illAptitude?: NullableEnumIllAptitudeFieldUpdateOperationsInput | $Enums.IllAptitude | null
    feverMax?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    daysPlanned?: NullableIntFieldUpdateOperationsInput | number | null
    expectedReturn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnManual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    capMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    noSprint?: BoolFieldUpdateOperationsInput | boolean
    noChangeOfDirection?: BoolFieldUpdateOperationsInput | boolean
    gymOnly?: BoolFieldUpdateOperationsInput | boolean
    noContact?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    medSignature?: NullableStringFieldUpdateOperationsInput | string | null
    protocolObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    protocolTasks?: NullableStringFieldUpdateOperationsInput | string | null
    protocolControls?: NullableStringFieldUpdateOperationsInput | string | null
    protocolCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTeamUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type UserTeamUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTeamUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visibleToDirectivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visibleToDirectivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    visibleToDirectivo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shirtNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shirtNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shirtNumber?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseCreateManyKindInput = {
    id?: string
    userId: string
    title: string
    space?: string | null
    players?: string | null
    duration?: string | null
    description?: string | null
    imageUrl?: string | null
    tags?: ExerciseCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseUpdateWithoutKindInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    space?: NullableStringFieldUpdateOperationsInput | string | null
    players?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ExerciseUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExercisesNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutKindInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    space?: NullableStringFieldUpdateOperationsInput | string | null
    players?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ExerciseUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUncheckedUpdateManyWithoutKindInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    space?: NullableStringFieldUpdateOperationsInput | string | null
    players?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ExerciseUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScoutingPlayerCreateManyCategoriaInput = {
    id?: string
    teamId?: string | null
    fullName: string
    positions?: ScoutingPlayerCreatepositionsInput | string[]
    club?: string | null
    estado?: $Enums.ScoutingStatus
    agentName?: string | null
    agentPhone?: string | null
    agentEmail?: string | null
    playerPhone?: string | null
    playerEmail?: string | null
    instagram?: string | null
    videos?: ScoutingPlayerCreatevideosInput | string[]
    notes?: string | null
    rating?: number | null
    tags?: ScoutingPlayerCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScoutingPlayerUpdateWithoutCategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    positions?: ScoutingPlayerUpdatepositionsInput | string[]
    club?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumScoutingStatusFieldUpdateOperationsInput | $Enums.ScoutingStatus
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    agentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    agentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    playerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    playerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ScoutingPlayerUpdatevideosInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: ScoutingPlayerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutScoutingPlayersNestedInput
  }

  export type ScoutingPlayerUncheckedUpdateWithoutCategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    positions?: ScoutingPlayerUpdatepositionsInput | string[]
    club?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumScoutingStatusFieldUpdateOperationsInput | $Enums.ScoutingStatus
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    agentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    agentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    playerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    playerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ScoutingPlayerUpdatevideosInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: ScoutingPlayerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScoutingPlayerUncheckedUpdateManyWithoutCategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    positions?: ScoutingPlayerUpdatepositionsInput | string[]
    club?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumScoutingStatusFieldUpdateOperationsInput | $Enums.ScoutingStatus
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    agentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    agentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    playerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    playerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ScoutingPlayerUpdatevideosInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: ScoutingPlayerUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TeamCountOutputTypeDefaultArgs instead
     */
    export type TeamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExerciseKindCountOutputTypeDefaultArgs instead
     */
    export type ExerciseKindCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExerciseKindCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScoutingCategoryCountOutputTypeDefaultArgs instead
     */
    export type ScoutingCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScoutingCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamDefaultArgs instead
     */
    export type TeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GlobalConfigDefaultArgs instead
     */
    export type GlobalConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GlobalConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserTeamDefaultArgs instead
     */
    export type UserTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserTeamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RivalDefaultArgs instead
     */
    export type RivalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RivalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerFeedbackDefaultArgs instead
     */
    export type PlayerFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerFeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlaceDefaultArgs instead
     */
    export type PlaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlaceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExerciseKindDefaultArgs instead
     */
    export type ExerciseKindArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExerciseKindDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExerciseDefaultArgs instead
     */
    export type ExerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExerciseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RPEEntryDefaultArgs instead
     */
    export type RPEEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RPEEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WellnessEntryDefaultArgs instead
     */
    export type WellnessEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WellnessEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlannerPrefsDefaultArgs instead
     */
    export type PlannerPrefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlannerPrefsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClinicalEntryDefaultArgs instead
     */
    export type ClinicalEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClinicalEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScoutingCategoryDefaultArgs instead
     */
    export type ScoutingCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScoutingCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerDefaultArgs instead
     */
    export type PlayerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScoutingPlayerDefaultArgs instead
     */
    export type ScoutingPlayerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScoutingPlayerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamVideoDefaultArgs instead
     */
    export type TeamVideoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamVideoDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}